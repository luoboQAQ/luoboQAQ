<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on luoboQAQ</title>
    <link>https://lbqaq.top/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on luoboQAQ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 04 Apr 2022 22:54:54 +0800</lastBuildDate><atom:link href="https://lbqaq.top/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>二分查找是个啥啊</title>
      <link>https://lbqaq.top/p/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%98%AF%E4%B8%AA%E5%95%A5%E5%95%8A/</link>
      <pubDate>Mon, 04 Apr 2022 22:54:54 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%98%AF%E4%B8%AA%E5%95%A5%E5%95%8A/</guid>
      <description>打了两次力扣的周赛，都败在了第三题上，而且都是二分查找的题目。这下不能忍了，必须来总结一波。
第一次二分查找 二分查找是用来在一个有序数组中查找某一元素的算法。它的工作原理如下：
 它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需到右侧查找；如果中间元素大于所查找的值同理，只需到左侧查找。
 使用二分查找就能将原先$\Omicron(n)$时间复杂度的线性查找降低为$\Omicron(\log(n))$。但是一定要注意，二分查找一定要在有序的数组上进行。
下面放上模板：
int binary_search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int left = 0, right = nums.size() - 1; int ret = -1; // 未搜索到数据返回-1下标  int mid; while (left &amp;lt;= right) { mid = left + ((right - left) &amp;gt;&amp;gt; 1); // 直接平均可能会溢出，所以用这个算法  if (nums[mid] &amp;lt; target) left = mid + 1; else if (nums[mid] &amp;gt; target) right = mid - 1; else { // 最后检测相等是因为多数搜索情况不是大于就是小于  ret = mid; break; } } return ret; // 单一出口 } 在上面的代码中，我们每次搜索的是[left,right]这个闭区间，所以在while中要使用&amp;lt;=。</description>
    </item>
    
    <item>
      <title>进制转换和位运算</title>
      <link>https://lbqaq.top/p/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/</link>
      <pubDate>Sun, 03 Apr 2022 09:45:04 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/</guid>
      <description>进制转换 在数学中，不止只有我们常见的10进制，最近刷了几道关于进制转换的题目，在这里做个总结和记录吧。
基本概念 首先我们要先了解进制的基本概念，这里我直接从LeetCode官方这里引用了。
 任何一种进位计数制都有一个基数，基数为 X 的进位计数制称为 X 进制，表示每一个数位上的数运算时都是逢 X 进一。
  对于一个 X 进制的数，其具体数值由其中的每个数码和数码所在的数位决定。整数部分从右往左的第 m 个数位表示的权重是 $X^m$，其中 m 最小为 0；小数部分从左往右的第 n 个数位表示的权重是$X^{-n}$，其中 n 最小为 1。
 八进制的 $720.5$ 可以写成如下形式：
$720.5_{(8)} = 7 \times 8^2 + 2 \times 8^1 + 0 \times 8^0 + 5 \times 8^{-1}$
用我自己的话来说，就是数值*权重
进制转换的一般思路 一般来说，我们习惯将进制转换成十进制，这样便于理解和手算。当然，我们也可以不通过十进制作为中间态过度，比如我们熟悉的二进制和十六进制的转换。
非十进制转十进制 将非十进制数转成十进制数，只要将每个数位的加权和即可。
例如，将八进制数 $720.5_{(8)}$ 转成十进制：
$720.5_{(8)} = 7 \times 8^2 + 2 \times 8^1 + 0 \times 8^0 + 5 \times 8^{-1} = 464.</description>
    </item>
    
    <item>
      <title>初探区间求和问题</title>
      <link>https://lbqaq.top/p/%E5%88%9D%E6%8E%A2%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 14 Mar 2022 20:46:19 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/%E5%88%9D%E6%8E%A2%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/</guid>
      <description>最近看了很多篇关于如何刷题的文章，其中都不约而同的提到了&amp;quot;总结&amp;quot;这个关键词。仔细想想自己确实是从来没有做过一篇总结，刷过的题目就过去了，导致同样的题目再做一次又不会了。
我的第一篇总结就以最近刷到的「区间求和」问题展开吧。首先，先上一般问题的模板（其中加粗的为最佳方案）：
 数组不变，区间查询：前缀和、树状数组、线段树； 数组单点修改，区间查询：树状数组、线段树； 数组区间修改，单点查询：差分、线段树； 数组区间修改，区间查询：线段树。  前缀和 前缀和的作用就是为了帮助我们快速求某一段的和，是「差分」的逆运算。
前缀和数组的每一位记录的是当前位置距离起点位置，这连续一段的和区间和。
一维前缀和 假设有一个一维数组$x$和该数组的一维前缀和数组$y$，则$x$和$y$满足以下关系：
$$y_0=x_0、y_1=x_0+x_1、y_2=x_0+x_1+x_2、&amp;hellip;&amp;hellip;、y_n=x_0+x_1+&amp;hellip;+x_n$$
所以我们可以通过 $y_n=y_{n-1}+x_n$ 这个公式计算出前缀和，代码实现如下：
for (int i = 0; i &amp;lt; n; i++) { if (i == 0) y[i] = x[i]; else y[i] = y[i - 1] + x[i]; } 但是在实际使用中，常常会遇到左边界溢出的情况，为了避免这种情况，我们可以将前缀和数组整体向后移动一位，下面给出前缀给计算代码：
int n = x.size(); vector&amp;lt;int&amp;gt; y(n + 1); for (int i = 1; i &amp;lt;= n; i++) y[i] = y[i - 1] + x[i - 1]; 这样当我们想求区间$[a,b]$之和时只需要计算$y[b+1]-y[a]$即可。</description>
    </item>
    
    <item>
      <title>Qt构建qsqlmysql.dll</title>
      <link>https://lbqaq.top/p/qt%E6%9E%84%E5%BB%BAqsqlmysql.dll/</link>
      <pubDate>Thu, 03 Jun 2021 15:44:17 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/qt%E6%9E%84%E5%BB%BAqsqlmysql.dll/</guid>
      <description>这篇文章我打算来介绍一下如何构建qsqlmysql.dll，由于版权原因，在新版的Qt里是不自带该dll的，这样对我们编写数据库程序会很麻烦。（你用ODBC？那没事了）
我在网上也查了很多资料，但根据步骤来总是会报错，提示没有mysql.h这个头文件。下面就记录一下我成功编译的过程。
基于cmake的步骤 在6.1之后的Qt版本中，Qt公司删除了qmake而更换成了cmake的方式来构建项目文件，下面就是我总结的使用cmake生成的方法。
注意： 路径的前段部分(软件的安装位置)每个人可能都不一样，但是路径的后段部分应该是一样的，请自行修改。
1.准备好Qt的源代码，如果没有可以在Qt的安装目录打开MaintenanceTool.exe启动Qt组件管理，在里面勾选Src把源码下载下来。
2.打开cmake-gui，选择目标文件夹为D:\Qt\6.1.1\Src\qtbase\src\plugins\sqldrivers，并设置生成文件夹为D:/Qt/6.1.1/Src/qtbase/src/plugins/sqldrivers/build
 配置文件夹 
3.点击左下角的Configure，会提示生成的目录不存在是否创建，直接点是就可以了。
4.编译器这里选择MinGW Makefiles,然后点击Finish
 选择编译器 
5.等待生成完成后，把FEATURE_sql_mysql后面的勾勾上，然后把其余的FEATURE_sql后面的勾取消。
 选择生成模块 
6.再次点击左下角的Configure，可以发现上面的红框已经消失了，说明配置成功了。然后点击Generate，生成Makefiles。
 配置成功 
7.这时配置文件已经构建完成了，接下来就是生成dll了，打开PowerShell切换目录至D:/Qt/6.1.1/Src/qtbase/src/plugins/sqldrivers/build，输入mingw32-make开始编译生成dll。
 编译成功 
没有报错，说明生成成功。
8.最后打开目录D:\Qt\6.1.1\Src\qtbase\src\plugins\sqldrivers\build\plugins\sqldrivers，就可以看到生成好的qsqlmysql.dll了。
基于qmake的步骤 注意： 路径的前段部分(软件的安装位置)每个人可能都不一样，但是路径的后段部分应该是一样的，请自行修改。
1.准备好Qt的源代码，如果没有可以在Qt的安装目录打开MaintenanceTool.exe启动Qt组件管理，在里面勾选Src把源码下载下来。
2.进入D:\Qt\6.0.3\Src\qtbase\src\plugins\sqldrivers目录下，打开sqldrivers.pro这个文件。
3.在左侧文件树中打开mysql文件夹，选择mysql.pro打开。
4.修改里面的内容：
  注释掉QMAKE_USE += mysql这一句
  增加下面三行代码(注意把D:/MySQL/改为你MySQL的安装路径)：
LIBS +=-LD:/MySQL/lib -llibmysql INCLUDEPATH += D:/MySQL/include DEPENDPATH += D:/MySQL/include   5.点击Qt左下角的小锤子进行构建，不出意外的话就可以在D:\Qt\6.0.3\Src\qtbase\src\plugins这个路径下看到build开头的文件夹，在.\plugins\sqldrivers目录下就能看到编译好的dll了。
6.最后将qsqlmysql.dll放入D:\Qt\6.0.3\mingw81_64\plugins\sqldrivers\里就行了。如果链接数据库时还报错，就把libmysql.dll复制到Qt的编译器的D:\Qt\6.0.3\mingw81_64\bin\目录。</description>
    </item>
    
    <item>
      <title>竞赛用STL整理</title>
      <link>https://lbqaq.top/p/%E7%AB%9E%E8%B5%9B%E7%94%A8stl%E6%95%B4%E7%90%86/</link>
      <pubDate>Sun, 31 Jan 2021 20:39:29 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/%E7%AB%9E%E8%B5%9B%E7%94%A8stl%E6%95%B4%E7%90%86/</guid>
      <description>最近刷了好几道关于STL的竞赛题，许多知识点还是不熟练，在继续学习之前，还是来好好整理一下一些常见的STL和容器吧。紫书上介绍的有以下几种：
 线性：vector,list,string 关联：map,set 特殊：stack,queue,priority_queue 算法：sort,lower_bound,find  vector vector可以理解为可以自由变换长度的数组(不定长数组)，个人感觉使用频率还是很高的。vector是连续的，意味着可以使用[]或at()。
声明： vector&amp;lt;int&amp;gt; a
常用函数   push_back：在尾部添加一个数据
  pop_back：删除尾部的一个数据
  size：当前的大小（就是有多少元素）
  erase：删除指针指向的数据项
  clear：清空
  empty：判断是否为空
  deque deque可以看作是双向队列，是连续存储结构。vector有的功能它都有，还支持高效的首/尾端插入/删除操作。
新增函数  push_front：在头部添加一个数据 pop_front：在头部删除一个数据  list list可以看作是双链表，是非连续存储结构。可在两端进行push、pop，同时在内部可以很方便的进行插入和删除操作。不过我没怎么用到这个容器。等我做到相关的题目再来补充一些信息吧。
string string就是字符串。相比char[]那可是方便不少，c++的cin/cout就只支持string类型而不支持char型数组。string还支持+、=、+=等运算符。
常用函数   append：在字符串后添加（相当于+=）
  substr(n,m)：返回string的子串，从n处开始，取m个。当m省略或超过了字符串的长度，则一直取到字符串结束。
  查找相关函数：
如果没有查到，返回string::npos。
  find：从前往后查找子串或字符出现的位置。
  rfind：从后往前查找子串或字符出现的位置。
  find_first_of：从前往后查找何处出现另一个字符串中包含的字符。例如：
  s1.find_first_of(&amp;ldquo;abc&amp;rdquo;); //查找s1中第一次出现&amp;quot;abc&amp;quot;中任一字符的位置
  find_last_of：从后往前查找何处出现另一个字符串中包含的字符。</description>
    </item>
    
  </channel>
</rss>
