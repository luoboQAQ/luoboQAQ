<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>二分 on luoboQAQ</title>
    <link>https://lbqaq.top/tags/%E4%BA%8C%E5%88%86/</link>
    <description>Recent content in 二分 on luoboQAQ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 04 Apr 2022 22:54:54 +0800</lastBuildDate><atom:link href="https://lbqaq.top/tags/%E4%BA%8C%E5%88%86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>二分查找是个啥啊</title>
      <link>https://lbqaq.top/p/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%98%AF%E4%B8%AA%E5%95%A5%E5%95%8A/</link>
      <pubDate>Mon, 04 Apr 2022 22:54:54 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%98%AF%E4%B8%AA%E5%95%A5%E5%95%8A/</guid>
      <description>打了两次力扣的周赛，都败在了第三题上，而且都是二分查找的题目。这下不能忍了，必须来总结一波。
第一次二分查找 二分查找是用来在一个有序数组中查找某一元素的算法。它的工作原理如下：
 它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需到右侧查找；如果中间元素大于所查找的值同理，只需到左侧查找。
 使用二分查找就能将原先$\Omicron(n)$时间复杂度的线性查找降低为$\Omicron(\log(n))$。但是一定要注意，二分查找一定要在有序的数组上进行。
下面放上模板：
int binary_search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int left = 0, right = nums.size() - 1; int ret = -1; // 未搜索到数据返回-1下标  int mid; while (left &amp;lt;= right) { mid = left + ((right - left) &amp;gt;&amp;gt; 1); // 直接平均可能会溢出，所以用这个算法  if (nums[mid] &amp;lt; target) left = mid + 1; else if (nums[mid] &amp;gt; target) right = mid - 1; else { // 最后检测相等是因为多数搜索情况不是大于就是小于  ret = mid; break; } } return ret; // 单一出口 } 在上面的代码中，我们每次搜索的是[left,right]这个闭区间，所以在while中要使用&amp;lt;=。</description>
    </item>
    
  </channel>
</rss>
