<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on luoboQAQ</title>
    <link>https://lbqaq.top/post/</link>
    <description>Recent content in Posts on luoboQAQ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 08 Oct 2021 15:19:44 +0800</lastBuildDate><atom:link href="https://lbqaq.top/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>shiro整合JWT</title>
      <link>https://lbqaq.top/p/shiro%E6%95%B4%E5%90%88jwt/</link>
      <pubDate>Fri, 08 Oct 2021 15:19:44 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/shiro%E6%95%B4%E5%90%88jwt/</guid>
      <description>在我现在在做的项目中需要进行身份和权限认证，在网上找了些教程，推荐都是使用JWT来进行身份认证，于是便决定使用此方法来实现。（然而用完了才发现JWT也有缺点）
何为JWT 所谓JWT，全称是JSON Web Token。下面是从官网摘抄的定义：
 JWT是一个开放的标准（RFC 7519），它定义了一种紧凑和独立的方式，以JSON对象的形式在各方之间安全地传输信息。这种信息可以被验证和信任，因为它是经过数字签名的。JWTs可以使用秘密（使用HMAC算法）或使用RSA或ECDSA的公共/私人密钥对进行签名。
 按我的理解，JWT其实就是将传统的session认证中的token存储位置从服务器上下发给用户，服务器只需要判断传来的token是否合法而无需存储。这样做的好处就是可以做分布式的服务器，无需考虑用户是在哪一台服务器上登录的。
详细的定义和构成我这里就不展开了，这里主要关注JWT中Payload（载荷）。这是有效信息存放的地方，我们一般关注这里就行了。
下面是官方提供且建议（并不强制）使用的声明：
  iss: jwt签发者
  sub: 主题
  aud: 接收jwt的一方
  exp: jwt的过期时间，这个过期时间必须要大于签发时间
  nbf: 生效时间，在此时间之前该jwt都是不可用的.
  iat: jwt的签发时间
  jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。
  当然，在载荷中还可以存放自定义的信息，在本项目中使用官方提供的就足以了，故不展开。
认证流程  用户使用用户名密码来请求服务器 服务器进行验证用户的信息 服务器通过验证发送给用户一个token 客户端存储token，并在每次请求时附送上这个token值 服务端验证token值，并返回数据  具体实现 导入依赖包 第一步当然是导入相关依赖了，使用Maven进行包管理。
&amp;lt;!-- shiro --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shiro&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shiro-spring&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.8.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- jwt --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.auth0&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;java-jwt&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.18.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 封装JWT工具类 这里主要实现JWT的生成、验证、提取用户名三个功能</description>
    </item>
    
    <item>
      <title>Vue学习笔记</title>
      <link>https://lbqaq.top/p/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 22 Sep 2021 08:21:14 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>最近看了很久的Vue教程，为了避免之后的遗忘，还是停下脚步，花点时间讲笔记写出来吧。
这篇笔记是基于B站上的尚硅谷Vue2.0+Vue3.0全套教程而成，在此感谢提供这么优秀的学习教程。
Vue2基础 想要学好Vue，那肯定还是从Vue2开始学起。那么这一章主要是Vue2中的基础内容，没有使用到脚手架。
初识Vue 每学一个新的语言，HelloWord是必不可少的。话不多说，上代码：
&amp;lt;!-- 准备好一个容器 --&amp;gt; &amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;Hello，{{name.toUpperCase()}}，{{address}}&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34; &amp;gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。  //创建Vue实例  new Vue({ el:&amp;#39;#demo&amp;#39;, //el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。  data:{ //data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象。  name:&amp;#39;vue&amp;#39;, address:&amp;#39;北京&amp;#39; } }) &amp;lt;/script&amp;gt; 这样就完成了一个基础的Vue程序。
1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；
2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；
3.root容器里的代码被称为【Vue模板】；
4.Vue实例和容器是一一对应的；
5.真实开发中只有一个Vue实例，并且会配合着组件一起使用；
6.{{xxx}}中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；
7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；
Vue模板语法 Vue模板语法有2大类：
1.插值语法：
​ 功能：用于解析标签体内容。
​ 写法：{{xxx}}，xxx是js表达式，且可以直接读取到data中的所有属性。
2.指令语法：
​ 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件&amp;hellip;..）。
​ 举例：v-bind:href=&amp;ldquo;xxx&amp;rdquo; 或 简写为 :href=&amp;ldquo;xxx&amp;rdquo;，xxx同样要写js表达式，
​ 且可以直接读取到data中的所有属性。
​ 备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。
其实很好理解，想要显示在页面上的内容就使用{{value}}这样的写法，而v-bind:则是用于html标签中的属性绑定。
数据绑定 Vue中有2种数据绑定的方式：
​ 1.单向绑定(v-bind)：数据只能从data流向页面。</description>
    </item>
    
    <item>
      <title>Swagger3初体验</title>
      <link>https://lbqaq.top/p/swagger/</link>
      <pubDate>Thu, 09 Sep 2021 15:09:04 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/swagger/</guid>
      <description>最近做项目需要前后端分离，所以需要接口文档给前端方便联调。手写文档是不可能的，这时就需要使用Swagger了。网上的教程大部分版本都在2.x甚至是1.x，很少有3.0的教程，我个人就是喜欢用最新版，所以我就来分享一下我使用Swagger3的体验和坑吧。
配置 这里就分享springboot版本的方法了，现在的项目应该都用springboot创建了吧。
  导入Maven依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springfox-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;   在启动类上加上@EnableOpenApi就行了。
  当然，这样只是默认的，我们要用肯定要配置一下，我们去创建一个Config类，在里面建立一个函数返回Docket类，我们所有的配置就在这个Docket类里配置。
@Configuration @EnableOpenApi public class SwaggerConfig { @Bean public Docket docket(){ return new Docket(DocumentationType.OAS_30)	//3.0版本用OAS_30这个标准  .apiInfo(getApiInfo()) .select() //扫描指定包下的接口  .apis(RequestHandlerSelectors.basePackage(&amp;#34;top.lbqaq.controller&amp;#34;)) .build(); } /** * 配置swagger信息 */ private ApiInfo getApiInfo(){ //这里是作者信息，分别为姓名、个人主页、邮箱  Contact contact = new Contact(&amp;#34;luoboQAQ&amp;#34;,&amp;#34;https://lbqaq.top&amp;#34;,&amp;#34;123@xx.com&amp;#34;); return new ApiInfo( &amp;#34;项目名&amp;#34;, &amp;#34;项目描述&amp;#34;, &amp;#34;版本&amp;#34;, &amp;#34;项目主页&amp;#34;, contact, &amp;#34;Apache 2.0&amp;#34;, &amp;#34;https://www.apache.org/licenses/LICENSE-2.0&amp;#34;, new ArrayList()); } } 这样一个带有个人信息的配置页就做好了。
注解 首先是2.</description>
    </item>
    
    <item>
      <title>使用Webhooks实现自动部署</title>
      <link>https://lbqaq.top/p/%E4%BD%BF%E7%94%A8webhooks%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Mon, 23 Aug 2021 15:44:59 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/%E4%BD%BF%E7%94%A8webhooks%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</guid>
      <description>每次写完博客，需要在本地编译，然后再手动通过WinSCP送到服务器上。作为一个懒人，这上面几步下来还是觉得麻烦，而且每次编译又会生成一顿不需要的文件，于是便决定整点自动化的流程，直接解放双手。
因为我的博客在没买服务器之前都是托管在Github上的，于是自然而然地就想到了Webhook，在每次Push后自动发送消息给服务器，让其自动拉取代码。
网上的教程大多都是在本地编译，然而我觉得既然要懒，就一懒到底吧，编译也直接通过Github Actions来完成就行了。
流程 需要2个Github仓库（1个应该也可以），一个存放网站的源码，一个是存放编译好的html文件。整个工作流程就如下图所示：
 流程图 
步骤 设置脚本 首先要写一个shell脚本，功能很简单就是自动拉取代码。
#!/bin/bash cd /home/luobo/Blog git pull 创建webhook服务后端 这里就直接使用NodeJS来创建，使用的原因很简单，因为已经有现成的插件可以使用了。
首先安装依赖
npm i -S github-webhook-handler npm i -g pm2 然后创建webhook.js作为后端
var http = require(&amp;#39;http&amp;#39;); var spawn = require(&amp;#39;child_process&amp;#39;).spawn; var createHandler = require(&amp;#39;github-webhook-handler&amp;#39;); //注意要将 secret 修改你自己的 var handler = createHandler({ path: &amp;#39;/webhook&amp;#39;, secret: &amp;#39;xxxxx&amp;#39; }); http.createServer(function (req, res) { handler(req, res, function (err) { res.statusCode = 404; res.end(&amp;#39;no such location&amp;#39;); }) }).listen(6666); handler.</description>
    </item>
    
    <item>
      <title>为博客添加评论系统</title>
      <link>https://lbqaq.top/p/waline/</link>
      <pubDate>Sat, 21 Aug 2021 15:37:44 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/waline/</guid>
      <description>一个完整的博客，怎么能少的了评论系统呢。评论的实现已经有许许多多的方法了，挑来挑去，还是选择了Waline。
一开始我是采用官方推荐的LeanCloud+Vercel的方式进行部署的，结果步骤全部走完后才发现Vercel已经在国内被墙了，不科学根本上不去😇。总不能要求用户还要开梯子才能评论吧，所幸官方提供了其他的部署方式，因为我才买了自己的服务器~~（不榨干怎么行呢）~~，所以就选择本地部署+SQLlite的方式了。
部署步骤 安装node.js 由于Waline的服务端是由js写的，所以需要安装node.js
  在nodejs中文网找到需要的版本，选择阿里云镜像，将下载链接复制下来
  连接服务器，选择nodejs的安装目录，这里我安装在/usr/local/bin/
cd /usr/local/bin/   下载安装包到本地
wget https://npm.taobao.org/mirrors/node/v14.17.5/node-v14.17.5-linux-x64.tar.gz   解压
tar -xvf node-v14.17.5-linux-x64.tar.gz   重命名目录
mv node-v14.17.5-linux-x64 nodejs   添加目录到系统变量
cd /etc/profile.d vim custom.sh 在文件末尾添加export PATH=$PATH:/usr/local/bin/nodejs/bin
  测试，输入下面3条命令，如果不报错则安装成功。
node -v npm version npx -v   （可选）安装cnpm
npm install -g cnpm --registry=https://registry.npm.taobao.org   安装Waline服务端   安装waline的服务端
npm install -g @waline/vercel   配置数据库。这里我采用的是SQLite，只需要下载 waline.sqlite 文件至合适的位置。</description>
    </item>
    
    <item>
      <title>SpringMVC学习笔记</title>
      <link>https://lbqaq.top/p/springmvc/</link>
      <pubDate>Sun, 15 Aug 2021 09:06:00 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/springmvc/</guid>
      <description>SpringMVC也告一段落了，终于要到SpringBoot了。
还是和之前一样，笔记是基于遇见狂神说的SpringMVC视频教程而来，在此感谢能提供这么优秀的教程。
回顾MVC 什么是MVC  MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 将业务逻辑、数据、显示分离的方法来组织代码。  **Model（模型）：**数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。
拓展：在前端数据传输给后端时，有些字段是不需要的，这是可能会细分出Vo层（视图）
比如：用户有账号、密码、年龄等一系列字段
这时前端登录只传了账号密码
此时可以用UserVo来表示，里面只有账号和密码
**View（视图）：**负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。
**Controller（控制器）：**接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。
最典型的MVC就是JSP + servlet + javabean的模式。
 用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面  职责分析：
Controller：控制器
 取得表单数据 调用业务逻辑 转向指定的页面  Model：模型
 业务逻辑 保存数据的状态  View：视图
 显示页面  复习Servlet   父工程添加依赖
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.13&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.3.9&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.servlet.jsp&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jsp-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.</description>
    </item>
    
    <item>
      <title>Spring学习笔记</title>
      <link>https://lbqaq.top/p/spring/</link>
      <pubDate>Thu, 12 Aug 2021 09:38:02 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/spring/</guid>
      <description>花了3天时间，Spring也终于看完了,SSM已经干完了两个了，感觉人都要没了😇。还是老样子，留下笔记以免遗忘。
下面的内容都是基于遇见狂神说的Spring5视频教程而来，在此感谢能提供这么优秀的教程。
Spring 简介 Spring就是用来简化Java开发的，只能说学Java不学Spring，就像读四大名著不读红楼梦&amp;hellip;&amp;hellip;
2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。
2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。
很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。
Spring理念 : 使现有技术更加实用。 本身就是一个大杂烩 , 整合现有的框架技术。
SSM：SpringMVC+Spring+MyBatis
几个常用的网址：
  官网
  官方文档（英文）
  中文文档
  GitHub
  &amp;lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.3.9&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.3.9&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 优点   Spring是一个开源免费的框架 , 容器
  Spring是一个轻量级的框架 , 非侵入式的
  控制反转（IoC）,面向切面（Aop）
  对事务的支持 , 对框架的支持
  一句话概括：</description>
    </item>
    
    <item>
      <title>从零开始ASF挂卡</title>
      <link>https://lbqaq.top/p/asf/</link>
      <pubDate>Wed, 11 Aug 2021 21:46:24 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/asf/</guid>
      <description>因为买了一台云服务器，不拿来干点啥实在是太亏了，于是便想到了可以使用云服务器来挂卡。
步骤 安装.net环境 ASF是基于.netcore开发的程序，所以需要安装环境。这里建议看微软官方的安装文档，里面有不同系统的安装方法。
我们需要安装的只是ASP.NET Core 运行时。
我的系统是centos7，这里就只列举我系统上的命令了。
sudo rpm -Uvh https://packages.microsoft.com/config/centos/7/packages-microsoft-prod.rpm sudo yum install aspnetcore-runtime-5.0 安装ASF 在ASF的发布页面上下载系统对应的版本解压即可。
我这里是在本地先下载好后用WinSCP直接传上服务器。
配置ASF 这里就采用官方的**在线配置文件生成器**自动生成即可。
我们这里选择机器人，将steam的账号和密码填入，并将Enabled设置为True就行了。
详细的配置内容可以在官方Wiki上看到，这里就不再赘述了。
下面放上我的配置文件：
{ &amp;#34;SteamLogin&amp;#34;: &amp;#34;xxx&amp;#34;, &amp;#34;SteamPassword&amp;#34;: &amp;#34;xxx&amp;#34;, &amp;#34;Enabled&amp;#34;: true, &amp;#34;CustomGamePlayedWhileFarming&amp;#34;: &amp;#34;挂卡中...&amp;#34;, &amp;#34;CustomGamePlayedWhileIdle&amp;#34;: &amp;#34;空闲中...&amp;#34;, &amp;#34;FarmingOrders&amp;#34;: [ 15, 12 ], &amp;#34;HoursUntilCardDrops&amp;#34;: 0, &amp;#34;OnlineStatus&amp;#34;: 1 }  CustomGamePlayedWhileFarming：表示挂卡时显示的游戏名 CustomGamePlayedWhileIdle：表示空闲时显示的游戏名 HoursUntilCardDrops：表示至少将游戏挂到几小时，如果是非限制账户，调到0是最好的。  我们也可以配置ASF本身的设置，这里也同样贴上我的配置：
{ &amp;#34;s_SteamOwnerID&amp;#34;: &amp;#34;xxx&amp;#34;, &amp;#34;CurrentCulture&amp;#34;: &amp;#34;zh-CN&amp;#34;, &amp;#34;IPCPassword&amp;#34;: &amp;#34;xxx&amp;#34; }  s_SteamOwnerID：该属性定义 ASF 进程所有者的 64 位 Steam ID，直接设置成自己的大号就行 CurrentCulture：ASF的语言 IPCPassword：由于ASF默认会开启IPC服务，为了安全起见建议设置密码或关闭IPC服务。  将配置文件放入config目录里就行了。</description>
    </item>
    
    <item>
      <title>MyBatis学习笔记</title>
      <link>https://lbqaq.top/p/mybatis/</link>
      <pubDate>Wed, 11 Aug 2021 11:11:10 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/mybatis/</guid>
      <description>花了四天的时间，终于把MyBatis的视频教程全部看完了，为了以后不要那么快的遗忘掉，还是来写一下笔记比较好。
下面的内容都是基于遇见狂神说的MyBatis视频教程而来，在此感谢能提供这么优秀的教程。
简介  MyBatis的作用用我自己的话说，就是不用自己手动搞JDBC了，省事，行！ MyBatis作用于持久层——DAO层 【DAO (Data Access Object) 数据访问对象】，通俗点说就是用来操作数据库的层 选择MyBatis的最大原因还是用的人多，为后面的Spring打基础_(:з)∠)_  第一个MyBatis程序 思路流程：搭建环境&amp;ndash;&amp;gt;导入MyBatis&amp;mdash;&amp;gt;编写代码&amp;mdash;&amp;gt;测试
具体代码   创建Maven项目
  引入依赖包
&amp;lt;!-- 导入依赖 --&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;!-- mysql驱动 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;8.0.25&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- mybatis --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.7&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- junit --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt;   在resources目录下创建mybatis-config.xml，作为MyBatis的配置文件
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34; ?&amp;gt; &amp;lt;!DOCTYPE configuration PUBLIC &amp;#34;-//mybatis.org//DTD Config 3.0//EN&amp;#34; &amp;#34;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;#34;&amp;gt; &amp;lt;!--核心配置文件--&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;environments default=&amp;#34;development&amp;#34;&amp;gt; &amp;lt;environment id=&amp;#34;development&amp;#34;&amp;gt; &amp;lt;transactionManager type=&amp;#34;JDBC&amp;#34;/&amp;gt; &amp;lt;dataSource type=&amp;#34;POOLED&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;driver&amp;#34; value=&amp;#34;com.</description>
    </item>
    
    <item>
      <title>Qt构建qsqlmysql.dll</title>
      <link>https://lbqaq.top/p/qt%E6%9E%84%E5%BB%BAqsqlmysql.dll/</link>
      <pubDate>Thu, 03 Jun 2021 15:44:17 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/qt%E6%9E%84%E5%BB%BAqsqlmysql.dll/</guid>
      <description>这篇文章我打算来介绍一下如何构建qsqlmysql.dll，由于版权原因，在新版的Qt里是不自带该dll的，这样对我们编写数据库程序会很麻烦。（你用ODBC？那没事了）
我在网上也查了很多资料，但根据步骤来总是会报错，提示没有mysql.h这个头文件。下面就记录一下我成功编译的过程。
基于cmake的步骤 在6.1之后的Qt版本中，Qt公司删除了qmake而更换成了cmake的方式来构建项目文件，下面就是我总结的使用cmake生成的方法。
注意： 路径的前段部分(软件的安装位置)每个人可能都不一样，但是路径的后段部分应该是一样的，请自行修改。
1.准备好Qt的源代码，如果没有可以在Qt的安装目录打开MaintenanceTool.exe启动Qt组件管理，在里面勾选Src把源码下载下来。
2.打开cmake-gui，选择目标文件夹为D:\Qt\6.1.1\Src\qtbase\src\plugins\sqldrivers，并设置生成文件夹为D:/Qt/6.1.1/Src/qtbase/src/plugins/sqldrivers/build
 配置文件夹 
3.点击左下角的Configure，会提示生成的目录不存在是否创建，直接点是就可以了。
4.编译器这里选择MinGW Makefiles,然后点击Finish
 选择编译器 
5.等待生成完成后，把FEATURE_sql_mysql后面的勾勾上，然后把其余的FEATURE_sql后面的勾取消。
 选择生成模块 
6.再次点击左下角的Configure，可以发现上面的红框已经消失了，说明配置成功了。然后点击Generate，生成Makefiles。
 配置成功 
7.这时配置文件已经构建完成了，接下来就是生成dll了，打开PowerShell切换目录至D:/Qt/6.1.1/Src/qtbase/src/plugins/sqldrivers/build，输入mingw32-make开始编译生成dll。
 编译成功 
没有报错，说明生成成功。
8.最后打开目录D:\Qt\6.1.1\Src\qtbase\src\plugins\sqldrivers\build\plugins\sqldrivers，就可以看到生成好的qsqlmysql.dll了。
基于qmake的步骤 注意： 路径的前段部分(软件的安装位置)每个人可能都不一样，但是路径的后段部分应该是一样的，请自行修改。
1.准备好Qt的源代码，如果没有可以在Qt的安装目录打开MaintenanceTool.exe启动Qt组件管理，在里面勾选Src把源码下载下来。
2.进入D:\Qt\6.0.3\Src\qtbase\src\plugins\sqldrivers目录下，打开sqldrivers.pro这个文件。
3.在左侧文件树中打开mysql文件夹，选择mysql.pro打开。
4.修改里面的内容：
  注释掉QMAKE_USE += mysql这一句
  增加下面三行代码(注意把D:/MySQL/改为你MySQL的安装路径)：
LIBS +=-LD:/MySQL/lib -llibmysql INCLUDEPATH += D:/MySQL/include DEPENDPATH += D:/MySQL/include   5.点击Qt左下角的小锤子进行构建，不出意外的话就可以在D:\Qt\6.0.3\Src\qtbase\src\plugins这个路径下看到build开头的文件夹，在.\plugins\sqldrivers目录下就能看到编译好的dll了。
6.最后将qsqlmysql.dll放入D:\Qt\6.0.3\mingw81_64\plugins\sqldrivers\里就行了。如果链接数据库时还报错，就把libmysql.dll复制到Qt的编译器的D:\Qt\6.0.3\mingw81_64\bin\目录。</description>
    </item>
    
    <item>
      <title>WSL2&#43;WT配置小结</title>
      <link>https://lbqaq.top/p/wsl2-wt%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93/</link>
      <pubDate>Thu, 08 Apr 2021 13:14:20 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/wsl2-wt%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93/</guid>
      <description>1202年了，是时候抛弃老旧的cmd窗口和臃肿的VM虚拟机了，来试试巨硬推出的WSL2+Windows Terminal(～￣▽￣)～。
起因 在知乎上刷到了一篇回答，是关于Windows编程的体验的。在这篇文章中提到了WSL2和Windows Terminal，我一下就被那精美的界面吸引了（管他好不好用，好看就完事了）。正好现在在上操作系统这门课，需要使用Linux进行实验，这还说什么，直接开冲。
 精美的界面 
WSL2安装 安装其实很简单，按照微软的教程一步一步做就完事了。
0.前置条件 想要用WSL2，首先你得是 Windows 10，而且还有版本号要求。
 对于 x64 系统：版本 1903 或更高版本，采用 内部版本 18362 或更高版本。 对于 ARM64 系统：版本 2004 或更高版本，采用 内部版本 19041 或更高版本。  1. 开启WSL服务 在Powershell(管理员)中输入下面的命令：
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 2. 启用虚拟机服务 在Powershell(管理员)中输入下面的命令：
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 重新启动 计算机，以完成 WSL 安装并更新到 WSL 2。
3. 下载 Linux 内核更新包 下载最新包并安装：
 适用于 x64 计算机的 WSL2 Linux 内核更新包  4. 将 WSL 2 设置为默认版本 在Powershell中输入下面的命令：</description>
    </item>
    
    <item>
      <title>PyAipao</title>
      <link>https://lbqaq.top/p/pyaipao/</link>
      <pubDate>Thu, 11 Mar 2021 10:25:00 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/pyaipao/</guid>
      <description>PyAipao简介 该项目可实现阳光体育一键跑步，同时可基于GitHub Actions来实现云跑步。
仅需一次配置，即可轻松跑完一学期ヾ(≧▽≦*)o
准备工作 1.一个github账号 2.抓包抓到的IMEICode 3.Server酱的SCKEY或企业微信（可选，用于微信推送跑步结果）  云跑步上手教程 1.点击fork按钮将该仓库复制到你的仓库  fork 
2.获取 IMEICode
 打开抓包软件抓包, 再打开阳光体育 App 登录, 在所有的数据包中找后缀有 IMEICode=  的 URL 请求, 等号后面的字段即为七天有效的 IMEICode (若多次没抓到: 可来回切换几次飞行模式, 杀掉 App 后台重复尝试多次)  如果不需要推送，可以直接略过第3步
3.1基于Server酱的推送
 完成Server酱的注册和绑定 点我直达 在 SendKey这一页中找到SendKey并记录  SendKey   3.2基于企业微信应用消息的推送
由于Server酱不捐助是无法查看消息内容的，所以为了白嫖我自己写了推送部分的代码，可以直接使用微信官方接口来推送。
企业微信的配置方法可以在Server酱的消息通道里看到，这里就不赘述了。
 weisend 
和Server酱一样，我们也需要企业ID(CORPID)，应用ID(AGENTID)，应用Secret(SECRET)这三个值。
4.配置Github Actions
  打开仓库的secrets，在其中建立IMEICODE并将IMEICode填入  4.1 
  （可选）使用Server酱推送，需要建立SCKEY并填入SendKey
  （可选）使用企业微信应用消息推送，需要建立CORPID&amp;ndash;填入企业ID，AGENTID&amp;ndash;填入应用ID，SECRET&amp;ndash;填入应用Secret
  打开Code-.github/workflows-autorun.yml，点击右上角的铅笔图标进行编辑，将时间改为你想让它每天按时跑的时间，默认为每天上午9点；同时修改推送方式，默认不推送。</description>
    </item>
    
    <item>
      <title>给Blog增加动画</title>
      <link>https://lbqaq.top/p/%E7%BB%99blog%E5%A2%9E%E5%8A%A0%E5%8A%A8%E7%94%BB/</link>
      <pubDate>Mon, 01 Feb 2021 13:55:05 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/%E7%BB%99blog%E5%A2%9E%E5%8A%A0%E5%8A%A8%E7%94%BB/</guid>
      <description>看到zsnmwy大佬的博客，和我使用的是同样的主题，但是人家却多了一些动画，瞬间就高级起来了。于是打开百度搜素一波，发现只要改一下CSS就可以实现了。
准备工具   hugo的扩展版（extended）
这里一定要下扩展版，因为我使用的主题都是利用scss来生成css的，如果用普通版是无法利用scss生成对应的css的。之前不知道下的是普通版，结果怎么改scss都没有效果，浪费了很多时间😥。
  相关代码 1.头像转动 在themes/hugo-theme-stack/assets/scss/partials/sidebar.scss中增加以下代码：
.site-logo { transition: all 1.75s ease-out; } .site-logo:hover { transform: rotate(360deg); } 2.文章头图缩放 在themes/hugo-theme-stack/assets/scss/partials/article.scss中增加以下代码：
.article-image { overflow:hidden; } .article-image { img { transition:all .5s ease; } &amp;amp;:hover{ transform:scale(1.2); } 3.Archives页面缩放 在themes/hugo-theme-stack/assets/scss/partials/article.scss中增加以下代码：
article{ transition:.5s ease; } article { &amp;amp;:hover{ transform:scale(1.05,1.05); background:#f0f8ff; } } 4.菜单缩放 在themes/hugo-theme-stack/assets/scss/partials/menu.scss中增加以下代码：
overflow-y: visible; //把auto改为visible，为了图标放大溢出时不显示滚动条 li { transition:.5s ease; } li{ &amp;amp;:hover{ transform:scale(1.1,1.1); } } 有了动画后，感觉整个博客都变得高级起来了ヾ(•ω•`)o
在这感谢zsnmwy大佬，上面有些动画懒得自己写了，就直接从他的css中复制了ヾ(￣▽￣)</description>
    </item>
    
    <item>
      <title>竞赛用STL整理</title>
      <link>https://lbqaq.top/p/%E7%AB%9E%E8%B5%9B%E7%94%A8stl%E6%95%B4%E7%90%86/</link>
      <pubDate>Sun, 31 Jan 2021 20:39:29 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/%E7%AB%9E%E8%B5%9B%E7%94%A8stl%E6%95%B4%E7%90%86/</guid>
      <description>最近刷了好几道关于STL的竞赛题，许多知识点还是不熟练，在继续学习之前，还是来好好整理一下一些常见的STL和容器吧。紫书上介绍的有以下几种：
 线性：vector,list,string 关联：map,set 特殊：stack,queue,priority_queue 算法：sort,lower_bound,find  vector vector可以理解为可以自由变换长度的数组(不定长数组)，个人感觉使用频率还是很高的。vector是连续的，意味着可以使用[]或at()。
声明： vector&amp;lt;int&amp;gt; a
常用函数   push_back：在尾部添加一个数据
  pop_back：删除尾部的一个数据
  size：当前的大小（就是有多少元素）
  erase：删除指针指向的数据项
  clear：清空
  empty：判断是否为空
  deque deque可以看作是双向队列，是连续存储结构。vector有的功能它都有，还支持高效的首/尾端插入/删除操作。
新增函数  push_front：在头部添加一个数据 pop_front：在头部删除一个数据  list list可以看作是双链表，是非连续存储结构。可在两端进行push、pop，同时在内部可以很方便的进行插入和删除操作。不过我没怎么用到这个容器。等我做到相关的题目再来补充一些信息吧。
string string就是字符串。相比char[]那可是方便不少，c++的cin/cout就只支持string类型而不支持char型数组。string还支持+、=、+=等运算符。
常用函数   append：在字符串后添加（相当于+=）
  substr(n,m)：返回string的子串，从n处开始，取m个。当m省略或超过了字符串的长度，则一直取到字符串结束。
  查找相关函数：
如果没有查到，返回string::npos。
  find：从前往后查找子串或字符出现的位置。
  rfind：从后往前查找子串或字符出现的位置。
  find_first_of：从前往后查找何处出现另一个字符串中包含的字符。例如：
  s1.find_first_of(&amp;ldquo;abc&amp;rdquo;); //查找s1中第一次出现&amp;quot;abc&amp;quot;中任一字符的位置
  find_last_of：从后往前查找何处出现另一个字符串中包含的字符。</description>
    </item>
    
    <item>
      <title>数据结构算法复习</title>
      <link>https://lbqaq.top/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Sun, 10 Jan 2021 15:06:20 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</guid>
      <description>考前整理的算法，也顺便放到博客上吧ヾ(•ω•`)o
数据结构代码复习 3.单链表逆置 带头结点
int Inverse_Link(LinkList *L) { LinkList *cur, *p; if (L-&amp;gt;next &amp;amp;&amp;amp; L-&amp;gt;next-&amp;gt;next) { p = L-&amp;gt;next-&amp;gt;next; L-&amp;gt;next-&amp;gt;next = NULL; while (p) { cur = L-&amp;gt;next; L-&amp;gt;next = p; p = p-&amp;gt;next; L-&amp;gt;next-&amp;gt;next = cur; } } return 0; } 5.双向链表 双链表定义：
typedef struct DuLinkList { int data; struct DuLinkList *prior; struct DuLinkList *next; } DuLinkList; 遍历：
void Printlist_DuL(DuLinkList *L) { DuLinkList *s; s = L-&amp;gt;next; if (L-&amp;gt;next !</description>
    </item>
    
    <item>
      <title>C语言生成随机数</title>
      <link>https://lbqaq.top/p/c%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</link>
      <pubDate>Tue, 22 Dec 2020 19:36:53 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/c%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</guid>
      <description>生成随机数 在C语言中，生成随机数可以使用stdlib.h头文件里的rand()来生成，例如：
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;int main(){ int a = rand(); printf(&amp;#34;%d\n&amp;#34;,a); return 0; } rand() 会随机生成一个位于 0 ~ RAND_MAX 之间的整数。
但是这样生成的随机数每次开启程序都是一样的，则需要使用srand()来重新播种，一般常与&amp;lt;time.h&amp;gt;里的time()函数一起使用。
srand((unsigned)time(NULL)); 连续生成多个随机数 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;time.h&amp;gt;int main() { int a, i; srand((unsigned)time(NULL)); //使用for循环生成10个随机数  for (i = 0; i &amp;lt; 10; i++) { a = rand(); printf(&amp;#34;%d &amp;#34;, a); } return 0; } 生成指定范围的随机数 想要生成指定范围的随机数，只要进行%运算就好了
int a = rand() % 10; //产生0~9的随机数 int a = rand() % 10 + 1; //产生1~10的随机数 连续生成不重复的随机数 这就是本文的重点了ヾ(•ω•`)o （其实就是为了记下这个算法才水了一篇文章）</description>
    </item>
    
    <item>
      <title>Git的常用命令</title>
      <link>https://lbqaq.top/p/git/</link>
      <pubDate>Wed, 16 Dec 2020 13:16:45 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/git/</guid>
      <description>基本操作 建立版本库：git init
查看结果：git status
查看不同：git diff
版本回退 查看提交日记：git log
回退：git reset --hard HEAD^
HEAD^表示上一个版本，HEAD^^表示前两个版本，HEAD~100表示前100个版本
恢复：git reflog查看命令历史，确定回到未来的哪个版本
撤销修改  直接丢弃工作区的修改时，用命令git checkout -- file 已经添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &amp;lt;file&amp;gt;，第二步按1操作。  上传 git remote add origin 仓库链接 #将远程仓库和本地仓库绑定 git add . git commit -m &amp;quot;提交信息&amp;quot; git push -u origin 自己当前的分支名 #-u将本地库和远程库的分支关联，之后可以不加 下载 git clone 仓库链接 git clone到当前文件夹
git clone 仓库链接 . 分支管理 创建与合并分支 查看分支：git branch
创建分支：git branch &amp;lt;name&amp;gt;
切换分支：git checkout &amp;lt;name&amp;gt;或者git switch &amp;lt;name&amp;gt;</description>
    </item>
    
    <item>
      <title>Blog常用的命令</title>
      <link>https://lbqaq.top/p/blog%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Tue, 15 Dec 2020 18:02:14 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/blog%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/</guid>
      <description>主题相关 FrontMatter 字段含义
title: 标题 description: 描述 image: 显示的特色图片 comments: 显示 / 隐藏评论区(T/F) license: 文章协议 输入 false 可以隐藏 hidden: 隐藏文章（不在首页，归档等页面显示，但是可以直接通过链接访问） math: 是否加载 KaTeX 脚本 slug: 固定链接 draft: 是否为草稿 categories: 分类 tags: 标签 lastmod: 上次更新时间 MarkDown相关 # 我是一级标题 ## 我是二级标题 可对应1-6级标题 *斜体文本* **粗体文本** ***粗斜体文本*** 一行中用三个以上的星号*、减号-、底线_来建立一个分隔线 ~~删除线~~ &amp;lt;u&amp;gt;带下划线文本&amp;lt;/u&amp;gt; 创建脚注格式类似这样 [^JiaoZhu]。 [^JiaoZhu]: 脚注的内容 列表：*、+、-、1. &amp;gt; 区块 [链接文本](网址) 图片在前加! | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 </description>
    </item>
    
  </channel>
</rss>
