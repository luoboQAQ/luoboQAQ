<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on luoboQAQ</title>
    <link>https://lbqaq.top/post/</link>
    <description>Recent content in Posts on luoboQAQ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 17 May 2022 22:45:18 +0800</lastBuildDate><atom:link href="https://lbqaq.top/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>数据可视化笔记</title>
      <link>https://lbqaq.top/p/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 17 May 2022 22:45:18 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0/</guid>
      <description>主成分分析(PCA) 基本思想 PCA顾名思义，就是找出数据里最主要的方面，用数据里最主要的方面来代替原始数据。具体的，假如我们的数据集是n维的，共有m个数据$(x^{(1)},x^{(2)},&amp;hellip;,x^{(m)})$。我们希望将这m个数据的维度从n维降到n&amp;rsquo;维，希望这m个n&amp;rsquo;维的数据集尽可能的代表原始数据集。
通过计算数据矩阵的协方差矩阵，然后得到协方差矩阵的特征值特征向量，选择特征值最大(即方差最大)的k个特征所对应的特征向量组成的矩阵。这样就可以将数据矩阵转换到新的空间当中，实现数据特征的降维。
由于得到协方差矩阵的特征值特征向量有两种方法：特征值分解协方差矩阵、奇异值分解协方差矩阵，所以PCA算法有两种实现方法：基于特征值分解协方差矩阵实现PCA算法、基于SVD分解协方差矩阵实现PCA算法。
特征值分解(EVD) 特征值和特征向量的定义如下：
$$ Ax=\lambda x $$
其中A是一个$n \times n$的实对称矩阵，$x$是一个$n$维向量，则我们说$\lambda$是矩阵A的一个特征值，而$x$是矩阵A的特征值$\lambda$所对应的特征向量。
求出特征值和特征向量有什么好处呢？ 就是我们可以将矩阵A特征分解。如果我们求出了矩阵A的$n$个特征值$\lambda_1 \leq \lambda_2 \leq &amp;hellip; \leq \lambda_n$,以及这$n$个特征值所对应的特征向量${q_1,q_2,&amp;hellip;q_n}$，如果这$n$个特征向量线性无关，那么矩阵A就可以用下式的特征分解表示：$A=Q\Sigma Q^{-1}$ 。
其中，Q是这个矩阵A的特征向量组成的矩阵，Σ是一个对角矩阵，每一个对角线元素就是一个特征值，里面的特征值是由大到小排列的，这些特征值所对应的特征向量就是描述这个矩阵变化方向（从主要的变化到次要的变化排列）。也就是说矩阵A的信息可以由其特征值和特征向量表示。
注意到要进行特征分解，矩阵A必须为方阵。那么如果A不是方阵，即行和列不相同时，我们还可以对矩阵进行分解吗？答案是可以，此时我们的SVD登场了。
奇异值分解(SVD) SVD也是对矩阵进行分解，但是和特征分解不同，SVD并不要求要分解的矩阵为方阵。假设我们的矩阵A是一个$m \times n$的矩阵，那么我们定义矩阵A的SVD为：
$$ A = U\Sigma V^T $$
其中U是一个$m \times m$的矩阵，$\Sigma$是一个$m \times n$的矩阵，除了主对角线上的元素以外全为0，主对角线上的每个元素都称为奇异值，V是一个$n \times n$的矩阵。
计算方法：
 我们将A的转置和A做矩阵乘法，那么会得到$n \times n$的一个方阵$A^TA$。对其进行特征值分解，得到n个特征值和对应的n个特征向量$v$了。将$A^TA$的所有特征向量张成一个$n \times n$的矩阵V，就是我们SVD公式里面的V矩阵了。 对$AA^T$进行特征值分解，得到m个特征值和对应的m个特征向量$u$了。将$AA^T$的所有特征向量张成一个$m \times m$的矩阵U，就是我们SVD公式里面的U矩阵了。一般我们将U中的每个特征向量叫做A的左奇异向量。 由于奇异值矩阵$\Sigma$除了对角线上是奇异值其他位置都是0，那我们只需要求出每个奇异值$\sigma$就可以了。求解奇异值可以用$\sigma_i = Av_i / u_i$或$\sigma_i = \sqrt{\lambda_i}$  算法过程 输入：n维样本集$D=(x^{(1)}, x^{(2)},&amp;hellip;,x^{(m)})$，要降维到的维数n&#39;.
输出：降维后的样本集$D&#39;$
 对所有的样本进行中心化： $x^{(i)} = x^{(i)} - \frac{1}{m}\sum\limits_{j=1}^{m} x^{(j)}$ 计算样本的协方差矩阵$XX^T$ 对矩阵$XX^T$进行特征值分解 取出最大的n&amp;rsquo;个特征值对应的特征向量$(w_1,w_2,&amp;hellip;,w_{n&amp;rsquo;})$, 将所有的特征向量标准化后，组成特征向量矩阵W。 对样本集中的每一个样本$x^{(i)}$,转化为新的样本$z^{(i)}=W^Tx^{(i)}$ 得到输出样本集$D&amp;rsquo; =(z^{(1)}, z^{(2)},&amp;hellip;,z^{(m)})$  上面是采用EVD，如果采用SVD，在第二第三步时就用SVD进行解决。</description>
    </item>
    
    <item>
      <title>分类算法学习笔记</title>
      <link>https://lbqaq.top/p/%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 10 May 2022 14:00:16 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>分类算法的作用 分类是在一群已经知道类别标号的样本中，训练一种分类器，让其能够对某种未知的样本进行分类。分类算法属于一种有监督的学习。分类算法的分类过程就是建立一种分类模型来描述预定的数据集或概念集，通过分析由属性描述的数据库元组来构造模型。分类的目的就是使用分类对新的数据集进行划分，其主要涉及分类规则的准确性、过拟合、矛盾划分的取舍等。
 有监督学习和无监督学习的区别  有监督学习是指数据集的正确输出已知情况下的一类学习算法。因为输入和输出已知，意味着输入和输出之间有一个关系，监督学习算法就是要发现和总结这种“关系”。 无监督学习是指对无标签数据的一类学习算法。因为没有标签信息，意味着需要从数据集中发现和总结模式或者结构。 简单来说，是否有监督（supervised），就看输入数据是否有标签（label）    交叉验证 基本思想 交叉验证的基本思想是把在某种意义下将原始数据(dataset)进行分组，一部分做为训练集(train set)，另一部分做为验证集(validation set or test set)，首先用训练集对分类器进行训练，再利用验证集来测试训练得到的模型(model)，以此来做为评价分类器的性能指标。用交叉验证的目的是为了得到可靠稳定的模型。
K折交叉验证(K-fold cross-validation) K折交叉验证就是进行多次train_test_split划分；每次划分时，在不同的数据集上进行训练、测试评估，从而得出一个评价结果；如果是10折交叉验证，意思就是在原始数据集上，进行10次划分，每次划分进行一次训练、评估，最后得到10次划分后的评估结果，一般在这几次评估结果上取平均得到最后的评分。其中，k一般取5或10。
K折交叉验证的步骤：
 将原始数据集划分为相等的K部分（“折”） 将第1部分作为测试集，其余作为训练集 训练模型，计算模型在测试集上的准确率 每次用不同的部分作为测试集，重复步骤2和3 K次 将平均准确率作为最终的模型准确率   10折交叉验证 
 💡 要会给定数据集进行K折交叉验证 要会计算模型准确率（每次的准确率、最终的准确率）
 支持向量机(SVM) 基本思想 SVM学习的基本思想是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。对于线性可分的数据集来说，这样的超平面有无穷多个（即感知机），但是几何间隔最大的分离超平面却是唯一的。
 SVM基本思想 
用我自己的理解，就是找一条线将两个数据集分开，要保证这条线到两边的数据集距离最大。那么，如何才能保证距离最大呢，这就是下面要讨论的难点了。
支持向量  在支持向量机中，距离超平面最近的且满足一定条件的几个训练样本点被称为支持向量。
 在上图中，处于虚线上的点（即红色的点）我们就将其定义为支持向量。那么，如何得到支持向量到超平面的距离呢？我们引入几何间隔的概念：
$$ \gamma = \frac{y(w^Tx + b)}{||w||_2} = \frac{\gamma^{&amp;rsquo;}}{||w||_2} $$
一般我们都取函数间隔$\gamma^{&amp;rsquo;}$为1，这样我们就可以得到支持向量到超平面的距离为$\frac{1}{||w||_2}$，两个支持向量之间的距离为$\frac{2}{||w||_2}$
SVM模型目标函数 SVM的模型是让所有点到超平面的距离大于一定的距离，也就是所有的分类点要在各自类别的支持向量两边。用数学式子表示为：
$$ max \;\; \frac{1}{||w||_2} \;\; s.t \;\; y_i(w^Tx_i + b) \geq 1 (i =1,2,&amp;hellip;m) $$</description>
    </item>
    
    <item>
      <title>聚类算法学习笔记</title>
      <link>https://lbqaq.top/p/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 10 May 2022 08:23:41 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>Kmeans 算法步骤  从样本中选择 K 个点作为初始质心（完全随机） 计算每个样本到各个质心的距离，将样本划分到距离最近的质心所对应的簇中 计算每个簇内所有样本的均值，并使用该均值更新簇的质心 重复步骤 2 与 3 ，直到达到以下条件之一：  质心的位置变化小于指定的阈值（默认为 0.0001） 达到最大迭代次数    欧氏距离  衡量的是多维空间中两个点之间的绝对距离
 在二维和三维空间中的欧氏距离就是两点之间的实际距离
计算方法：对应坐标值相减的平方和再开方
$$ dist(X,Y)=\sqrt{\sum_{i=1}^{n}(x_i-y_i)^2} $$
对于二维来说，就是
$$ dist(X,Y)=\sqrt{(x_1-y_1)^2+(x_2-y_2)^2} $$
注意理解输入？输出？类别中心？迭代过程中做什么？
编程实现 %% 生成测试数据 clear p=100; % 每簇的样本数 sigma = [0.1 0;0 0.1]; % 协方差矩阵 R = chol(sigma); % 生成测试数据集 data=[... [0 0] + randn(p,2)*R,1*ones(p,1);... [0 2] + randn(p,2)*R,2*ones(p,1);... [2 0] + randn(p,2)*R,3*ones(p,1);... [2 2] + randn(p,2)*R,4*ones(p,1);... ]; %% 绘制样本散点图 figure(1) scatter(data(:,1),data(:,2),&amp;#39;r.</description>
    </item>
    
    <item>
      <title>二分查找是个啥啊</title>
      <link>https://lbqaq.top/p/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%98%AF%E4%B8%AA%E5%95%A5%E5%95%8A/</link>
      <pubDate>Mon, 04 Apr 2022 22:54:54 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%98%AF%E4%B8%AA%E5%95%A5%E5%95%8A/</guid>
      <description>打了两次力扣的周赛，都败在了第三题上，而且都是二分查找的题目。这下不能忍了，必须来总结一波。
第一次二分查找 二分查找是用来在一个有序数组中查找某一元素的算法。它的工作原理如下：
 它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需到右侧查找；如果中间元素大于所查找的值同理，只需到左侧查找。
 使用二分查找就能将原先$\Omicron(n)$时间复杂度的线性查找降低为$\Omicron(\log(n))$。但是一定要注意，二分查找一定要在有序的数组上进行。
下面放上模板：
int binary_search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int left = 0, right = nums.size() - 1; int ret = -1; // 未搜索到数据返回-1下标  int mid; while (left &amp;lt;= right) { mid = left + ((right - left) &amp;gt;&amp;gt; 1); // 直接平均可能会溢出，所以用这个算法  if (nums[mid] &amp;lt; target) left = mid + 1; else if (nums[mid] &amp;gt; target) right = mid - 1; else { // 最后检测相等是因为多数搜索情况不是大于就是小于  ret = mid; break; } } return ret; // 单一出口 } 在上面的代码中，我们每次搜索的是[left,right]这个闭区间，所以在while中要使用&amp;lt;=。</description>
    </item>
    
    <item>
      <title>进制转换和位运算</title>
      <link>https://lbqaq.top/p/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/</link>
      <pubDate>Sun, 03 Apr 2022 09:45:04 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/</guid>
      <description>进制转换 在数学中，不止只有我们常见的10进制，最近刷了几道关于进制转换的题目，在这里做个总结和记录吧。
基本概念 首先我们要先了解进制的基本概念，这里我直接从LeetCode官方这里引用了。
 任何一种进位计数制都有一个基数，基数为 X 的进位计数制称为 X 进制，表示每一个数位上的数运算时都是逢 X 进一。
  对于一个 X 进制的数，其具体数值由其中的每个数码和数码所在的数位决定。整数部分从右往左的第 m 个数位表示的权重是 $X^m$，其中 m 最小为 0；小数部分从左往右的第 n 个数位表示的权重是$X^{-n}$，其中 n 最小为 1。
 八进制的 $720.5$ 可以写成如下形式：
$720.5_{(8)} = 7 \times 8^2 + 2 \times 8^1 + 0 \times 8^0 + 5 \times 8^{-1}$
用我自己的话来说，就是数值*权重
进制转换的一般思路 一般来说，我们习惯将进制转换成十进制，这样便于理解和手算。当然，我们也可以不通过十进制作为中间态过度，比如我们熟悉的二进制和十六进制的转换。
非十进制转十进制 将非十进制数转成十进制数，只要将每个数位的加权和即可。
例如，将八进制数 $720.5_{(8)}$ 转成十进制：
$720.5_{(8)} = 7 \times 8^2 + 2 \times 8^1 + 0 \times 8^0 + 5 \times 8^{-1} = 464.</description>
    </item>
    
    <item>
      <title>初探区间求和问题</title>
      <link>https://lbqaq.top/p/%E5%88%9D%E6%8E%A2%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 14 Mar 2022 20:46:19 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/%E5%88%9D%E6%8E%A2%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/</guid>
      <description>最近看了很多篇关于如何刷题的文章，其中都不约而同的提到了&amp;quot;总结&amp;quot;这个关键词。仔细想想自己确实是从来没有做过一篇总结，刷过的题目就过去了，导致同样的题目再做一次又不会了。
我的第一篇总结就以最近刷到的「区间求和」问题展开吧。首先，先上一般问题的模板（其中加粗的为最佳方案）：
 数组不变，区间查询：前缀和、树状数组、线段树； 数组单点修改，区间查询：树状数组、线段树； 数组区间修改，单点查询：差分、线段树； 数组区间修改，区间查询：线段树。  前缀和 前缀和的作用就是为了帮助我们快速求某一段的和，是「差分」的逆运算。
前缀和数组的每一位记录的是当前位置距离起点位置，这连续一段的和区间和。
一维前缀和 假设有一个一维数组$x$和该数组的一维前缀和数组$y$，则$x$和$y$满足以下关系：
$$y_0=x_0、y_1=x_0+x_1、y_2=x_0+x_1+x_2、&amp;hellip;&amp;hellip;、y_n=x_0+x_1+&amp;hellip;+x_n$$
所以我们可以通过 $y_n=y_{n-1}+x_n$ 这个公式计算出前缀和，代码实现如下：
for (int i = 0; i &amp;lt; n; i++) { if (i == 0) y[i] = x[i]; else y[i] = y[i - 1] + x[i]; } 但是在实际使用中，常常会遇到左边界溢出的情况，为了避免这种情况，我们可以将前缀和数组整体向后移动一位，下面给出前缀给计算代码：
int n = x.size(); vector&amp;lt;int&amp;gt; y(n + 1); for (int i = 1; i &amp;lt;= n; i++) y[i] = y[i - 1] + x[i - 1]; 这样当我们想求区间$[a,b]$之和时只需要计算$y[b+1]-y[a]$即可。</description>
    </item>
    
    <item>
      <title>JavaWeb期末复习</title>
      <link>https://lbqaq.top/p/javawebexam/</link>
      <pubDate>Mon, 03 Jan 2022 19:52:31 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/javawebexam/</guid>
      <description>题目类型  选择（10分） 10题 填空（10分） 10题 问答（30分） 4题 编程题（30分） 3-4题 综合题（20分）  上机题整理 这里只存放核心的代码，完整的程序见Gitee仓库
使用Maven 通过使用Maven可以让程序自动配置和导入包，不必自己手动配置和导入，非常方便，推荐大家使用。
我的配置文件已经把考试会用的包都导入了，包括Servlet、JSP、JSTL、MySQl驱动，版本都已经调整为最佳，保证开箱即用。
  新建项目，选择Maven，直接下一步
 step1 
  填写项目名称和目录位置，其他的可填可不填
 step2 
  在pom.xml文件增加这样一句&amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;
接着粘贴下面的代码，并点击右上角的图标应用（或者使用快捷键Ctrl+Shift+O）
&amp;lt;dependencies&amp;gt; &amp;lt;!-- servlet 依赖 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- jsp 依赖 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.servlet.jsp&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;javax.servlet.jsp-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.3.3&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- jstl --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.servlet.jsp.jstl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jstl-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- standard标签库 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;taglibs&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;standard&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- mysql驱动 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;8.</description>
    </item>
    
    <item>
      <title>如何优雅的看番</title>
      <link>https://lbqaq.top/p/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%9C%8B%E7%95%AA/</link>
      <pubDate>Tue, 26 Oct 2021 15:39:41 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%9C%8B%E7%95%AA/</guid>
      <description>新番“先审后播”政策已经实行了快半年了，现在看来在哔哩哔哩上追番的体验已经没有之前那样舒适了，更不用提还有好多番剧连上线都没有上线。这时本地看番就成了一个比较不错的选择了。这篇文章就记录以下这段时间我本地追番使用的工具和网站，大家也可以以此为参照，打造属于自己的追番体验。
找番 “巧妇难为无米之炊”，没有片源的话，本文使用的一切工具也就无从谈起了。下面我就列举几个我知道的找番网址：
  （推荐）萌番组
只能说是良心网站了，国内可以直连，支持RSS订阅和筛选
  動漫花園
老牌网站了，国内无法直连，但分享内容不止番剧，还有音乐等内容
  Nyaa
一般是英文资源，可做为备用网站
  下载 找到了需要的资源（一般都是BT链接），下一步就是下载了，这里我推荐qBittorrent，我认为是BT下载的最优解了。Windows平台我建议选择增强版qBittorrent-Enhanced-Edition
对于新番来说，速度基本是不慢的。但如果要下载旧番的话，如果分享的人不多的话速度就不太理想了。
面对这种情况我知道的有这样几种解决方法：
  使用115等支持离线的网盘
这里我推荐一个安卓的APP，叫PikPak。由于是新出的，现在有会员免费领取的活动，可以无限次离线+3T空间。我个人测试了一下离线成功率和下载速度还是不错的，乘现在还能白嫖就多用用吧_(:з)∠)_
  租一台国外的VPS，先在上面下载好再转存到国内（因为有些资源分享的人在国内无法连接到，所以这个方法才有用😂）
  看看百度云等网盘上有没有人分享
  使用PT，当然这个难度过大了，就连我也没整过😇
  播放 说到本地播放器，那就不得不提到PotPlayer的大名了，这基本是播放器的最优解了，在这里我就不过多阐述它的优点了，我主要是想提一提另外的一款播放器——弹弹play
相比PotPlayer，它最大的优点就是支持弹幕的播放。在看了这么多年的B站以后，现在看番不带弹幕就觉得缺了些什么，这款播放器就很好的解决了我这个痛点。当然它的功能不止这些，比如可以配置自动下载、开启远程访问等等。但我一般不会让一个播放器后台常驻+开机自启的，所以这些功能对我来说并没有多大的作用。
当然还是有缺点的，比如不能像pakku那样将重复弹幕合并成一条大弹幕，使用自带的重复弹幕屏蔽会有肉眼可见的弹幕消失等BUG。不过瑕不掩瑜，这款播放器我还是很推荐的。
补帧 终于到这个环节了，这才是我写这篇文章的主要动力。
国际惯例，先来一段名词解释：
 帧数(Frames)，为帧生成数量的简称。由于口语习惯上的原因，我们通常将帧数与帧率混淆。每一帧都是静止的图象，快速连续地显示帧便形成了运动的假象，因此高的帧率可以得到更流畅、更逼真的动画。
而帧率（Frame rate）是用于测量显示帧数的量度。所谓的测量单位为每秒显示帧数(Frames per Second，简称：FPS）或“赫兹”（Hz）。此词多用于影视制作和电子游戏。
 所以说补帧就是将低帧率的视频通过一定的算法提升到高帧率。直观来看，就是画面变得更加流畅丝滑了，还不理解的话可以看下面的动图或者看看极客湾的这期视频，通过不同帧率的对比能有个更清晰的认识。
 点开才能动 
当然，上面的视频中使用的是AI补帧，对显卡和时间要求都十分高。我们正常看番是用不到这些的。这里就列举本地实时插帧的三款软件。
    AMD Fluid Motion SVP dmitriRender     硬件需求 支持此功能的A卡 无 高性能的显卡   是否收费 免费 收费（可试用） 收费（可试用）   正版体验 / 优秀 较差   配置难度 不知道 复杂 简单   支持格式 全部 不支持HEVC 全部    至于补帧效果，我感觉对于动漫dmitriRender要比SVP要好一点。当然由于动漫的画面一般不具有逻辑连续，所以还是会有一点虚影的，不过不影响观看。</description>
    </item>
    
    <item>
      <title>MySQL8开启远程访问</title>
      <link>https://lbqaq.top/p/mysql8%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/</link>
      <pubDate>Thu, 21 Oct 2021 10:19:52 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/mysql8%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/</guid>
      <description>最近把服务器重装成Ubuntu了，所以要重装MySQL，没想到在这里踩了好几个坑，在这里记录下来备忘。
安装 这其实很简单，直接通过Ubuntu的包管理器直接安装就行了（我把系统转为Ubuntu也有这方面的原因）。
sudo apt-get install mysql-server 通过这条命令安装的MySQL的root账号是没有密码的，所以只要输入mysql就直接可以进入了
开启远程访问 这里就是本文的重点了，我在这里花了很多时间😇
设定MySQL的监听端口 通过apt安装的MySQL默认是只监听本地的端口的，我们要修改使其监听所有ip地址的请求。
vim /etc/mysql/mysql.conf.d/mysqld.cnf #把bind - address后面的127.0.0.1改为0.0.0.0 #重启MySQL服务器 systemctl restart mysql 设置root账号密码并开启远程访问 默认root账号是没有密码的，这当然是不行的，我们需要给一个密码
usemysql;ALTERUSER&amp;#39;root&amp;#39;@&amp;#39;localhost&amp;#39;IDENTIFIEDWITHmysql_native_passwordBY&amp;#39;新的密码&amp;#39;;updateusersethost=&amp;#39;%&amp;#39;whereuser=&amp;#39;root&amp;#39;;flushprivileges;还要注意把防火墙的3306端口放行，这样就可以实现MySQL的远程访问了。</description>
    </item>
    
    <item>
      <title>shiro整合JWT</title>
      <link>https://lbqaq.top/p/shiro%E6%95%B4%E5%90%88jwt/</link>
      <pubDate>Fri, 08 Oct 2021 15:19:44 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/shiro%E6%95%B4%E5%90%88jwt/</guid>
      <description>在我现在在做的项目中需要进行身份和权限认证，在网上找了些教程，推荐都是使用JWT来进行身份认证，于是便决定使用此方法来实现。（然而用完了才发现JWT也有缺点）
何为JWT 所谓JWT，全称是JSON Web Token。下面是从官网摘抄的定义：
 JWT是一个开放的标准（RFC 7519），它定义了一种紧凑和独立的方式，以JSON对象的形式在各方之间安全地传输信息。这种信息可以被验证和信任，因为它是经过数字签名的。JWTs可以使用秘密（使用HMAC算法）或使用RSA或ECDSA的公共/私人密钥对进行签名。
 按我的理解，JWT其实就是将传统的session认证中的token存储位置从服务器上下发给用户，服务器只需要判断传来的token是否合法而无需存储。这样做的好处就是可以做分布式的服务器，无需考虑用户是在哪一台服务器上登录的。
详细的定义和构成我这里就不展开了，这里主要关注JWT中Payload（载荷）。这是有效信息存放的地方，我们一般关注这里就行了。
下面是官方提供且建议（并不强制）使用的声明：
  iss: jwt签发者
  sub: 主题
  aud: 接收jwt的一方
  exp: jwt的过期时间，这个过期时间必须要大于签发时间
  nbf: 生效时间，在此时间之前该jwt都是不可用的.
  iat: jwt的签发时间
  jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。
  当然，在载荷中还可以存放自定义的信息，在本项目中使用官方提供的就足以了，故不展开。
认证流程  用户使用用户名密码来请求服务器 服务器进行验证用户的信息 服务器通过验证发送给用户一个token 客户端存储token，并在每次请求时附送上这个token值 服务端验证token值，并返回数据   JWT认证流程图 
具体实现 导入依赖包 第一步当然是导入相关依赖了，使用Maven进行包管理。
&amp;lt;!-- shiro --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shiro&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shiro-spring&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.8.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- jwt --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.auth0&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;java-jwt&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.</description>
    </item>
    
    <item>
      <title>Vue学习笔记</title>
      <link>https://lbqaq.top/p/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 22 Sep 2021 08:21:14 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>最近看了很久的Vue教程，为了避免之后的遗忘，还是停下脚步，花点时间讲笔记写出来吧。
这篇笔记是基于B站上的尚硅谷Vue2.0+Vue3.0全套教程而成，在此感谢提供这么优秀的学习教程。
Vue2基础 想要学好Vue，那肯定还是从Vue2开始学起。那么这一章主要是Vue2中的基础内容，没有使用到脚手架。
初识Vue 每学一个新的语言，HelloWord是必不可少的。话不多说，上代码：
&amp;lt;!-- 准备好一个容器 --&amp;gt; &amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;Hello，{{name.toUpperCase()}}，{{address}}&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34; &amp;gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。  //创建Vue实例  new Vue({ el:&amp;#39;#demo&amp;#39;, //el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。  data:{ //data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象。  name:&amp;#39;vue&amp;#39;, address:&amp;#39;北京&amp;#39; } }) &amp;lt;/script&amp;gt; 这样就完成了一个基础的Vue程序。
1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；
2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；
3.root容器里的代码被称为【Vue模板】；
4.Vue实例和容器是一一对应的；
5.真实开发中只有一个Vue实例，并且会配合着组件一起使用；
6.{{xxx}}中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；
7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；
Vue模板语法 Vue模板语法有2大类：
1.插值语法：
​ 功能：用于解析标签体内容。
​ 写法：{{xxx}}，xxx是js表达式，且可以直接读取到data中的所有属性。
2.指令语法：
​ 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件&amp;hellip;..）。
​ 举例：v-bind:href=&amp;ldquo;xxx&amp;rdquo; 或 简写为 :href=&amp;ldquo;xxx&amp;rdquo;，xxx同样要写js表达式，
​ 且可以直接读取到data中的所有属性。
​ 备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。
其实很好理解，想要显示在页面上的内容就使用{{value}}这样的写法，而v-bind:则是用于html标签中的属性绑定。
数据绑定 Vue中有2种数据绑定的方式：
​ 1.单向绑定(v-bind)：数据只能从data流向页面。</description>
    </item>
    
    <item>
      <title>Swagger3初体验</title>
      <link>https://lbqaq.top/p/swagger/</link>
      <pubDate>Thu, 09 Sep 2021 15:09:04 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/swagger/</guid>
      <description>最近做项目需要前后端分离，所以需要接口文档给前端方便联调。手写文档是不可能的，这时就需要使用Swagger了。网上的教程大部分版本都在2.x甚至是1.x，很少有3.0的教程，我个人就是喜欢用最新版，所以我就来分享一下我使用Swagger3的体验和坑吧。
配置 这里就分享springboot版本的方法了，现在的项目应该都用springboot创建了吧。
  导入Maven依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springfox-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;   在启动类上加上@EnableOpenApi就行了。
  当然，这样只是默认的，我们要用肯定要配置一下，我们去创建一个Config类，在里面建立一个函数返回Docket类，我们所有的配置就在这个Docket类里配置。
@Configuration @EnableOpenApi public class SwaggerConfig { @Bean public Docket docket(){ return new Docket(DocumentationType.OAS_30)	//3.0版本用OAS_30这个标准  .apiInfo(getApiInfo()) .select() //扫描指定包下的接口  .apis(RequestHandlerSelectors.basePackage(&amp;#34;top.lbqaq.controller&amp;#34;)) .build(); } /** * 配置swagger信息 */ private ApiInfo getApiInfo(){ //这里是作者信息，分别为姓名、个人主页、邮箱  Contact contact = new Contact(&amp;#34;luoboQAQ&amp;#34;,&amp;#34;https://lbqaq.top&amp;#34;,&amp;#34;123@xx.com&amp;#34;); return new ApiInfo( &amp;#34;项目名&amp;#34;, &amp;#34;项目描述&amp;#34;, &amp;#34;版本&amp;#34;, &amp;#34;项目主页&amp;#34;, contact, &amp;#34;Apache 2.0&amp;#34;, &amp;#34;https://www.apache.org/licenses/LICENSE-2.0&amp;#34;, new ArrayList()); } } 这样一个带有个人信息的配置页就做好了。
注解 首先是2.</description>
    </item>
    
    <item>
      <title>使用Webhooks实现自动部署</title>
      <link>https://lbqaq.top/p/%E4%BD%BF%E7%94%A8webhooks%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Mon, 23 Aug 2021 15:44:59 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/%E4%BD%BF%E7%94%A8webhooks%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</guid>
      <description>每次写完博客，需要在本地编译，然后再手动通过WinSCP送到服务器上。作为一个懒人，这上面几步下来还是觉得麻烦，而且每次编译又会生成一顿不需要的文件，于是便决定整点自动化的流程，直接解放双手。
因为我的博客在没买服务器之前都是托管在Github上的，于是自然而然地就想到了Webhook，在每次Push后自动发送消息给服务器，让其自动拉取代码。
网上的教程大多都是在本地编译，然而我觉得既然要懒，就一懒到底吧，编译也直接通过Github Actions来完成就行了。
流程 需要2个Github仓库（1个应该也可以），一个存放网站的源码，一个是存放编译好的html文件。整个工作流程就如下图所示：
 流程图 
步骤 设置脚本 首先要写一个shell脚本，功能很简单就是自动拉取代码。
#!/bin/bash cd /home/luobo/Blog git pull 创建webhook服务后端 这里就直接使用NodeJS来创建，使用的原因很简单，因为已经有现成的插件可以使用了。
首先安装依赖
npm i -S github-webhook-handler npm i -g pm2 然后创建webhook.js作为后端
var http = require(&amp;#39;http&amp;#39;); var spawn = require(&amp;#39;child_process&amp;#39;).spawn; var createHandler = require(&amp;#39;github-webhook-handler&amp;#39;); //注意要将 secret 修改你自己的 var handler = createHandler({ path: &amp;#39;/webhook&amp;#39;, secret: &amp;#39;xxxxx&amp;#39; }); http.createServer(function (req, res) { handler(req, res, function (err) { res.statusCode = 404; res.end(&amp;#39;no such location&amp;#39;); }) }).listen(6666); handler.</description>
    </item>
    
    <item>
      <title>为博客添加评论系统</title>
      <link>https://lbqaq.top/p/waline/</link>
      <pubDate>Sat, 21 Aug 2021 15:37:44 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/waline/</guid>
      <description>一个完整的博客，怎么能少的了评论系统呢。评论的实现已经有许许多多的方法了，挑来挑去，还是选择了Waline。
一开始我是采用官方推荐的LeanCloud+Vercel的方式进行部署的，结果步骤全部走完后才发现Vercel已经在国内被墙了，不科学根本上不去😇。总不能要求用户还要开梯子才能评论吧，所幸官方提供了其他的部署方式，因为我才买了自己的服务器~~（不榨干怎么行呢）~~，所以就选择本地部署+SQLlite的方式了。
部署步骤 安装node.js 由于Waline的服务端是由js写的，所以需要安装node.js
  在nodejs中文网找到需要的版本，选择阿里云镜像，将下载链接复制下来
  连接服务器，选择nodejs的安装目录，这里我安装在/usr/local/bin/
cd /usr/local/bin/   下载安装包到本地
wget https://npm.taobao.org/mirrors/node/v14.17.5/node-v14.17.5-linux-x64.tar.gz   解压
tar -xvf node-v14.17.5-linux-x64.tar.gz   重命名目录
mv node-v14.17.5-linux-x64 nodejs   添加目录到系统变量
cd /etc/profile.d vim custom.sh 在文件末尾添加export PATH=$PATH:/usr/local/bin/nodejs/bin
  测试，输入下面3条命令，如果不报错则安装成功。
node -v npm version npx -v   （可选）安装cnpm
npm install -g cnpm --registry=https://registry.npm.taobao.org   安装Waline服务端   安装waline的服务端
npm install -g @waline/vercel   配置数据库。这里我采用的是SQLite，只需要下载 waline.sqlite 文件至合适的位置。</description>
    </item>
    
    <item>
      <title>SpringMVC学习笔记</title>
      <link>https://lbqaq.top/p/springmvc/</link>
      <pubDate>Sun, 15 Aug 2021 09:06:00 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/springmvc/</guid>
      <description>SpringMVC也告一段落了，终于要到SpringBoot了。
还是和之前一样，笔记是基于遇见狂神说的SpringMVC视频教程而来，在此感谢能提供这么优秀的教程。
回顾MVC 什么是MVC  MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 将业务逻辑、数据、显示分离的方法来组织代码。  **Model（模型）：**数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。
拓展：在前端数据传输给后端时，有些字段是不需要的，这是可能会细分出Vo层（视图）
比如：用户有账号、密码、年龄等一系列字段
这时前端登录只传了账号密码
此时可以用UserVo来表示，里面只有账号和密码
**View（视图）：**负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。
**Controller（控制器）：**接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。
最典型的MVC就是JSP + servlet + javabean的模式。
 用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面  职责分析：
Controller：控制器
 取得表单数据 调用业务逻辑 转向指定的页面  Model：模型
 业务逻辑 保存数据的状态  View：视图
 显示页面  复习Servlet   父工程添加依赖
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.13&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.3.9&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.servlet.jsp&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jsp-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.</description>
    </item>
    
    <item>
      <title>Spring学习笔记</title>
      <link>https://lbqaq.top/p/spring/</link>
      <pubDate>Thu, 12 Aug 2021 09:38:02 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/spring/</guid>
      <description>花了3天时间，Spring也终于看完了,SSM已经干完了两个了，感觉人都要没了😇。还是老样子，留下笔记以免遗忘。
下面的内容都是基于遇见狂神说的Spring5视频教程而来，在此感谢能提供这么优秀的教程。
Spring 简介 Spring就是用来简化Java开发的，只能说学Java不学Spring，就像读四大名著不读红楼梦&amp;hellip;&amp;hellip;
2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。
2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。
很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。
Spring理念 : 使现有技术更加实用。 本身就是一个大杂烩 , 整合现有的框架技术。
SSM：SpringMVC+Spring+MyBatis
几个常用的网址：
  官网
  官方文档（英文）
  中文文档
  GitHub
  &amp;lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.3.9&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.3.9&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 优点   Spring是一个开源免费的框架 , 容器
  Spring是一个轻量级的框架 , 非侵入式的
  控制反转（IoC）,面向切面（Aop）
  对事务的支持 , 对框架的支持
  一句话概括：</description>
    </item>
    
    <item>
      <title>从零开始ASF挂卡</title>
      <link>https://lbqaq.top/p/asf/</link>
      <pubDate>Wed, 11 Aug 2021 21:46:24 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/asf/</guid>
      <description>因为买了一台云服务器，不拿来干点啥实在是太亏了，于是便想到了可以使用云服务器来挂卡。
步骤 安装.net环境 ASF是基于.netcore开发的程序，所以需要安装环境。这里建议看微软官方的安装文档，里面有不同系统的安装方法。
我们需要安装的只是ASP.NET Core 运行时。
我的系统是centos7，这里就只列举我系统上的命令了。
sudo rpm -Uvh https://packages.microsoft.com/config/centos/7/packages-microsoft-prod.rpm sudo yum install aspnetcore-runtime-5.0 安装ASF 在ASF的发布页面上下载系统对应的版本解压即可。
我这里是在本地先下载好后用WinSCP直接传上服务器。
配置ASF 这里就采用官方的**在线配置文件生成器**自动生成即可。
我们这里选择机器人，将steam的账号和密码填入，并将Enabled设置为True就行了。
详细的配置内容可以在官方Wiki上看到，这里就不再赘述了。
下面放上我的配置文件：
{ &amp;#34;SteamLogin&amp;#34;: &amp;#34;xxx&amp;#34;, &amp;#34;SteamPassword&amp;#34;: &amp;#34;xxx&amp;#34;, &amp;#34;Enabled&amp;#34;: true, &amp;#34;CustomGamePlayedWhileFarming&amp;#34;: &amp;#34;挂卡中...&amp;#34;, &amp;#34;CustomGamePlayedWhileIdle&amp;#34;: &amp;#34;空闲中...&amp;#34;, &amp;#34;FarmingOrders&amp;#34;: [ 15, 12 ], &amp;#34;HoursUntilCardDrops&amp;#34;: 0, &amp;#34;OnlineStatus&amp;#34;: 1 }  CustomGamePlayedWhileFarming：表示挂卡时显示的游戏名 CustomGamePlayedWhileIdle：表示空闲时显示的游戏名 HoursUntilCardDrops：表示至少将游戏挂到几小时，如果是非限制账户，调到0是最好的。  我们也可以配置ASF本身的设置，这里也同样贴上我的配置：
{ &amp;#34;s_SteamOwnerID&amp;#34;: &amp;#34;xxx&amp;#34;, &amp;#34;CurrentCulture&amp;#34;: &amp;#34;zh-CN&amp;#34;, &amp;#34;IPCPassword&amp;#34;: &amp;#34;xxx&amp;#34; }  s_SteamOwnerID：该属性定义 ASF 进程所有者的 64 位 Steam ID，直接设置成自己的大号就行 CurrentCulture：ASF的语言 IPCPassword：由于ASF默认会开启IPC服务，为了安全起见建议设置密码或关闭IPC服务。  将配置文件放入config目录里就行了。</description>
    </item>
    
    <item>
      <title>MyBatis学习笔记</title>
      <link>https://lbqaq.top/p/mybatis/</link>
      <pubDate>Wed, 11 Aug 2021 11:11:10 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/mybatis/</guid>
      <description>花了四天的时间，终于把MyBatis的视频教程全部看完了，为了以后不要那么快的遗忘掉，还是来写一下笔记比较好。
下面的内容都是基于遇见狂神说的MyBatis视频教程而来，在此感谢能提供这么优秀的教程。
简介  MyBatis的作用用我自己的话说，就是不用自己手动搞JDBC了，省事，行！ MyBatis作用于持久层——DAO层 【DAO (Data Access Object) 数据访问对象】，通俗点说就是用来操作数据库的层 选择MyBatis的最大原因还是用的人多，为后面的Spring打基础_(:з)∠)_  第一个MyBatis程序 思路流程：搭建环境&amp;ndash;&amp;gt;导入MyBatis&amp;mdash;&amp;gt;编写代码&amp;mdash;&amp;gt;测试
具体代码   创建Maven项目
  引入依赖包
&amp;lt;!-- 导入依赖 --&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;!-- mysql驱动 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;8.0.25&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- mybatis --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.7&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- junit --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt;   在resources目录下创建mybatis-config.xml，作为MyBatis的配置文件
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34; ?&amp;gt; &amp;lt;!DOCTYPE configuration PUBLIC &amp;#34;-//mybatis.org//DTD Config 3.0//EN&amp;#34; &amp;#34;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;#34;&amp;gt; &amp;lt;!--核心配置文件--&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;environments default=&amp;#34;development&amp;#34;&amp;gt; &amp;lt;environment id=&amp;#34;development&amp;#34;&amp;gt; &amp;lt;transactionManager type=&amp;#34;JDBC&amp;#34;/&amp;gt; &amp;lt;dataSource type=&amp;#34;POOLED&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;driver&amp;#34; value=&amp;#34;com.</description>
    </item>
    
    <item>
      <title>Qt构建qsqlmysql.dll</title>
      <link>https://lbqaq.top/p/qt%E6%9E%84%E5%BB%BAqsqlmysql.dll/</link>
      <pubDate>Thu, 03 Jun 2021 15:44:17 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/qt%E6%9E%84%E5%BB%BAqsqlmysql.dll/</guid>
      <description>这篇文章我打算来介绍一下如何构建qsqlmysql.dll，由于版权原因，在新版的Qt里是不自带该dll的，这样对我们编写数据库程序会很麻烦。（你用ODBC？那没事了）
我在网上也查了很多资料，但根据步骤来总是会报错，提示没有mysql.h这个头文件。下面就记录一下我成功编译的过程。
基于cmake的步骤 在6.1之后的Qt版本中，Qt公司删除了qmake而更换成了cmake的方式来构建项目文件，下面就是我总结的使用cmake生成的方法。
注意： 路径的前段部分(软件的安装位置)每个人可能都不一样，但是路径的后段部分应该是一样的，请自行修改。
1.准备好Qt的源代码，如果没有可以在Qt的安装目录打开MaintenanceTool.exe启动Qt组件管理，在里面勾选Src把源码下载下来。
2.打开cmake-gui，选择目标文件夹为D:\Qt\6.1.1\Src\qtbase\src\plugins\sqldrivers，并设置生成文件夹为D:/Qt/6.1.1/Src/qtbase/src/plugins/sqldrivers/build
 配置文件夹 
3.点击左下角的Configure，会提示生成的目录不存在是否创建，直接点是就可以了。
4.编译器这里选择MinGW Makefiles,然后点击Finish
 选择编译器 
5.等待生成完成后，把FEATURE_sql_mysql后面的勾勾上，然后把其余的FEATURE_sql后面的勾取消。
 选择生成模块 
6.再次点击左下角的Configure，可以发现上面的红框已经消失了，说明配置成功了。然后点击Generate，生成Makefiles。
 配置成功 
7.这时配置文件已经构建完成了，接下来就是生成dll了，打开PowerShell切换目录至D:/Qt/6.1.1/Src/qtbase/src/plugins/sqldrivers/build，输入mingw32-make开始编译生成dll。
 编译成功 
没有报错，说明生成成功。
8.最后打开目录D:\Qt\6.1.1\Src\qtbase\src\plugins\sqldrivers\build\plugins\sqldrivers，就可以看到生成好的qsqlmysql.dll了。
基于qmake的步骤 注意： 路径的前段部分(软件的安装位置)每个人可能都不一样，但是路径的后段部分应该是一样的，请自行修改。
1.准备好Qt的源代码，如果没有可以在Qt的安装目录打开MaintenanceTool.exe启动Qt组件管理，在里面勾选Src把源码下载下来。
2.进入D:\Qt\6.0.3\Src\qtbase\src\plugins\sqldrivers目录下，打开sqldrivers.pro这个文件。
3.在左侧文件树中打开mysql文件夹，选择mysql.pro打开。
4.修改里面的内容：
  注释掉QMAKE_USE += mysql这一句
  增加下面三行代码(注意把D:/MySQL/改为你MySQL的安装路径)：
LIBS +=-LD:/MySQL/lib -llibmysql INCLUDEPATH += D:/MySQL/include DEPENDPATH += D:/MySQL/include   5.点击Qt左下角的小锤子进行构建，不出意外的话就可以在D:\Qt\6.0.3\Src\qtbase\src\plugins这个路径下看到build开头的文件夹，在.\plugins\sqldrivers目录下就能看到编译好的dll了。
6.最后将qsqlmysql.dll放入D:\Qt\6.0.3\mingw81_64\plugins\sqldrivers\里就行了。如果链接数据库时还报错，就把libmysql.dll复制到Qt的编译器的D:\Qt\6.0.3\mingw81_64\bin\目录。</description>
    </item>
    
    <item>
      <title>WSL2&#43;WT配置小结</title>
      <link>https://lbqaq.top/p/wsl2-wt%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93/</link>
      <pubDate>Thu, 08 Apr 2021 13:14:20 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/wsl2-wt%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93/</guid>
      <description>1202年了，是时候抛弃老旧的cmd窗口和臃肿的VM虚拟机了，来试试巨硬推出的WSL2+Windows Terminal(～￣▽￣)～。
起因 在知乎上刷到了一篇回答，是关于Windows编程的体验的。在这篇文章中提到了WSL2和Windows Terminal，我一下就被那精美的界面吸引了（管他好不好用，好看就完事了）。正好现在在上操作系统这门课，需要使用Linux进行实验，这还说什么，直接开冲。
 精美的界面 
WSL2安装 安装其实很简单，按照微软的教程一步一步做就完事了。
0.前置条件 想要用WSL2，首先你得是 Windows 10，而且还有版本号要求。
 对于 x64 系统：版本 1903 或更高版本，采用 内部版本 18362 或更高版本。 对于 ARM64 系统：版本 2004 或更高版本，采用 内部版本 19041 或更高版本。  1. 开启WSL服务 在Powershell(管理员)中输入下面的命令：
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 2. 启用虚拟机服务 在Powershell(管理员)中输入下面的命令：
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 重新启动 计算机，以完成 WSL 安装并更新到 WSL 2。
3. 下载 Linux 内核更新包 下载最新包并安装：
 适用于 x64 计算机的 WSL2 Linux 内核更新包  4. 将 WSL 2 设置为默认版本 在Powershell中输入下面的命令：</description>
    </item>
    
    <item>
      <title>PyAipao</title>
      <link>https://lbqaq.top/p/pyaipao/</link>
      <pubDate>Thu, 11 Mar 2021 10:25:00 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/pyaipao/</guid>
      <description>PyAipao简介 该项目可实现阳光体育一键跑步，同时可基于GitHub Actions来实现云跑步。
仅需一次配置，即可轻松跑完一学期ヾ(≧▽≦*)o
准备工作 1.一个github账号 2.抓包抓到的IMEICode 3.Server酱的SCKEY或企业微信（可选，用于微信推送跑步结果）  云跑步上手教程 1.点击fork按钮将该仓库复制到你的仓库  fork 
2.获取 IMEICode
 打开抓包软件抓包, 再打开阳光体育 App 登录, 在所有的数据包中找后缀有 IMEICode=  的 URL 请求, 等号后面的字段即为七天有效的 IMEICode (若多次没抓到: 可来回切换几次飞行模式, 杀掉 App 后台重复尝试多次)  如果不需要推送，可以直接略过第3步
3.1基于Server酱的推送
 完成Server酱的注册和绑定 点我直达 在 SendKey这一页中找到SendKey并记录  SendKey   3.2基于企业微信应用消息的推送
由于Server酱不捐助是无法查看消息内容的，所以为了白嫖我自己写了推送部分的代码，可以直接使用微信官方接口来推送。
企业微信的配置方法可以在Server酱的消息通道里看到，这里就不赘述了。
 weisend 
和Server酱一样，我们也需要企业ID(CORPID)，应用ID(AGENTID)，应用Secret(SECRET)这三个值。
4.配置Github Actions
  打开仓库的secrets，在其中建立IMEICODE并将IMEICode填入  4.1 
  （可选）使用Server酱推送，需要建立SCKEY并填入SendKey
  （可选）使用企业微信应用消息推送，需要建立CORPID&amp;ndash;填入企业ID，AGENTID&amp;ndash;填入应用ID，SECRET&amp;ndash;填入应用Secret
  打开Code-.github/workflows-autorun.yml，点击右上角的铅笔图标进行编辑，将时间改为你想让它每天按时跑的时间，默认为每天上午9点；同时修改推送方式，默认不推送。</description>
    </item>
    
    <item>
      <title>给Blog增加动画</title>
      <link>https://lbqaq.top/p/%E7%BB%99blog%E5%A2%9E%E5%8A%A0%E5%8A%A8%E7%94%BB/</link>
      <pubDate>Mon, 01 Feb 2021 13:55:05 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/%E7%BB%99blog%E5%A2%9E%E5%8A%A0%E5%8A%A8%E7%94%BB/</guid>
      <description>看到zsnmwy大佬的博客，和我使用的是同样的主题，但是人家却多了一些动画，瞬间就高级起来了。于是打开百度搜素一波，发现只要改一下CSS就可以实现了。
准备工具   hugo的扩展版（extended）
这里一定要下扩展版，因为我使用的主题都是利用scss来生成css的，如果用普通版是无法利用scss生成对应的css的。之前不知道下的是普通版，结果怎么改scss都没有效果，浪费了很多时间😥。
  相关代码 1.头像转动 在themes/hugo-theme-stack/assets/scss/partials/sidebar.scss中增加以下代码：
.site-logo { transition: all 1.75s ease-out; } .site-logo:hover { transform: rotate(360deg); } 2.文章头图缩放 在themes/hugo-theme-stack/assets/scss/partials/article.scss中增加以下代码：
.article-image { overflow:hidden; } .article-image { img { transition:all .5s ease; } &amp;amp;:hover{ transform:scale(1.2); } 3.Archives页面缩放 在themes/hugo-theme-stack/assets/scss/partials/article.scss中增加以下代码：
article{ transition:.5s ease; } article { &amp;amp;:hover{ transform:scale(1.05,1.05); background:#f0f8ff; } } 4.菜单缩放 在themes/hugo-theme-stack/assets/scss/partials/menu.scss中增加以下代码：
overflow-y: visible; //把auto改为visible，为了图标放大溢出时不显示滚动条 li { transition:.5s ease; } li{ &amp;amp;:hover{ transform:scale(1.1,1.1); } } 有了动画后，感觉整个博客都变得高级起来了ヾ(•ω•`)o
在这感谢zsnmwy大佬，上面有些动画懒得自己写了，就直接从他的css中复制了ヾ(￣▽￣)</description>
    </item>
    
    <item>
      <title>竞赛用STL整理</title>
      <link>https://lbqaq.top/p/%E7%AB%9E%E8%B5%9B%E7%94%A8stl%E6%95%B4%E7%90%86/</link>
      <pubDate>Sun, 31 Jan 2021 20:39:29 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/%E7%AB%9E%E8%B5%9B%E7%94%A8stl%E6%95%B4%E7%90%86/</guid>
      <description>最近刷了好几道关于STL的竞赛题，许多知识点还是不熟练，在继续学习之前，还是来好好整理一下一些常见的STL和容器吧。紫书上介绍的有以下几种：
 线性：vector,list,string 关联：map,set 特殊：stack,queue,priority_queue 算法：sort,lower_bound,find  vector vector可以理解为可以自由变换长度的数组(不定长数组)，个人感觉使用频率还是很高的。vector是连续的，意味着可以使用[]或at()。
声明： vector&amp;lt;int&amp;gt; a
常用函数   push_back：在尾部添加一个数据
  pop_back：删除尾部的一个数据
  size：当前的大小（就是有多少元素）
  erase：删除指针指向的数据项
  clear：清空
  empty：判断是否为空
  deque deque可以看作是双向队列，是连续存储结构。vector有的功能它都有，还支持高效的首/尾端插入/删除操作。
新增函数  push_front：在头部添加一个数据 pop_front：在头部删除一个数据  list list可以看作是双链表，是非连续存储结构。可在两端进行push、pop，同时在内部可以很方便的进行插入和删除操作。不过我没怎么用到这个容器。等我做到相关的题目再来补充一些信息吧。
string string就是字符串。相比char[]那可是方便不少，c++的cin/cout就只支持string类型而不支持char型数组。string还支持+、=、+=等运算符。
常用函数   append：在字符串后添加（相当于+=）
  substr(n,m)：返回string的子串，从n处开始，取m个。当m省略或超过了字符串的长度，则一直取到字符串结束。
  查找相关函数：
如果没有查到，返回string::npos。
  find：从前往后查找子串或字符出现的位置。
  rfind：从后往前查找子串或字符出现的位置。
  find_first_of：从前往后查找何处出现另一个字符串中包含的字符。例如：
  s1.find_first_of(&amp;ldquo;abc&amp;rdquo;); //查找s1中第一次出现&amp;quot;abc&amp;quot;中任一字符的位置
  find_last_of：从后往前查找何处出现另一个字符串中包含的字符。</description>
    </item>
    
    <item>
      <title>数据结构算法复习</title>
      <link>https://lbqaq.top/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Sun, 10 Jan 2021 15:06:20 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</guid>
      <description>考前整理的算法，也顺便放到博客上吧ヾ(•ω•`)o
数据结构代码复习 3.单链表逆置 带头结点
int Inverse_Link(LinkList *L) { LinkList *cur, *p; if (L-&amp;gt;next &amp;amp;&amp;amp; L-&amp;gt;next-&amp;gt;next) { p = L-&amp;gt;next-&amp;gt;next; L-&amp;gt;next-&amp;gt;next = NULL; while (p) { cur = L-&amp;gt;next; L-&amp;gt;next = p; p = p-&amp;gt;next; L-&amp;gt;next-&amp;gt;next = cur; } } return 0; } 5.双向链表 双链表定义：
typedef struct DuLinkList { int data; struct DuLinkList *prior; struct DuLinkList *next; } DuLinkList; 遍历：
void Printlist_DuL(DuLinkList *L) { DuLinkList *s; s = L-&amp;gt;next; if (L-&amp;gt;next !</description>
    </item>
    
    <item>
      <title>C语言生成随机数</title>
      <link>https://lbqaq.top/p/c%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</link>
      <pubDate>Tue, 22 Dec 2020 19:36:53 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/c%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</guid>
      <description>生成随机数 在C语言中，生成随机数可以使用stdlib.h头文件里的rand()来生成，例如：
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;int main(){ int a = rand(); printf(&amp;#34;%d\n&amp;#34;,a); return 0; } rand() 会随机生成一个位于 0 ~ RAND_MAX 之间的整数。
但是这样生成的随机数每次开启程序都是一样的，则需要使用srand()来重新播种，一般常与&amp;lt;time.h&amp;gt;里的time()函数一起使用。
srand((unsigned)time(NULL)); 连续生成多个随机数 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;time.h&amp;gt;int main() { int a, i; srand((unsigned)time(NULL)); //使用for循环生成10个随机数  for (i = 0; i &amp;lt; 10; i++) { a = rand(); printf(&amp;#34;%d &amp;#34;, a); } return 0; } 生成指定范围的随机数 想要生成指定范围的随机数，只要进行%运算就好了
int a = rand() % 10; //产生0~9的随机数 int a = rand() % 10 + 1; //产生1~10的随机数 连续生成不重复的随机数 这就是本文的重点了ヾ(•ω•`)o （其实就是为了记下这个算法才水了一篇文章）</description>
    </item>
    
    <item>
      <title>Git的常用命令</title>
      <link>https://lbqaq.top/p/git/</link>
      <pubDate>Wed, 16 Dec 2020 13:16:45 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/git/</guid>
      <description>基本操作 建立版本库：git init
查看结果：git status
查看不同：git diff
版本回退 查看提交日记：git log
回退：git reset --hard HEAD^
HEAD^表示上一个版本，HEAD^^表示前两个版本，HEAD~100表示前100个版本
恢复：git reflog查看命令历史，确定回到未来的哪个版本
撤销修改  直接丢弃工作区的修改时，用命令git checkout -- file 已经添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &amp;lt;file&amp;gt;，第二步按1操作。  上传 git remote add origin 仓库链接 #将远程仓库和本地仓库绑定 git add . git commit -m &amp;#34;提交信息&amp;#34; git push -u origin 自己当前的分支名 #-u将本地库和远程库的分支关联，之后可以不加 下载 git clone 仓库链接 git clone到当前文件夹
git clone 仓库链接 . 分支管理 创建与合并分支 查看分支：git branch
创建分支：git branch &amp;lt;name&amp;gt;
切换分支：git checkout &amp;lt;name&amp;gt;或者git switch &amp;lt;name&amp;gt;</description>
    </item>
    
    <item>
      <title>Blog常用的命令</title>
      <link>https://lbqaq.top/p/blog%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Tue, 15 Dec 2020 18:02:14 +0800</pubDate>
      
      <guid>https://lbqaq.top/p/blog%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/</guid>
      <description>主题相关 FrontMatter 字段含义
title: 标题 description: 描述 image: 显示的特色图片 comments: 显示 / 隐藏评论区(T/F) license: 文章协议 输入 false 可以隐藏 hidden: 隐藏文章（不在首页，归档等页面显示，但是可以直接通过链接访问） math: 是否加载 KaTeX 脚本 slug: 固定链接 draft: 是否为草稿 categories: 分类 tags: 标签 lastmod: 上次更新时间 MarkDown相关 # 我是一级标题 ## 我是二级标题 可对应1-6级标题 *斜体文本* **粗体文本** ***粗斜体文本*** 一行中用三个以上的星号*、减号-、底线_来建立一个分隔线 ~~删除线~~ &amp;lt;u&amp;gt;带下划线文本&amp;lt;/u&amp;gt; 创建脚注格式类似这样 [^JiaoZhu]。 [^JiaoZhu]: 脚注的内容 列表：*、+、-、1. &amp;gt; 区块 [链接文本](网址) 图片在前加! | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 </description>
    </item>
    
  </channel>
</rss>
