[{"content":"因为买了一台云服务器，不拿来干点啥实在是太亏了，于是便想到了可以使用云服务器来挂卡。\n步骤 安装.net环境 ASF是基于.netcore开发的程序，所以需要安装环境。这里建议看微软官方的安装文档，里面有不同系统的安装方法。\n我们需要安装的只是ASP.NET Core 运行时。\n我的系统是centos7，这里就只列举我系统上的命令了。\nsudo rpm -Uvh https://packages.microsoft.com/config/centos/7/packages-microsoft-prod.rpm sudo yum install aspnetcore-runtime-5.0 安装ASF 在ASF的发布页面上下载系统对应的版本解压即可。\n我这里是在本地先下载好后用WinSCP直接传上服务器。\n配置ASF 这里就采用官方的**在线配置文件生成器**自动生成即可。\n我们这里选择机器人，将steam的账号和密码填入，并将Enabled设置为True就行了。\n详细的配置内容可以在官方Wiki上看到，这里就不再赘述了。\n下面放上我的配置文件：\n{ \u0026#34;SteamLogin\u0026#34;: \u0026#34;xxx\u0026#34;, \u0026#34;SteamPassword\u0026#34;: \u0026#34;xxx\u0026#34;, \u0026#34;Enabled\u0026#34;: true, \u0026#34;CustomGamePlayedWhileFarming\u0026#34;: \u0026#34;挂卡中...\u0026#34;, \u0026#34;CustomGamePlayedWhileIdle\u0026#34;: \u0026#34;空闲中...\u0026#34;, \u0026#34;FarmingOrders\u0026#34;: [ 15, 12 ], \u0026#34;HoursUntilCardDrops\u0026#34;: 0, \u0026#34;OnlineStatus\u0026#34;: 1 }  CustomGamePlayedWhileFarming：表示挂卡时显示的游戏名 CustomGamePlayedWhileIdle：表示空闲时显示的游戏名 HoursUntilCardDrops：表示至少将游戏挂到几小时，如果是非限制账户，调到0是最好的。  我们也可以配置ASF本身的设置，这里也同样贴上我的配置：\n{ \u0026#34;s_SteamOwnerID\u0026#34;: \u0026#34;xxx\u0026#34;, \u0026#34;CurrentCulture\u0026#34;: \u0026#34;zh-CN\u0026#34;, \u0026#34;IPCPassword\u0026#34;: \u0026#34;xxx\u0026#34; }  s_SteamOwnerID：该属性定义 ASF 进程所有者的 64 位 Steam ID，直接设置成自己的大号就行 CurrentCulture：ASF的语言 IPCPassword：由于ASF默认会开启IPC服务，为了安全起见建议设置密码或关闭IPC服务。  将配置文件放入config目录里就行了。\n启动ASF 首先将ASF的主程序设置为可执行：\nsudo chmod 755 ./ArchiSteamFarm 然后运行即可：\n./ArchiSteamFarm 附加步骤 使用ASCF 由于服务器在大陆境内，由于众所周知的原因是无法访问steam社区的，这时就需要使用大佬开发的转发工具了。\n【更新2.0】另一个SteamCommunityFix | 支持Win/Linux/MacOS 【2018-08-29】\n下载地址：https://pan.baidu.com/s/1nvBW8qP\n使用步骤：\n  下载并解压缩\n  打开终端（Terminal），进入到ascf程序目录： 如ascf程序在 /Users/Makazeu/Downloads/文件夹中，那么在终端中输入\ncd /Users/Makazeu/Downloads   赋予程序可执行权限，在终端中输入命令：\nchmod +x ./ascf   使用root用户（管理员用户）运行程序，在终端中输入\nsudo ./ascf 输入root用户密码后，看程序是否运行 因为程序涉及到hosts文件修改，需要高权限，所以你需要输入root密码\n  若程序已经成功运行，此时就不要关闭终端窗口了，否则程序就会退出！试下Steam社区能否正常打开\n  使用Tmux 由于我们在服务器上使用，不可能一直开着ssh，这时就需要将终端窗口和会话解绑，Tmux就是做这个工作的。\n安装：\n# Ubuntu 或 Debian $ sudo apt-get install tmux # CentOS 或 Fedora $ sudo yum install tmux # Mac $ brew install tmux 常用命令/快捷键：\n  新建会话：Tmux 窗口默认是以0、1、2\u0026hellip;\u0026hellip;来编号的，为了便于区分，可以为每个会话起名\ntmux new -s \u0026lt;session-name\u0026gt;   分离当前会话：Ctrl+b d\n  列出所有会话：Ctrl+b s或tmux ls\n  重命名当前会话：Ctrl+b $或tmux rename-session -t 0 \u0026lt;new-name\u0026gt;\n  接入到某个会话：\n# 使用会话编号 $ tmux attach -t 0 # 使用会话名称 $ tmux attach -t \u0026lt;session-name\u0026gt;   切换到某个会话：\n# 使用会话编号 $ tmux switch -t 0 # 使用会话名称 $ tmux switch -t \u0026lt;session-name\u0026gt;   参考链接  Tmux 使用教程 - 阮一峰的网络日志 ASF官方Wiki NET开发文档  ","date":"2021-08-11T21:46:24+08:00","image":"https://luobo.cf/p/asf/82970659_hu38fcc35bf47ad0f09aab60914ff90ed7_427280_120x120_fill_q75_box_smart1.jpg","permalink":"https://luobo.cf/p/asf/","title":"从零开始ASF挂卡"},{"content":"花了四天的时间，终于把MyBatis的视频教程全部看完了，为了以后不要那么快的遗忘掉，还是来写一下笔记比较好。\n下面的内容都是基于遇见狂神说的MyBatis视频教程而来，在此感谢能提供这么优秀的教程。\n简介  MyBatis的作用用我自己的话说，就是不用自己手动搞JDBC了，省事，行！ MyBatis作用于持久层——DAO层 【DAO (Data Access Object) 数据访问对象】，通俗点说就是用来操作数据库的层 选择MyBatis的最大原因还是用的人多，为后面的Spring打基础_(:з)∠)_  第一个MyBatis程序 思路流程：搭建环境\u0026ndash;\u0026gt;导入MyBatis\u0026mdash;\u0026gt;编写代码\u0026mdash;\u0026gt;测试\n具体代码   创建Maven项目\n  引入依赖包\n\u0026lt;!-- 导入依赖 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- mysql驱动 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.25\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- junit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;   在resources目录下创建mybatis-config.xml，作为MyBatis的配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;!--核心配置文件--\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!--每一个mapper都需要注册--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;UserMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;   编写MyBatis工具类，在utils的包下面创建MybatisUtils类，填入以下代码\nimport org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; //SqlSessionFactory  /** * @author luoboQAQ */ public class MybatisUtils { private static SqlSessionFactory sqlSessionFactory; static { try { //使用Mybatis第一步：获取SqlSessionFactory  String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。  //SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。  public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(); } }   在pojo包下创建实体类\npublic class User { private int id; //id  private String name; //姓名  private String pwd; //密码  //构造,有参,无参  //set/get  //toString() }   在dao包下创建接口类，我们需要的功能就填入到这里面\nimport top.lbqaq.pojo.User; import java.util.List; import java.util.Map; public interface UserMapper { //模糊查询  List\u0026lt;User\u0026gt; getUserLike(String value); //查询全部用户  List\u0026lt;User\u0026gt; getUserList(); //根据ID查询用户  User getUserById(int id); //插入用户  int addUser(User user); int addUser2(Map\u0026lt;String,Object\u0026gt; map); //修改用户  int updateUser(User user); //删除用户  int deleteUser(int id); }   编写Mapper.xml配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!--namespace绑定一个对应的Dao/Mapper接口--\u0026gt; \u0026lt;mapper namespace=\u0026#34;top.lbqaq.dao.UserMapper\u0026#34;\u0026gt; \u0026lt;!--id就是namespace中对应的方法名，resultType：sql语句的返回值--\u0026gt; \u0026lt;select id=\u0026#34;getUserList\u0026#34; resultType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;getUserLike\u0026#34; resultType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; select * from user where name like #{value} \u0026lt;/select\u0026gt; \u0026lt;!--parameterType：传入参数类型--\u0026gt; \u0026lt;select id=\u0026#34;getUserById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; select * from user where id=#{id} \u0026lt;/select\u0026gt; \u0026lt;insert id=\u0026#34;addUser\u0026#34; parameterType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; insert into user (id,name,pwd) values (#{id},#{name},#{pwd}) \u0026lt;/insert\u0026gt; \u0026lt;!--传递map的key--\u0026gt; \u0026lt;insert id=\u0026#34;addUser2\u0026#34; parameterType=\u0026#34;map\u0026#34;\u0026gt; insert into user (id,name,pwd) values (#{userid},#{userName},#{passWord}) \u0026lt;/insert\u0026gt; \u0026lt;update id=\u0026#34;updateUser\u0026#34; parameterType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; update user set name =#{name},pwd=#{pwd} where id=#{id} \u0026lt;/update\u0026gt; \u0026lt;delete id=\u0026#34;deleteUser\u0026#34; parameterType=\u0026#34;int\u0026#34;\u0026gt; delete from user where id=#{id} \u0026lt;/delete\u0026gt; \u0026lt;/mapper\u0026gt;   进行测试\nimport org.apache.ibatis.session.SqlSession; import org.junit.Test; import top.lbqaq.pojo.User; import top.lbqaq.utils.MybatisUtils; import java.util.HashMap; import java.util.List; public class UserMapperTest { @Test public void test() { //获得sqlSession对象  try (SqlSession sqlSession = MybatisUtils.getSqlSession()) { //执行SQL  UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u0026lt;User\u0026gt; userList = mapper.getUserList(); for (User user : userList) { System.out.println(user); } } } @Test public void getUserLike() { //获得sqlSession对象  try (SqlSession sqlSession = MybatisUtils.getSqlSession()) { //执行SQL  UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u0026lt;User\u0026gt; userList = mapper.getUserLike(\u0026#34;%李%\u0026#34;); for (User user : userList) { System.out.println(user); } } } @Test public void getUserById() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); sqlSession.close(); } @Test public void addUser(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); int res = mapper.addUser(new User(4, \u0026#34;小明\u0026#34;, \u0026#34;123\u0026#34;)); if(res\u0026gt;0){ System.out.println(\u0026#34;提交成功\u0026#34;); //提交事务  sqlSession.commit(); } sqlSession.close(); } @Test public void addUser2(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap\u0026lt;String,Object\u0026gt; map= new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;userid\u0026#34;,5); map.put(\u0026#34;userName\u0026#34;,\u0026#34;小绿\u0026#34;); map.put(\u0026#34;passWord\u0026#34;,\u0026#34;1234\u0026#34;); int res = mapper.addUser2(map); if(res\u0026gt;0){ System.out.println(\u0026#34;提交成功\u0026#34;); //提交事务  sqlSession.commit(); } sqlSession.close(); } @Test public void updateUser(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); int res = mapper.updateUser(new User(4, \u0026#34;小明\u0026#34;, \u0026#34;123456\u0026#34;)); if(res\u0026gt;0){ System.out.println(\u0026#34;提交成功\u0026#34;); //提交事务  sqlSession.commit(); } sqlSession.close(); } @Test public void deleteUser(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); int res = mapper.deleteUser(4); if(res\u0026gt;0){ System.out.println(\u0026#34;提交成功\u0026#34;); //提交事务  sqlSession.commit(); } sqlSession.close(); } }   注意事项   如果Mapper.xml创建在java目录里而不是resouces里，需要在Maven配置里配置过滤，否则会保错\n\u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt;   当需要传入参数进行查询而不是传入实体类，有两种方法\n  第一种：直接在方法中传递参数。\n在接口方法的参数前加@Param属性，sql语句编写的时候，直接取@Param中设置的值即可，不需要单独设置参数类型\nUser selectUserByNP(@Param(\u0026#34;username\u0026#34;) String username,@Param(\u0026#34;pwd\u0026#34;) String pwd); /* \u0026lt;select id=\u0026#34;selectUserByNP\u0026#34; resultType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; select * from user where name = #{username} and pwd = #{pwd} \u0026lt;/select\u0026gt; */   第二种：通过map来传递参数。（推荐）\n在接口创建时就直接使用map作为参数\nint addUser2(Map\u0026lt;String,Object\u0026gt; map); 在写sql时直接设置入参为map即可\n\u0026lt;!--传递map的key--\u0026gt; \u0026lt;insert id=\u0026#34;addUser2\u0026#34; parameterType=\u0026#34;map\u0026#34;\u0026gt; insert into user (id,name,pwd) values (#{userid},#{userName},#{passWord}) \u0026lt;/insert\u0026gt;     配置解析 官方文档\n核心配置 MyBatis官方给出的配置项有以下这么多：\nconfiguration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） \u0026lt;!-- 注意元素节点的顺序！顺序不对会报错 --\u0026gt; 我们需要关注的就是properties（属性）、settings（设置）、typeAliases（类型别名）、plugins（插件）、environments（环境配置）、mappers（映射器）这几项配置，其余的可以忽略（基本用不到）\nproperties 数据库这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。\n说白了，就是能将数据库那些配置项从核心配置中剥离出来，降低耦合。\n用法   在resources目录下创建db.properties，填入下面的内容\ndriver=com.mysql.cj.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis username=root password=root   在配置xml中导入\n\u0026lt;!--引用外部配置文件--\u0026gt; \u0026lt;properties resource=\u0026#34;db.properties\u0026#34;\u0026gt; \u0026lt;!--外部文件优先级大于内部（下面）--\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123\u0026#34;/\u0026gt; \u0026lt;/properties\u0026gt; 正常情况下，只需要用\u0026lt;properties resource=\u0026quot;db.properties\u0026quot;/\u0026gt;这短短一句就行了，上面的代码是用来测试优先级的\n  settings 这里存放的是MyBatis的一些设置项，具体的内容在官方文档上可以查看\n常用的设置项有以下几个：\n   设置名 描述 有效值 默认值     cacheEnabled 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。 true | false true   mapUnderscoreToCamelCase 是否开启驼峰命名自动映射，即从经典数据库列名A_COLUMN 映射到经典 Java 属性名 aColumn。 true | false False   logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 未设置    typeAliases 类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。\n也就是在resultType和parameterType中不需要写那么长的类名了\n用法 \u0026lt;!--可以给实体类起别名--\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;!--手动指定--\u0026gt; \u0026lt;typeAlias type=\u0026#34;top.lbqaq.pojo.User\u0026#34; alias=\u0026#34;User\u0026#34;/\u0026gt; \u0026lt;!--自动扫描包下所有类，别名为类名全小写--\u0026gt; \u0026lt;package name=\u0026#34;top.lbqaq.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; 有两种方法，第一种就是手动指定别名，第二种就是通过package标签自动扫描包下所有的类\n在第二种方法下，默认别名是类名全小写（当然首字母大写也同样可用）\n如果在类前加上@Alias注解，则别名就为手动设定的内容。\nplugins 这里是配置mybatis的插件的地方，常用的插件有以下几个：\n PageHelper MyBatis-Plus \u0026hellip; \u0026hellip;  这里是就不展开这些插件了，以后有需要再看\nenvironments 配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定）。\n\u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt;  transactionManager： 事务管理器 。有两个选项：  JDBC：正常的 MANAGED：几乎啥都不干   dataSource：如何使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。有三个选项：  unpooled：这个数据源的实现只是每次被请求时打开和关闭连接。 pooled：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。 jndi：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。    mappers 用于告诉MyBatis我们写的xml文件到底在哪，每个xml文件都需要绑定！\n常用的有以下几种方法：\n\u0026lt;!-- 使用相对于类路径的资源引用 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;top/lbqaq/dao/UserMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;!-- 使用映射器接口实现类的完全限定类名 需要配置文件名称和接口名称一致，并且位于同一目录下 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026#34;top.lbqaq.dao.UserMapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;!-- 将包内的映射器接口实现全部注册为映射器 但是需要配置文件名称和接口名称一致，并且位于同一目录下 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;package name=\u0026#34;org.mybatis.builder\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; ResultMap 属性名和字段名不一致 在实际开发中，会遇到类的属性名和数据库的字段名不一致，这时MyBatis的自动匹配将无法产生作用，这时可以使用ResultMap来解决这个问题。\n\u0026lt;mapper namespace=\u0026#34;top.lbqaq.dao.UserMapper\u0026#34;\u0026gt; \u0026lt;!--结果集映射--\u0026gt; \u0026lt;resultMap id=\u0026#34;UserMap\u0026#34; type=\u0026#34;User\u0026#34;\u0026gt; \u0026lt;!--column:数据库中的字段；property：实体类的属性--\u0026gt; \u0026lt;!-- \u0026lt;result column=\u0026#34;id\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;result column=\u0026#34;name\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;result column=\u0026#34;pwd\u0026#34; property=\u0026#34;password\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getUserById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultMap=\u0026#34;UserMap\u0026#34;\u0026gt; select * from user where id=#{id} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 多对一 在开发时常常会有这样的需求，比如多个学生都被一个老师教，下面将对该实例具体展开来了解多对一如何处理。\n环境搭建   添加Lombok插件\n  引入Maven依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.20\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   编写实体类\n@Data public class Student { private int id; private String name; /** * 学生需要关联一个老师 */ private Teacher teacher; } @Data public class Teacher { private int id; private String name; }   按查询嵌套处理 思路：\n  获取所有学生的信息\n  根据获取的学生信息的老师ID-\u0026gt;获取该老师的信息\n  思考问题，这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般使用关联查询？\n 做一个结果集映射：StudentTeacher StudentTeacher结果集的类型为 Student 学生中老师的属性为teacher，对应数据库中为tid。 多个 [1,\u0026hellip;）学生关联一个老师=\u0026gt; 一对一，一对多 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查询    \u0026lt;select id=\u0026#34;getStudent\u0026#34; resultMap=\u0026#34;StudentTeacher\u0026#34;\u0026gt; select * from student \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;StudentTeacher\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;id\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;name\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;!--复杂的属性需要单独处理 对象：association 集合：collection--\u0026gt; \u0026lt;association column=\u0026#34;tid\u0026#34; property=\u0026#34;teacher\u0026#34; javaType=\u0026#34;Teacher\u0026#34; select=\u0026#34;getTeacher\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultType=\u0026#34;Teacher\u0026#34;\u0026gt; select * from teacher where id=#{tid} \u0026lt;/select\u0026gt; 注意点：\n\u0026lt;resultMap id=\u0026#34;StudentTeacher\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--\u0026gt; \u0026lt;association property=\u0026#34;teacher\u0026#34; column=\u0026#34;{id=tid,name=tid}\u0026#34; javaType=\u0026#34;Teacher\u0026#34; select=\u0026#34;getTeacher\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!-- 这里传递过来的id，只有一个属性的时候，下面可以写任何值 association中column多参数配置： column=\u0026#34;{key=value,key=value}\u0026#34; 其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。 --\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultType=\u0026#34;teacher\u0026#34;\u0026gt; select * from teacher where id = #{id} and name = #{name} \u0026lt;/select\u0026gt; 这个还是比较难以理解的，一般我选择用第二种方法\n按结果嵌套处理 \u0026lt;!--按照结果嵌套处理--\u0026gt; \u0026lt;select id=\u0026#34;getStudent2\u0026#34; resultMap=\u0026#34;StudentTeacher2\u0026#34;\u0026gt; select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid=t.id \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;StudentTeacher2\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;sid\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;sname\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;association property=\u0026#34;teacher\u0026#34; javaType=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;tname\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; 这种就比较好理解了，难度主要在sql部分，好在之前数据库学的还行，这种方法还是比较适合我。\n一对多 一个老师会教多个学生。\n环境搭建 @Data public class Student { private int id; private String name; private int tid; } @Data public class Teacher { private int id; private String name; /** * 一个老师有多个学生 */ private List\u0026lt;Student\u0026gt; students; } 按结果嵌套查询 \u0026lt;!--按结果嵌套查询--\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultMap=\u0026#34;TeacherStudent\u0026#34;\u0026gt; select s.id sid,s.name sname,t.name tname,t.id tid from student s,teacher t where s.tid=t.id and t.id=#{tid} \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;TeacherStudent\u0026#34; type=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;tid\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;tname\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;!--集合中的泛型信息用ofType获取--\u0026gt; \u0026lt;collection property=\u0026#34;students\u0026#34; ofType=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;sid\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;sname\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;tid\u0026#34; property=\u0026#34;tid\u0026#34;/\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt; JavaType和ofType都是用来指定对象类型的。\nJavaType是用来指定pojo中属性的类型。\nofType指定的是映射到list集合属性中pojo的类型。\n按查询嵌套 \u0026lt;!--按查询嵌套--\u0026gt; \u0026lt;select id=\u0026#34;getTeacher2\u0026#34; resultMap=\u0026#34;TeacherStudent2\u0026#34;\u0026gt; select * from teacher where id=#{tid} \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;TeacherStudent2\u0026#34; type=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;collection property=\u0026#34;students\u0026#34; javaType=\u0026#34;ArrayList\u0026#34; ofType=\u0026#34;Student\u0026#34; select=\u0026#34;getStudentByTeacherId\u0026#34; column=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getStudentByTeacherId\u0026#34; resultType=\u0026#34;Student\u0026#34;\u0026gt; select * from student where tid = #{tid} \u0026lt;/select\u0026gt; 日志工厂 如果一个数据库相关的操作出现了问题，我们可以根据输出的SQL语句快速排查问题。可见打印出SQL语句是十分重要的。（还记得之前项目综合实践为了搞日志忙了半天，结果还是没搞出来😭）\n标准日志 在MyBatis里自带了通过控制台打印的日志功能，如果项目并不是很复杂，用它就足够了。\n只需要在设置里设置启用就可以了。\n\u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;STDOUT_LOGGING\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; log4j log4j相比标准日志，那不知道高到哪里去了，具体的功能我就不写了，毕竟一百度就能出来了。\n使用步骤：\n  导入log4j的包\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   在resources目录下新建log4j.properties，并填入以下配置文件\n#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码 log4j.rootLogger=DEBUG,console,file #控制台输出的相关设置 log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n #文件输出的相关设置 log4j.appender.file = org.apache.log4j.RollingFileAppender log4j.appender.file.File=./log/log.log log4j.appender.file.MaxFileSize=10mb log4j.appender.file.Threshold=DEBUG log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n #日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG   在MyBatis里启用\n\u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;LOG4J\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt;   在程序中使用Log4j进行输出\nimport org.apache.log4j.Logger; import org.junit.Test; public class UserMapperTest { static Logger logger = Logger.getLogger(UserMapperTest.class); @Test public void testLog4j(){ logger.info(\u0026#34;info:进入了testLog4j\u0026#34;); logger.debug(\u0026#34;debug:进入了testLog4j\u0026#34;); logger.error(\u0026#34;error:进入了testLog4j\u0026#34;); } }   使用注解开发 MyBatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。\n而到MyBatis 3提供了新的基于注解的配置。不幸的是，Java 注解的的表达力和灵活性十分有限。最强大的 MyBatis 映射并不能用注解来构建。\n在注解开发中，主要使用这几个注解：@select ()、@update ()、@Insert ()、@delete ()\n举例：\npublic interface UserMapper { @Select(\u0026#34;select * from user\u0026#34;) List\u0026lt;User\u0026gt; getUser(); @Select(\u0026#34;select * from user where id=#{id}\u0026#34;) User getUserByID(@Param(\u0026#34;id\u0026#34;) int id); @Insert(\u0026#34;insert into user(id,name,pwd) values(#{id},#{name},#{pwd})\u0026#34;) int addUser(User user); } 改造MybatisUtils工具类的getSession() 方法，重载实现。\n//获取SqlSession连接 public static SqlSession getSession(){ return getSession(true); //事务自动提交 } public static SqlSession getSession(boolean flag){ return sqlSessionFactory.openSession(flag); } @Param注解用于给方法参数起一个名字。以下是总结的使用原则：\n 在方法只接受一个参数的情况下，可以不使用@Param。 在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。 如果参数是 JavaBean ， 则不能使用@Param。 不使用@Param注解时，参数只能有一个，并且是JavaBean。  动态SQL 动态SQL指的是根据不同的查询条件 , 生成不同的sql语句。\n主要使用这几个标签：if、choose、where、set、foreach\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;top.lbqaq.dao.BlogMapper\u0026#34;\u0026gt; \u0026lt;insert id=\u0026#34;addBook\u0026#34; parameterType=\u0026#34;Blog\u0026#34;\u0026gt; insert into blog(id, title, author, create_time, views) values (#{id}, #{title}, #{author}, #{createTime}, #{views}) \u0026lt;/insert\u0026gt; \u0026lt;select id=\u0026#34;queryBlogIF\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;queryBlogChoose\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; and views = #{view} \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;update id=\u0026#34;updateBlog\u0026#34; parameterType=\u0026#34;map\u0026#34;\u0026gt; update blog \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id = #{id} \u0026lt;/update\u0026gt; \u0026lt;select id=\u0026#34;queryBlogForeach\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;!--collection:指定输入对象中的集合属性 item:每次遍历生成的对象 open:开始遍历时的拼接字符串 close:结束时拼接的字符串 separator:遍历对象之间需要拼接的字符串--\u0026gt; \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34; separator=\u0026#34;or\u0026#34;\u0026gt; id = #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; SQL片段 有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。\n提取SQL片段：\n\u0026lt;sql id=\u0026#34;if-title-author\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/sql\u0026gt; 引用SQL片段：\n\u0026lt;select id=\u0026#34;queryBlogIf\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --\u0026gt; \u0026lt;include refid=\u0026#34;if-title-author\u0026#34;\u0026gt;\u0026lt;/include\u0026gt; \u0026lt;!-- 在这里还可以引用其他的 sql 片段 --\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 注意：\n①、最好基于 单表来定义 sql 片段，提高片段的可重用性\n②、在 sql 片段中不要包括 where\n缓存 简介 1、什么是缓存 [ Cache ]？\n 存在内存中的临时数据。 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。  2、为什么使用缓存？\n 减少和数据库的交互次数，减少系统开销，提高系统效率。  3、什么样的数据能使用缓存？\n 经常查询并且不经常改变的数据。  MyBatis缓存   MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。\n  MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存\n   默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存    一级缓存 一级缓存也叫本地缓存：\n 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；  一级缓存失效的四种情况  sqlSession不同 sqlSession相同，查询条件不同 sqlSession相同，两次查询之间执行了增删改操作！ sqlSession相同，手动清除一级缓存  二级缓存   二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存\n  基于namespace级别的缓存，一个名称空间，对应一个二级缓存；\n  工作机制\n   一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存（map）中；    使用方法   开启全局缓存 mybatis-config.xml\n\u0026lt;setting name=\u0026#34;cacheEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt;   去每个mapper.xml中配置使用二级缓存，这个配置非常简单。\n\u0026lt;cache/\u0026gt; 官方示例 \u0026lt;cache eviction=\u0026#34;FIFO\u0026#34; flushInterval=\u0026#34;60000\u0026#34; size=\u0026#34;512\u0026#34; readOnly=\u0026#34;true\u0026#34;/\u0026gt; 这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。   ","date":"2021-08-11T11:11:10+08:00","image":"https://luobo.cf/p/mybatis/86164137_hudf396ad5f75caaaed9aa8bcb008fce93_362314_120x120_fill_q75_box_smart1.jpg","permalink":"https://luobo.cf/p/mybatis/","title":"MyBatis学习笔记"},{"content":"这篇文章我打算来介绍一下如何构建qsqlmysql.dll，由于版权原因，在新版的Qt里是不自带该dll的，这样对我们编写数据库程序会很麻烦。（你用ODBC？那没事了）\n我在网上也查了很多资料，但根据步骤来总是会报错，提示没有mysql.h这个头文件。下面就记录一下我成功编译的过程。\n基于cmake的步骤 在6.1之后的Qt版本中，Qt公司删除了qmake而更换成了cmake的方式来构建项目文件，下面就是我总结的使用cmake生成的方法。\n注意： 路径的前段部分(软件的安装位置)每个人可能都不一样，但是路径的后段部分应该是一样的，请自行修改。\n1.准备好Qt的源代码，如果没有可以在Qt的安装目录打开MaintenanceTool.exe启动Qt组件管理，在里面勾选Src把源码下载下来。\n2.打开cmake-gui，选择目标文件夹为D:\\Qt\\6.1.1\\Src\\qtbase\\src\\plugins\\sqldrivers，并设置生成文件夹为D:/Qt/6.1.1/Src/qtbase/src/plugins/sqldrivers/build\n 配置文件夹 \n3.点击左下角的Configure，会提示生成的目录不存在是否创建，直接点是就可以了。\n4.编译器这里选择MinGW Makefiles,然后点击Finish\n 选择编译器 \n5.等待生成完成后，把FEATURE_sql_mysql后面的勾勾上，然后把其余的FEATURE_sql后面的勾取消。\n 选择生成模块 \n6.再次点击左下角的Configure，可以发现上面的红框已经消失了，说明配置成功了。然后点击Generate，生成Makefiles。\n 配置成功 \n7.这时配置文件已经构建完成了，接下来就是生成dll了，打开PowerShell切换目录至D:/Qt/6.1.1/Src/qtbase/src/plugins/sqldrivers/build，输入mingw32-make开始编译生成dll。\n 编译成功 \n没有报错，说明生成成功。\n8.最后打开目录D:\\Qt\\6.1.1\\Src\\qtbase\\src\\plugins\\sqldrivers\\build\\plugins\\sqldrivers，就可以看到生成好的qsqlmysql.dll了。\n基于qmake的步骤 注意： 路径的前段部分(软件的安装位置)每个人可能都不一样，但是路径的后段部分应该是一样的，请自行修改。\n1.准备好Qt的源代码，如果没有可以在Qt的安装目录打开MaintenanceTool.exe启动Qt组件管理，在里面勾选Src把源码下载下来。\n2.进入D:\\Qt\\6.0.3\\Src\\qtbase\\src\\plugins\\sqldrivers目录下，打开sqldrivers.pro这个文件。\n3.在左侧文件树中打开mysql文件夹，选择mysql.pro打开。\n4.修改里面的内容：\n  注释掉QMAKE_USE += mysql这一句\n  增加下面三行代码(注意把D:/MySQL/改为你MySQL的安装路径)：\nLIBS +=-LD:/MySQL/lib -llibmysql INCLUDEPATH += D:/MySQL/include DEPENDPATH += D:/MySQL/include   5.点击Qt左下角的小锤子进行构建，不出意外的话就可以在D:\\Qt\\6.0.3\\Src\\qtbase\\src\\plugins这个路径下看到build开头的文件夹，在.\\plugins\\sqldrivers目录下就能看到编译好的dll了。\n6.最后将qsqlmysql.dll放入D:\\Qt\\6.0.3\\mingw81_64\\plugins\\sqldrivers\\里就行了。如果链接数据库时还报错，就把libmysql.dll复制到Qt的编译器的D:\\Qt\\6.0.3\\mingw81_64\\bin\\目录。\n","date":"2021-06-03T15:44:17+08:00","image":"https://luobo.cf/p/qt%E6%9E%84%E5%BB%BAqsqlmysql.dll/89217963_hu5f736f3854c953c513cfaec8c3d31831_4303313_120x120_fill_box_smart1_3.png","permalink":"https://luobo.cf/p/qt%E6%9E%84%E5%BB%BAqsqlmysql.dll/","title":"Qt构建qsqlmysql.dll"},{"content":"1202年了，是时候抛弃老旧的cmd窗口和臃肿的VM虚拟机了，来试试巨硬推出的WSL2+Windows Terminal(～￣▽￣)～。\n起因 在知乎上刷到了一篇回答，是关于Windows编程的体验的。在这篇文章中提到了WSL2和Windows Terminal，我一下就被那精美的界面吸引了（管他好不好用，好看就完事了）。正好现在在上操作系统这门课，需要使用Linux进行实验，这还说什么，直接开冲。\n 精美的界面 \nWSL2安装 安装其实很简单，按照微软的教程一步一步做就完事了。\n0.前置条件 想要用WSL2，首先你得是 Windows 10，而且还有版本号要求。\n 对于 x64 系统：版本 1903 或更高版本，采用 内部版本 18362 或更高版本。 对于 ARM64 系统：版本 2004 或更高版本，采用 内部版本 19041 或更高版本。  1. 开启WSL服务 在Powershell(管理员)中输入下面的命令：\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 2. 启用虚拟机服务 在Powershell(管理员)中输入下面的命令：\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 重新启动 计算机，以完成 WSL 安装并更新到 WSL 2。\n3. 下载 Linux 内核更新包 下载最新包并安装：\n 适用于 x64 计算机的 WSL2 Linux 内核更新包  4. 将 WSL 2 设置为默认版本 在Powershell中输入下面的命令：\nwsl --set-default-version 2 5.安装 Linux  打开 Microsoft Store，并选择你偏好的 Linux 分发版并点击获取进行安装。 等安装好后，打开并设置用户名和密码。  到此WSL2就安装完事了。\nWindows Terminal安装 1. 下载和安装   从Microsoft Store中下载\n  从Github上下载\n  2. 配置 为了让Windows Terminal看起来更好看一些，我们还要对其进行一些配置。\n 设置 \n打开Windows Terminal的设置选项，然后选打开JSON文件，把我配好的配置文件粘贴进去\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://aka.ms/terminal-profiles-schema\u0026#34;, // Add custom actions and keybindings to this array. // To unbind a key combination from your defaults.json, set the command to \u0026#34;unbound\u0026#34;. // To learn more about actions and keybindings, visit https://aka.ms/terminal-keybindings \u0026#34;actions\u0026#34;: [ // Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json. // These two lines additionally bind them to Ctrl+C and Ctrl+V. // To learn more about selection, visit https://aka.ms/terminal-selection { \u0026#34;command\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;copy\u0026#34;, \u0026#34;singleLine\u0026#34;: false }, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+c\u0026#34; }, { \u0026#34;command\u0026#34;: \u0026#34;paste\u0026#34;, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+v\u0026#34; }, // Press Ctrl+Shift+F to open the search box { \u0026#34;command\u0026#34;: \u0026#34;find\u0026#34;, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+shift+f\u0026#34; }, // Press Alt+Shift+D to open a new pane. // - \u0026#34;split\u0026#34;: \u0026#34;auto\u0026#34; makes this pane open in the direction that provides the most surface area. // - \u0026#34;splitMode\u0026#34;: \u0026#34;duplicate\u0026#34; makes the new pane use the focused pane\u0026#39;s profile. // To learn more about panes, visit https://aka.ms/terminal-panes { \u0026#34;command\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;splitPane\u0026#34;, \u0026#34;split\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;splitMode\u0026#34;: \u0026#34;duplicate\u0026#34; }, \u0026#34;keys\u0026#34;: \u0026#34;alt+shift+d\u0026#34; } ], \u0026#34;copyFormatting\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;copyOnSelect\u0026#34;: false, \u0026#34;defaultProfile\u0026#34;: \u0026#34;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\u0026#34;, \u0026#34;initialCols\u0026#34;: 120, \u0026#34;initialRows\u0026#34;: 30, \u0026#34;profiles\u0026#34;: { \u0026#34;defaults\u0026#34;: { \u0026#34;acrylicOpacity\u0026#34;: 0.75, \u0026#34;closeOnExit\u0026#34;: \u0026#34;graceful\u0026#34;, \u0026#34;colorScheme\u0026#34;: \u0026#34;Campbell\u0026#34;, \u0026#34;cursorColor\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, \u0026#34;cursorShape\u0026#34;: \u0026#34;bar\u0026#34;, \u0026#34;fontFace\u0026#34;: \u0026#34;Consolas\u0026#34;, \u0026#34;fontSize\u0026#34;: 13, \u0026#34;historySize\u0026#34;: 9001, \u0026#34;padding\u0026#34;: \u0026#34;0, 0, 0, 0\u0026#34;, \u0026#34;snapOnInput\u0026#34;: true, \u0026#34;startingDirectory\u0026#34;: \u0026#34;./\u0026#34;, \u0026#34;useAcrylic\u0026#34;: true }, \u0026#34;list\u0026#34;: [ { \u0026#34;commandline\u0026#34;: \u0026#34;powershell.exe -NoLogo\u0026#34;, \u0026#34;guid\u0026#34;: \u0026#34;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Windows PowerShell\u0026#34; }, { \u0026#34;commandline\u0026#34;: \u0026#34;cmd.exe\u0026#34;, \u0026#34;guid\u0026#34;: \u0026#34;{0caa0dad-35be-5f56-a8ff-afceeeaa6101}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Command Prompt\u0026#34; }, { \u0026#34;guid\u0026#34;: \u0026#34;{b453ae62-4e3d-5e58-b989-0a998ec441b8}\u0026#34;, \u0026#34;hidden\u0026#34;: true, \u0026#34;name\u0026#34;: \u0026#34;Azure Cloud Shell\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;Windows.Terminal.Azure\u0026#34; }, { \u0026#34;guid\u0026#34;: \u0026#34;{2c4de342-38b7-51cf-b940-2309a097f518}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Ubuntu\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;Windows.Terminal.Wsl\u0026#34;, \u0026#34;startingDirectory\u0026#34;: \u0026#34;//wsl$/Ubuntu/home/luobo\u0026#34; } ] } } 一般要修改这几项：\n fontFace - 字体，我的字体为Consolas，适合1080P的屏幕。高分辩率屏建议用monaco或者fira code fontSize - 字体大小，因人而异，因屏幕而异，自己根据视觉效果调整大小 acrylicOpacity - 背景透明度，同样因人而异，因屏幕而异，自己根据视觉效果调整大小 initialCols - 初始窗口宽度，同样因人而异，因屏幕而异，自己根据视觉效果调整大小 initialRows - 初始窗口高度，同样因人而异，因屏幕而异，自己根据视觉效果调整大小 startingDirectory - Ubuntu的默认打开路径，把其中的luobo换成你自己的用户名。  WSL+VSCode 毕竟都是微软家的软件，直接就能通过VSCode来远程编辑Linux里的文件。vim太难上手？我直接在Windows里编程(雾)。\n只要在项目目录里键入code .，就会自动跳到Windows里的VSCode里了。\n小结 WSL+Windows Terminal+VSCode，将三者配合起来，我觉得可以实现1+1+1\u0026gt;3的功能，毕竟，谁不喜欢颜值高的软件呢ヾ(≧▽≦*)o\n参考链接  微软官方WSL2教程 微软官方Windows Terminal教程 Windows Terminal 终端入门  ","date":"2021-04-08T13:14:20+08:00","image":"https://luobo.cf/p/wsl2-wt%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93/43493473_hu0b461f4faf109c1e7e1e6db59436d03b_285140_120x120_fill_box_smart1_3.png","permalink":"https://luobo.cf/p/wsl2-wt%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93/","title":"WSL2+WT配置小结"},{"content":"PyAipao简介 该项目可实现阳光体育一键跑步，同时可基于GitHub Actions来实现云跑步。\n仅需一次配置，即可轻松跑完一学期ヾ(≧▽≦*)o\n准备工作 1.一个github账号 2.抓包抓到的IMEICode 3.Server酱的SCKEY或企业微信（可选，用于微信推送跑步结果）  云跑步上手教程 1.点击fork按钮将该仓库复制到你的仓库  fork \n2.获取 IMEICode\n 打开抓包软件抓包, 再打开阳光体育 App 登录, 在所有的数据包中找后缀有 IMEICode=  的 URL 请求, 等号后面的字段即为七天有效的 IMEICode (若多次没抓到: 可来回切换几次飞行模式, 杀掉 App 后台重复尝试多次)  如果不需要推送，可以直接略过第3步\n3.1基于Server酱的推送\n 完成Server酱的注册和绑定 点我直达 在 SendKey这一页中找到SendKey并记录  SendKey   3.2基于企业微信应用消息的推送\n由于Server酱不捐助是无法查看消息内容的，所以为了白嫖我自己写了推送部分的代码，可以直接使用微信官方接口来推送。\n企业微信的配置方法可以在Server酱的消息通道里看到，这里就不赘述了。\n weisend \n和Server酱一样，我们也需要企业ID(CORPID)，应用ID(AGENTID)，应用Secret(SECRET)这三个值。\n4.配置Github Actions\n  打开仓库的secrets，在其中建立IMEICODE并将IMEICode填入  4.1 \n  （可选）使用Server酱推送，需要建立SCKEY并填入SendKey\n  （可选）使用企业微信应用消息推送，需要建立CORPID\u0026ndash;填入企业ID，AGENTID\u0026ndash;填入应用ID，SECRET\u0026ndash;填入应用Secret\n  打开Code-.github/workflows-autorun.yml，点击右上角的铅笔图标进行编辑，将时间改为你想让它每天按时跑的时间，默认为每天上午9点；同时修改推送方式，默认不推送。\n   4.2 \n注意：autorun.yml里的时间为UTC时间而不是北京时间 点我转换\n  启用Github Actions\n workflow \n   4.3 \n到这步已经配置完成了，它每天就会自己跑了。\n5.(可选)手动开始跑步\n 如果想手动开始跑步，点击Actions，按照图示步骤操作即可。  5.1   6.关闭自动跑步\n  在仓库Settings-Actions中选择Disable Actions\n 6.1 \n  参考链接  AutoAction AiPao  注意事项 License GPL v3.0\n本文仅供研究，使用者造成的任何后果由使用者自行承担，与作者无关。\n","date":"2021-03-11T10:25:00+08:00","image":"https://luobo.cf/p/pyaipao/87856451_huf58260040af023debd102865c61ea42c_2928959_120x120_fill_q75_box_smart1.jpg","permalink":"https://luobo.cf/p/pyaipao/","title":"PyAipao"},{"content":"看到zsnmwy大佬的博客，和我使用的是同样的主题，但是人家却多了一些动画，瞬间就高级起来了。于是打开百度搜素一波，发现只要改一下CSS就可以实现了。\n准备工具   hugo的扩展版（extended）\n这里一定要下扩展版，因为我使用的主题都是利用scss来生成css的，如果用普通版是无法利用scss生成对应的css的。之前不知道下的是普通版，结果怎么改scss都没有效果，浪费了很多时间😥。\n  相关代码 1.头像转动 在themes/hugo-theme-stack/assets/scss/partials/sidebar.scss中增加以下代码：\n.site-logo { transition: all 1.75s ease-out; } .site-logo:hover { transform: rotate(360deg); } 2.文章头图缩放 在themes/hugo-theme-stack/assets/scss/partials/article.scss中增加以下代码：\n.article-image { overflow:hidden; } .article-image { img { transition:all .5s ease; } \u0026amp;:hover{ transform:scale(1.2); } 3.Archives页面缩放 在themes/hugo-theme-stack/assets/scss/partials/article.scss中增加以下代码：\narticle{ transition:.5s ease; } article { \u0026amp;:hover{ transform:scale(1.05,1.05); background:#f0f8ff; } } 4.菜单缩放 在themes/hugo-theme-stack/assets/scss/partials/menu.scss中增加以下代码：\noverflow-y: visible; //把auto改为visible，为了图标放大溢出时不显示滚动条 li { transition:.5s ease; } li{ \u0026amp;:hover{ transform:scale(1.1,1.1); } } 有了动画后，感觉整个博客都变得高级起来了ヾ(•ω•`)o\n在这感谢zsnmwy大佬，上面有些动画懒得自己写了，就直接从他的css中复制了ヾ(￣▽￣)\n","date":"2021-02-01T13:55:05+08:00","image":"https://luobo.cf/p/%E7%BB%99blog%E5%A2%9E%E5%8A%A0%E5%8A%A8%E7%94%BB/86589864_hu78fbbc6652b920150235079836d94b1b_2463299_120x120_fill_box_smart1_3.png","permalink":"https://luobo.cf/p/%E7%BB%99blog%E5%A2%9E%E5%8A%A0%E5%8A%A8%E7%94%BB/","title":"给Blog增加动画"},{"content":"最近刷了好几道关于STL的竞赛题，许多知识点还是不熟练，在继续学习之前，还是来好好整理一下一些常见的STL和容器吧。紫书上介绍的有以下几种：\n 线性：vector,list,string 关联：map,set 特殊：stack,queue,priority_queue 算法：sort,lower_bound,find  vector vector可以理解为可以自由变换长度的数组(不定长数组)，个人感觉使用频率还是很高的。vector是连续的，意味着可以使用[]或at()。\n声明： vector\u0026lt;int\u0026gt; a\n常用函数   push_back：在尾部添加一个数据\n  pop_back：删除尾部的一个数据\n  size：当前的大小（就是有多少元素）\n  erase：删除指针指向的数据项\n  clear：清空\n  empty：判断是否为空\n  deque deque可以看作是双向队列，是连续存储结构。vector有的功能它都有，还支持高效的首/尾端插入/删除操作。\n新增函数  push_front：在头部添加一个数据 pop_front：在头部删除一个数据  list list可以看作是双链表，是非连续存储结构。可在两端进行push、pop，同时在内部可以很方便的进行插入和删除操作。不过我没怎么用到这个容器。等我做到相关的题目再来补充一些信息吧。\nstring string就是字符串。相比char[]那可是方便不少，c++的cin/cout就只支持string类型而不支持char型数组。string还支持+、=、+=等运算符。\n常用函数   append：在字符串后添加（相当于+=）\n  substr(n,m)：返回string的子串，从n处开始，取m个。当m省略或超过了字符串的长度，则一直取到字符串结束。\n  查找相关函数：\n如果没有查到，返回string::npos。\n  find：从前往后查找子串或字符出现的位置。\n  rfind：从后往前查找子串或字符出现的位置。\n  find_first_of：从前往后查找何处出现另一个字符串中包含的字符。例如：\n  s1.find_first_of(\u0026ldquo;abc\u0026rdquo;); //查找s1中第一次出现\u0026quot;abc\u0026quot;中任一字符的位置\n  find_last_of：从后往前查找何处出现另一个字符串中包含的字符。\n  find_first_not_of：从前往后查找何处出现另一个字符串中没有包含的字符。\n  find_last_not_of：从后往前查找何处出现另一个字符串中没有包含的字符。\n  流处理 可以通过\u0026lt;sstream\u0026gt;，将string对象作为一个流。例如：\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;sstream\u0026gt;#include \u0026lt;string\u0026gt;using namespace std; int main(){ string line; while(getline(cin,line)){ stringstream ss(line); while(ss\u0026gt;\u0026gt;x){...} } } set set就是数学中的集合，每个元素只能出现一次，set中的元素已经从小到大排好了。\n常用函数  insert：插入一个元素 erase：删除，可以传入定位器，也可直接传入值 count：统计元素出现的个数，因为只有0/1个，所以一般用来判断元素是否存在 find：查找  对于自己定义的结构体，需要重载\u0026lt;运算符。\n常用算法 在\u0026lt;algorithm\u0026gt;中提供了关于set的两种算法（目前只知道两种）\n  set_union：取两个集合的并集，例如：\n#define ALL(x) x.begin(),x.end() #define INS(x) inserter(x,x.begin()) set_union(ALL(x1),ALL(x2),INS(x)); //将x1和x2的内容取并集后放入x中   set_intersection：取两个集合的交集，例如：\nset_intersection(ALL(x1),ALL(x2),INS(x)); //将x1和x2的内容取交集放入x中   map map是映射，支持[]运算符，还是非常实用的。\nmap的函数和set基本一致，这里就不重复写了。\nstack stack就是数据结构中的栈，数据是“后进先出”。\n基本函数  push：入栈 pop：出栈 top：取栈顶元素  要注意的是，使用pop()出栈并不会返回被删除的元素值，如果想要需要先top()一下\nqueue queue就是数据结构里的队列，数据符合“先进先出”的规则。\n基本函数   push：入队\n  pop：出队\n  front：取队首\n  priority_queue 优先队列，将按照优先级来排序，取队首的front()的函数将换为top()。该容器也定义在头文件\u0026lt;queue\u0026gt;里。\n对于自定义数据类型的队列，需要定义\u0026lt;运算。对于已经定义过的数据类型，我们可以通过定义一个结构体，在其中重载()运算符来看起来像一个函数，例如：\nstruct cmp { bool operator()(const int a, const int b) const { return abs(a) \u0026lt; abs(b); } }; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, cmp\u0026gt; p_queue; 这样就定义了一个绝对值大小优先的队列\n","date":"2021-01-31T20:39:29+08:00","image":"https://luobo.cf/p/%E7%AB%9E%E8%B5%9B%E7%94%A8stl%E6%95%B4%E7%90%86/85526504_huffc36122ca7f2f624d334d6d5c5a83e7_1825704_120x120_fill_q75_box_smart1.jpg","permalink":"https://luobo.cf/p/%E7%AB%9E%E8%B5%9B%E7%94%A8stl%E6%95%B4%E7%90%86/","title":"竞赛用STL整理"},{"content":"考前整理的算法，也顺便放到博客上吧ヾ(•ω•`)o\n数据结构代码复习 3.单链表逆置 带头结点\nint Inverse_Link(LinkList *L) { LinkList *cur, *p; if (L-\u0026gt;next \u0026amp;\u0026amp; L-\u0026gt;next-\u0026gt;next) { p = L-\u0026gt;next-\u0026gt;next; L-\u0026gt;next-\u0026gt;next = NULL; while (p) { cur = L-\u0026gt;next; L-\u0026gt;next = p; p = p-\u0026gt;next; L-\u0026gt;next-\u0026gt;next = cur; } } return 0; } 5.双向链表 双链表定义：\ntypedef struct DuLinkList { int data; struct DuLinkList *prior; struct DuLinkList *next; } DuLinkList; 遍历：\nvoid Printlist_DuL(DuLinkList *L) { DuLinkList *s; s = L-\u0026gt;next; if (L-\u0026gt;next != NULL) { printf(\u0026#34;当前的双向链表值为：\u0026#34;); do { printf(\u0026#34;%d \u0026#34;, s-\u0026gt;data); s = s-\u0026gt;next; } while (s != NULL); } printf(\u0026#34;\\n\u0026#34;); } 交换：\nint ListSwap_DuL(DuLinkList *L, int i) { //在带头结点的双向链表中交换第i个，i+1个位置的元素  DuLinkList *p = L, *q; int j = 0; while (p \u0026amp;\u0026amp; j \u0026lt; i - 1) { p = p-\u0026gt;next; j += 1; } if (!p || j \u0026gt; i - 1) return -1; p = p-\u0026gt;next; q = p-\u0026gt;next; p-\u0026gt;prior-\u0026gt;next = q; //1 -\u0026gt;q p 2  q-\u0026gt;prior = p-\u0026gt;prior; //1\u0026lt;--\u0026gt;q p 2  p-\u0026gt;next = q-\u0026gt;next; //1\u0026lt;--\u0026gt;q p -\u0026gt;2  q-\u0026gt;next-\u0026gt;prior = p; //1\u0026lt;--\u0026gt;q p\u0026lt;--\u0026gt;2  q-\u0026gt;next = p; //1\u0026lt;--\u0026gt;q -\u0026gt;p\u0026lt;--\u0026gt;2  p-\u0026gt;prior = q; //1\u0026lt;--\u0026gt;q\u0026lt;--\u0026gt;p\u0026lt;--\u0026gt;2  return 0; } 6.链表回文 bool isPalindrome(struct ListNode *head) { Lstack *s; int e; struct ListNode *p = head; s = (Lstack *)malloc(sizeof(Lstack)); Initlist_Stack(s); while (p) { push(s, p-\u0026gt;val); p = p-\u0026gt;next; } p = head; while (p) { e = pop(s); if (p-\u0026gt;val != e) break; p = p-\u0026gt;next; } if (p) return false; else return true; } 7-1.链队列 定义：\ntypedef struct QNode //队列 { int data; struct QNode *next; } QNode; typedef struct LinkQueue //对列相关的指针 { QNode *front; //对头指针  QNode *rear; //队尾指针 } LinkQueue; 插入：\nint EnQueue(LinkQueue *q, int e) { //[入队]将元素e放入队尾，带头结点  QNode *p; p = (QNode *)malloc(sizeof(QNode)); p-\u0026gt;data = e; p-\u0026gt;next = NULL; q-\u0026gt;rear-\u0026gt;next = p; q-\u0026gt;rear = p; return 0; } 7-2.循环链表 插入和普通单链表没区别，这里就列举部分\ns = (LinkList *)malloc(sizeof(LinkList)); s-\u0026gt;data = e; s-\u0026gt;next = p-\u0026gt;next; p-\u0026gt;next = s; 8.求二叉树各种数的算法 （1）求高度 高度很简单，来个递归就完事了\nint BiTreeHeight(BiTNode *T) { //求二叉树的高度  int treeHeight = 0; if (T != NULL) { int leftHeight = BiTreeHeight(T-\u0026gt;lchild); int rightHeight = BiTreeHeight(T-\u0026gt;rchild); treeHeight = leftHeight \u0026gt;= rightHeight ? leftHeight + 1 : rightHeight + 1; } return treeHeight; } （2）求叶子数 叶子数也一样，递归永远滴神\nvoid BiTreeLeafCount(BiTNode *T, int *count) { //求二叉树叶子结点数  if (!T) return; if (T-\u0026gt;lchild == NULL \u0026amp;\u0026amp; T-\u0026gt;rchild == NULL) *count += 1; BiTreeLeafCount(T-\u0026gt;lchild, count); BiTreeLeafCount(T-\u0026gt;rchild, count); } （3）求结点数 这不就遍历嘛，直接看下面吧=￣ω￣=\n9.二叉树的中序遍历 递归：\nint InOrderTraverse(BiTNode *T) { //中序遍历二叉树T的递归算法  if (T == NULL) return 0; InOrderTraverse(T-\u0026gt;lchild); printf(\u0026#34;%c \u0026#34;, T-\u0026gt;data); InOrderTraverse(T-\u0026gt;rchild); } 非递归（重要）：\nint inorder(BiTNode *T) { //中序遍历二叉树T的非递归算法  BiTNode *s[MAXSIZE + 1]; int top = 0; while (T != NULL || top != 0) { while (T != NULL) { s[++top] = T; T = T-\u0026gt;lchild; } if (top != 0) { T = s[top--]; printf(\u0026#34;%c \u0026#34;, T-\u0026gt;data); T = T-\u0026gt;rchild; } } return 0; } 10.二叉排序树 int Search_BST(BSTree t, int key, BSTree f, BSTree *p) { //在指针t所指的二叉排序树上查找key，成功则p指向该元素数据结点并返回0  //否则p指向查找路径上最后一个结点并返回1，f指向T的双亲，初始值为NULL  if (!t) { *p = f; return 1; } else if (key == t-\u0026gt;data) { *p = t; return 0; } else if (key \u0026lt; t-\u0026gt;data) { return Search_BST(t-\u0026gt;lchild, key, t, p); } else return Search_BST(t-\u0026gt;rchild, key, t, p); } int Insert_BST(BSTree *t, int key) { //二叉排序树的插入，当不存在key时插入并返回0，否则返回1  BSTree p, s; p = NULL; if (Search_BST(*t, key, NULL, \u0026amp;p)) { s = (BSTree)malloc(sizeof(BSTNode)); s-\u0026gt;data = key; s-\u0026gt;lchild = s-\u0026gt;rchild = NULL; if (!p) *t = s; else if (key \u0026lt; p-\u0026gt;data) p-\u0026gt;lchild = s; else p-\u0026gt;rchild = s; return 0; } else return 1; } 14.图的遍历 （1）深度优先 入栈时打印结点信息\n递归：\nvoid DFS(ALGraph *G, int v, int visited[]) { ArcNode *p; int w, i; visited[v] = 1; printf(\u0026#34;%d \u0026#34;, v); p = G-\u0026gt;vertices[v].firstarc; while (p != NULL) { w = p-\u0026gt;adjvex; if (visited[w] == 0) DFS(G, w, visited); p = p-\u0026gt;nextarc; } } 非递归：\nvoid DFS1(ALGraph *G, int v) { ArcNode *p; int w, i; int visited[MAX_VERTEX_NUM]; ArcNode *s[MAX_VERTEX_NUM]; //顺序栈  int top = 0; for (i = 1; i \u0026lt;= G-\u0026gt;vexnum; i++) visited[i] = 0; //访问标志数组初始化  visited[v] = 1; printf(\u0026#34;%2d\u0026#34;, v); p = G-\u0026gt;vertices[v].firstarc; while (p != NULL || top != 0) { while (p != NULL) { w = p-\u0026gt;adjvex; if (visited[w] == 0) { printf(\u0026#34;%2d\u0026#34;, w); visited[w] = 1; s[++top] = p; p = G-\u0026gt;vertices[w].firstarc; } else p = p-\u0026gt;nextarc; } if (top != 0) { p = s[top--]; p = p-\u0026gt;nextarc; } } } （2）广度优先 出队列时打印结点信息\nvoid BFS(ALGraph *G, int v) { ArcNode *p; int w, i; int queue[MAX_VERTEX_NUM], front = 0, rear = 0; // 定义循环队列  int visited[MAX_VERTEX_NUM]; for (i = 1; i \u0026lt;= G-\u0026gt;vexnum; i++) visited[i] = 0; //访问标志数组初始化  printf(\u0026#34;%2d\u0026#34;, v); //输出被访问顶点的编号  visited[v] = 1; //置已访问标记  rear = (rear + 1) % MAX_VERTEX_NUM; queue[rear] = v; //v进队  while (front != rear) // 队列不空时循环  { front = (front + 1) % MAX_VERTEX_NUM; w = queue[front]; //出队并赋给w  p = G-\u0026gt;vertices[w].firstarc; //找w的第一个的邻接点  while (p != NULL) { if (visited[p-\u0026gt;adjvex] == 0) { printf(\u0026#34;%2d\u0026#34;, p-\u0026gt;adjvex); //访问之  visited[p-\u0026gt;adjvex] = 1; rear = (rear + 1) % MAX_VERTEX_NUM; //相邻顶点进队  queue[rear] = p-\u0026gt;adjvex; } p = p-\u0026gt;nextarc; //找下一个邻接顶点  } } } 15.双向冒泡 void BubbleSort1(int R[], int n) { //双向冒泡  int i, j, lastExchange, lastExchange1, i1, temp; i = n; //i 指示无序序列中最后一个记录的位置  i1 = 1; while (i \u0026gt; i1) { lastExchange = 1; //记录正序最后一次交换发生的位置  lastExchange1 = n; //记录逆序最后一次交换发生的位置  for (j = i1; j \u0026lt; i; j++) if (R[j] \u0026gt; R[j + 1]) { temp = R[j]; R[j] = R[j + 1]; R[j + 1] = temp; //逆序时交换  lastExchange = j; } for (j = lastExchange; j \u0026gt; i1; j--) if (R[j] \u0026lt; R[j - 1]) { temp = R[j]; R[j] = R[j - 1]; R[j - 1] = temp; //逆序时交换  lastExchange1 = j; } i = lastExchange; i1 = lastExchange1; } } ","date":"2021-01-10T15:06:20+08:00","image":"https://luobo.cf/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/83667969_hu38d2b1a912e76eab4c1b90daa958e1cd_1812230_120x120_fill_box_smart1_3.png","permalink":"https://luobo.cf/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/","title":"数据结构算法复习"},{"content":"生成随机数 在C语言中，生成随机数可以使用stdlib.h头文件里的rand()来生成，例如：\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;int main(){ int a = rand(); printf(\u0026#34;%d\\n\u0026#34;,a); return 0; } rand() 会随机生成一个位于 0 ~ RAND_MAX 之间的整数。\n但是这样生成的随机数每次开启程序都是一样的，则需要使用srand()来重新播种，一般常与\u0026lt;time.h\u0026gt;里的time()函数一起使用。\nsrand((unsigned)time(NULL)); 连续生成多个随机数 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;time.h\u0026gt;int main() { int a, i; srand((unsigned)time(NULL)); //使用for循环生成10个随机数  for (i = 0; i \u0026lt; 10; i++) { a = rand(); printf(\u0026#34;%d \u0026#34;, a); } return 0; } 生成指定范围的随机数 想要生成指定范围的随机数，只要进行%运算就好了\nint a = rand() % 10; //产生0~9的随机数 int a = rand() % 10 + 1; //产生1~10的随机数 连续生成不重复的随机数 这就是本文的重点了ヾ(•ω•`)o （其实就是为了记下这个算法才水了一篇文章）\nint *GetRandom(int m) { //根据给定的m生成随机不重复的数组a  int i, n, w, t; int *a; n = 2 * m; srand((unsigned int)time(0)); a = (int *)malloc(n * sizeof(int)); for (i = 0; i \u0026lt; n; i++) a[i] = i + 1; for (i = 1; i \u0026lt;= m; i++) { w = rand() % (n - i) + i; t = a[i]; a[i] = a[w]; a[w] = t; } return a; } ","date":"2020-12-22T19:36:53+08:00","image":"https://luobo.cf/p/c%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/84444030_hu7ef2fd02297b262112d9bbc23507151d_2022394_120x120_fill_box_smart1_3.png","permalink":"https://luobo.cf/p/c%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/","title":"C语言生成随机数"},{"content":"基本操作 建立版本库：git init\n查看结果：git status\n查看不同：git diff\n版本回退 查看提交日记：git log\n回退：git reset --hard HEAD^\nHEAD^表示上一个版本，HEAD^^表示前两个版本，HEAD~100表示前100个版本\n恢复：git reflog查看命令历史，确定回到未来的哪个版本\n撤销修改  直接丢弃工作区的修改时，用命令git checkout -- file 已经添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD \u0026lt;file\u0026gt;，第二步按1操作。  上传 git remote add origin 仓库链接 #将远程仓库和本地仓库绑定 git add . git commit -m \u0026quot;提交信息\u0026quot; git push -u origin 自己当前的分支名 #-u将本地库和远程库的分支关联，之后可以不加 下载 git clone 仓库链接 git clone到当前文件夹\ngit clone 仓库链接 . 分支管理 创建与合并分支 查看分支：git branch\n创建分支：git branch \u0026lt;name\u0026gt;\n切换分支：git checkout \u0026lt;name\u0026gt;或者git switch \u0026lt;name\u0026gt;\n创建+切换分支：git checkout -b \u0026lt;name\u0026gt;或者git switch -c \u0026lt;name\u0026gt;\n删除分支：git branch -d \u0026lt;name\u0026gt;\n合并某分支到当前分支：git merge \u0026lt;name\u0026gt;\n 当Git无法自动合并分支时，就必须首先解决冲突，自己手动修改冲突文件再合并即可。 查看分支合并图：git log --graph 使用非快速模式合并，有commit：git merge --no-ff -m \u0026quot;merge with no-ff\u0026quot; dev  Bug分支 需要紧急处理Bug时，可以使用git stash将现在的工作区暂存\n恢复原来的工作区\n 恢复但不删除stash内容：git stash apply 手动删除stash内容：git stash drop 恢复且删除stash内容：git stash pop  可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，如：\ngit stash apply stash@{0} 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick \u0026lt;commit\u0026gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。\n多人协作   查看远程库信息，使用git remote -v\n  从本地推送分支，使用git push origin branch-name\n  如果冲突，先git pull抓取远程的新提交，处理好后再push\n  在本地创建和远程分支对应的分支：git checkout -b branch-name origin/branch-name\n  建立本地分支和远程分支的关联：git branch --set-upstream branch-name origin/branch-name\n  将非直线的提交日记变为直线：git rebase\n  标签管理 创建标签   新建一个标签：git tag \u0026lt;name\u0026gt;,默认为HEAD，也可以指定一个commit id\n  指定标签信息：git tag -a \u0026lt;tagname\u0026gt; -m \u0026quot;blablabla...\u0026quot;\n  查看所有标签：git tag\n  标签管理  推送一个本地标签：git push origin \u0026lt;tagname\u0026gt; 推送全部未推送过的本地标签：git push origin --tags 删除一个本地标签：git tag -d \u0026lt;tagname\u0026gt; 删除一个远程标签：git push origin :refs/tags/\u0026lt;tagname\u0026gt;  ","date":"2020-12-16T13:16:45+08:00","image":"https://luobo.cf/p/git/79008828_hu0acf08fa0a8e929040b98749b2927875_1528743_120x120_fill_q75_box_smart1.jpg","permalink":"https://luobo.cf/p/git/","title":"Git的常用命令"},{"content":"主题相关 FrontMatter 字段含义\ntitle: 标题 description: 描述 image: 显示的特色图片 comments: 显示 / 隐藏评论区(T/F) license: 文章协议 输入 false 可以隐藏 hidden: 隐藏文章（不在首页，归档等页面显示，但是可以直接通过链接访问） math: 是否加载 KaTeX 脚本 slug: 固定链接 draft: 是否为草稿 categories: 分类 tags: 标签 lastmod: 上次更新时间 MarkDown相关 # 我是一级标题 ## 我是二级标题 可对应1-6级标题 *斜体文本* **粗体文本** ***粗斜体文本*** 一行中用三个以上的星号*、减号-、底线_来建立一个分隔线 ~~删除线~~ \u0026lt;u\u0026gt;带下划线文本\u0026lt;/u\u0026gt; 创建脚注格式类似这样 [^JiaoZhu]。 [^JiaoZhu]: 脚注的内容 列表：*、+、-、1. \u0026gt; 区块 [链接文本](网址) 图片在前加! | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 ","date":"2020-12-15T18:02:14+08:00","image":"https://luobo.cf/p/blog%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/80228475_hueadf3bffe35dbd99d1cbacd445bc351e_1641954_120x120_fill_q75_box_smart1.jpg","permalink":"https://luobo.cf/p/blog%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/","title":"Blog常用的命令"}]