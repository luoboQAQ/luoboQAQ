[{"content":"在我现在在做的项目中需要进行身份和权限认证，在网上找了些教程，推荐都是使用JWT来进行身份认证，于是便决定使用此方法来实现。（然而用完了才发现JWT也有缺点）\n何为JWT 所谓JWT，全称是JSON Web Token。下面是从官网摘抄的定义：\n JWT是一个开放的标准（RFC 7519），它定义了一种紧凑和独立的方式，以JSON对象的形式在各方之间安全地传输信息。这种信息可以被验证和信任，因为它是经过数字签名的。JWTs可以使用秘密（使用HMAC算法）或使用RSA或ECDSA的公共/私人密钥对进行签名。\n 按我的理解，JWT其实就是将传统的session认证中的token存储位置从服务器上下发给用户，服务器只需要判断传来的token是否合法而无需存储。这样做的好处就是可以做分布式的服务器，无需考虑用户是在哪一台服务器上登录的。\n详细的定义和构成我这里就不展开了，这里主要关注JWT中Payload（载荷）。这是有效信息存放的地方，我们一般关注这里就行了。\n下面是官方提供且建议（并不强制）使用的声明：\n  iss: jwt签发者\n  sub: 主题\n  aud: 接收jwt的一方\n  exp: jwt的过期时间，这个过期时间必须要大于签发时间\n  nbf: 生效时间，在此时间之前该jwt都是不可用的.\n  iat: jwt的签发时间\n  jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。\n  当然，在载荷中还可以存放自定义的信息，在本项目中使用官方提供的就足以了，故不展开。\n认证流程  用户使用用户名密码来请求服务器 服务器进行验证用户的信息 服务器通过验证发送给用户一个token 客户端存储token，并在每次请求时附送上这个token值 服务端验证token值，并返回数据  具体实现 导入依赖包 第一步当然是导入相关依赖了，使用Maven进行包管理。\n\u0026lt;!-- shiro --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shiro\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shiro-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.8.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- jwt --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.auth0\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;java-jwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.18.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 封装JWT工具类 这里主要实现JWT的生成、验证、提取用户名三个功能\n@Slf4j public class JwtUtil { /** * 服务器私钥 */ private static final Algorithm ALGORITHM = Algorithm.HMAC256(\u0026#34;test\u0026#34;); /** * 生成JSON Web Token * * @param username 用户名 * @param issuer 签发者 * @param subject 面向主体 * @param ttlMillis 生效时长(单位:毫秒) */ public static String creatJwt(String username, String issuer, String subject, long ttlMillis) { long nowMillis = System.currentTimeMillis(); Date now = new Date(nowMillis); JWTCreator.Builder builder = JWT.create() .withAudience(username) .withIssuedAt(now) .withSubject(subject) .withIssuer(issuer); if (ttlMillis \u0026gt;= 0) { long expMillis = nowMillis + ttlMillis; Date exp = new Date(expMillis); builder.withExpiresAt(exp); } return builder.sign(ALGORITHM); } /** * 获取签发对象 * * @param token 需要解密的token * @return 解密后获得的对象，失败返回null */ public static String getAudience(String token) { String audience; try { audience = JWT.decode(token).getAudience().get(0); } catch (JWTDecodeException exception) { log.error(\u0026#34;输入的token无法解析\u0026#34;); return null; } return audience; } /** * 验证token是否正确 * * @param token 需要验证的token * @return 是否通过验证 */ public static Boolean verifyToken(String token) { try { JWTVerifier verifier = JWT.require(ALGORITHM).build(); verifier.verify(token); } catch (JWTVerificationException e) { return false; } return true; } } 配置Shiro 这里的ShiroConfig.java与一般Shiro项目的配置有以下几点不同：\n 禁用Session 使用自定义的jwtFilter过滤器，用来拦截并处理携带JWT token的请求 使用自定义的Realm认证器，用于验证用户是否存在及查询用户权限  @Configuration public class ShiroConfig { @Autowired private MyRealm myRealm; @Bean public DefaultWebSecurityManager getDefaultWebSecurityManager() { DefaultWebSecurityManager manger = new DefaultWebSecurityManager(); manger.setRealm(myRealm); // 关闭shiro自带的session  DefaultSubjectDAO subjectDAO = new DefaultSubjectDAO(); subjectDAO.setSessionStorageEvaluator(sessionStorageEvaluator()); manger.setSubjectDAO(subjectDAO); return manger; } @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager manger) { ShiroFilterFactoryBean bean = new CustomShiroFilterFactoryBean(); bean.setSecurityManager(manger); Map\u0026lt;String, Filter\u0026gt; filterMap = new HashMap\u0026lt;\u0026gt;(); filterMap.put(\u0026#34;jwt\u0026#34;, getJwtFilter()); bean.setFilters(filterMap); Map\u0026lt;String, String\u0026gt; map = new LinkedHashMap\u0026lt;\u0026gt;(); //设置过滤规则，anon表示无需认证，其余的请求都通过自定义的jwt认证器  map.put(\u0026#34;/\u0026#34;, \u0026#34;anon\u0026#34;); map.put(\u0026#34;/swagger-ui/**\u0026#34;, \u0026#34;anon\u0026#34;); map.put(\u0026#34;/v3/api-docs\u0026#34;, \u0026#34;anon\u0026#34;); map.put(\u0026#34;/swagger-resources/**\u0026#34;, \u0026#34;anon\u0026#34;); map.put(\u0026#34;/unauthorized/**\u0026#34;, \u0026#34;anon\u0026#34;); map.put(\u0026#34;/**\u0026#34;, \u0026#34;jwt\u0026#34;); bean.setFilterChainDefinitionMap(map); bean.setLoginUrl(\u0026#34;/login\u0026#34;); // 设置无权限时跳转的 url  bean.setUnauthorizedUrl(\u0026#34;/unauthorized/无权限\u0026#34;); return bean; } public JwtFilter getJwtFilter() { return new JwtFilter(); } /** * 开启注解代理 */ @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) { AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager); return authorizationAttributeSourceAdvisor; } /** * 禁用session, 不保存用户登录状态。保证每次请求都重新认证 */ @Bean protected SessionStorageEvaluator sessionStorageEvaluator() { DefaultSessionStorageEvaluator sessionStorageEvaluator = new DefaultSessionStorageEvaluator(); sessionStorageEvaluator.setSessionStorageEnabled(false); return sessionStorageEvaluator; } } 自定义Token 由于使用了JWT当token，自然要写自定义的Token\npublic class JwtToken implements AuthenticationToken { private String token; public JwtToken(String token) { this.token = token; } @Override public Object getPrincipal() { return token; } @Override public Object getCredentials() { return token; } } 自定义过滤器 由于使用了JWT，所以不能使用shiro中自带的过滤器，而是自定义自己的过滤器 JWTFilter，JWTFilter 继承了 BasicHttpAuthenticationFilter，并部分原方法进行了重写\n@Slf4j public class JwtFilter extends BasicHttpAuthenticationFilter { @Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) { //判断请求的请求头是否带上 \u0026#34;Token\u0026#34;  if (isLoginAttempt(request, response)) { //如果存在，则进入 executeLogin 方法执行登入，检查 token 是否正确  try { executeLogin(request, response); return true; } catch (Exception e) { //token 错误  responseError(response, e.getMessage()); } } //如果请求头不存在 Token，则可能是执行登陆操作或者是游客状态访问，无需检查 token，直接返回 true  return true; } /** * 判断用户是否想要登入。 * 检测 header 里面是否包含 Token 字段 */ @Override protected boolean isLoginAttempt(ServletRequest request, ServletResponse response) { HttpServletRequest req = (HttpServletRequest) request; String token = req.getHeader(\u0026#34;Token\u0026#34;); return token != null; } @Override protected boolean executeLogin(ServletRequest request, ServletResponse response) throws Exception { HttpServletRequest httpServletRequest = (HttpServletRequest) request; String token = httpServletRequest.getHeader(\u0026#34;Token\u0026#34;); JwtToken jwtToken = new JwtToken(token); // 提交给realm进行登入，如果错误他会抛出异常并被捕获  getSubject(request, response).login(jwtToken); // 如果没有抛出异常则代表登入成功，返回true  return true; } /** * 将非法请求跳转到 /unauthorized/** */ private void responseError(ServletResponse response, String message) { try { HttpServletResponse httpServletResponse = (HttpServletResponse) response; //设置编码，否则中文字符在重定向时会变为空字符串  message = URLEncoder.encode(message, \u0026#34;UTF-8\u0026#34;); httpServletResponse.sendRedirect(\u0026#34;/unauthorized/\u0026#34; + message); } catch (IOException e) { log.error(e.getMessage()); } } } 该过滤器有这几大步骤：\n 检验请求头是否带有Token 如果带有 token，执行 shiro 的 login() 方法，将 token 提交到 Realm 中进行检验；如果没有 token，说明当前状态为游客状态（或者其他一些不需要进行认证的接口） 如果在 token 校验的过程中出现错误，如 token 校验失败，那么我会将该请求视为认证不通过，则重定向到 /unauthorized/**  自定义Realm 这里主要是进行身份认证和权限认证\n@Component public class MyRealm extends AuthorizingRealm { @Autowired UserService userService; @Autowired RoleService roleService; @Autowired PermissionService permissionService; @Override public boolean supports(AuthenticationToken token) { return token instanceof JwtToken; } /** * 权限认证 * 只有当需要检测用户权限的时候才会调用此方法，例如checkRole,checkPermission之类的 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { String userName = (String) principals.iterator().next(); Set\u0026lt;String\u0026gt; roles = roleService.getAllRoleByUserName(userName); Set\u0026lt;String\u0026gt; permissions = permissionService.getAllPermissionByUserName(userName); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); info.setRoles(roles); info.setStringPermissions(permissions); return info; } /** * 身份认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { JwtToken jwtToken = (JwtToken) token; String jwtTokenPrincipal = (String) jwtToken.getPrincipal(); String userName = JwtUtil.getAudience(jwtTokenPrincipal); if (userName == null || JwtUtil.verifyToken(jwtTokenPrincipal)) { throw new AuthenticationException(\u0026#34;token认证失败！\u0026#34;); } User user = userService.getUserByUserName(userName); if (user == null) { throw new AuthenticationException(\u0026#34;该用户不存在！\u0026#34;); } return new SimpleAuthenticationInfo(userName, jwtTokenPrincipal, user.getRealName()); } } 异常处理 第一个是专门处理身份认证时的异常\n@ApiOperation(value = \u0026#34;接收未授权错误\u0026#34;, notes = \u0026#34;返回错误信息\u0026#34;) @GetMapping(\u0026#34;/unauthorized/{message}\u0026#34;) public Result unauthorized(@PathVariable String message) { return new Result().setCode(233).setMessage(message); } 第二个则是全局接管Shiro的异常，在其中进行处理\n@RestControllerAdvice public class ExceptionController { /** * 捕捉shiro的异常 */ @ExceptionHandler(ShiroException.class) public Result handle401(ShiroException e) { Result result = new Result(); result.setCode(666); if(e instanceof UnauthenticatedException){ result.setMessage(\u0026#34;您没有登录！\u0026#34;); }else if(e instanceof UnauthorizedException){ result.setMessage(\u0026#34;您没有权限访问！\u0026#34;); } else { result.setMessage(e.toString()); } return result; } } 开始使用   身份认证在Controller上添加@RequiresRoles(\u0026quot;xxx\u0026quot;)\n  权限认证在Controller上添加@RequiresPermissions(\u0026quot;xxx\u0026quot;)\n  测试  游客访问，不带Token \n 不带token访问 \n 带上token \n 带上错误的token \n 访问无权限的接口 \n参考文章  教你 Shiro + SpringBoot 整合 JWT Shiro步步为营\u0026ndash;如何优雅地与JWT集成  ","date":"2021-10-08T15:19:44+08:00","image":"https://lbqaq.top/p/shiro%E6%95%B4%E5%90%88jwt/92388693.webp","permalink":"https://lbqaq.top/p/shiro%E6%95%B4%E5%90%88jwt/","title":"shiro整合JWT"},{"content":"最近看了很久的Vue教程，为了避免之后的遗忘，还是停下脚步，花点时间讲笔记写出来吧。\n这篇笔记是基于B站上的尚硅谷Vue2.0+Vue3.0全套教程而成，在此感谢提供这么优秀的学习教程。\nVue2基础 想要学好Vue，那肯定还是从Vue2开始学起。那么这一章主要是Vue2中的基础内容，没有使用到脚手架。\n初识Vue 每学一个新的语言，HelloWord是必不可少的。话不多说，上代码：\n\u0026lt;!-- 准备好一个容器 --\u0026gt; \u0026lt;div id=\u0026#34;demo\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Hello，{{name.toUpperCase()}}，{{address}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; \u0026gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。  //创建Vue实例  new Vue({ el:\u0026#39;#demo\u0026#39;, //el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。  data:{ //data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象。  name:\u0026#39;vue\u0026#39;, address:\u0026#39;北京\u0026#39; } }) \u0026lt;/script\u0026gt; 这样就完成了一个基础的Vue程序。\n1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；\n2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；\n3.root容器里的代码被称为【Vue模板】；\n4.Vue实例和容器是一一对应的；\n5.真实开发中只有一个Vue实例，并且会配合着组件一起使用；\n6.{{xxx}}中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；\n7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；\nVue模板语法 Vue模板语法有2大类：\n1.插值语法：\n​ 功能：用于解析标签体内容。\n​ 写法：{{xxx}}，xxx是js表达式，且可以直接读取到data中的所有属性。\n2.指令语法：\n​ 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件\u0026hellip;..）。\n​ 举例：v-bind:href=\u0026ldquo;xxx\u0026rdquo; 或 简写为 :href=\u0026ldquo;xxx\u0026rdquo;，xxx同样要写js表达式，\n​ 且可以直接读取到data中的所有属性。\n​ 备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。\n其实很好理解，想要显示在页面上的内容就使用{{value}}这样的写法，而v-bind:则是用于html标签中的属性绑定。\n数据绑定 Vue中有2种数据绑定的方式：\n​ 1.单向绑定(v-bind)：数据只能从data流向页面。\n​ 2.双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。\n​ 备注：\n​ 1.双向绑定一般都应用在表单类元素上（如：input、select等）\n​ 2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。\n\u0026lt;!-- 普通写法 --\u0026gt; 单向数据绑定：\u0026lt;input type=\u0026#34;text\u0026#34; v-bind:value=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;br/\u0026gt; 双向数据绑定：\u0026lt;input type=\u0026#34;text\u0026#34; v-model:value=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;!-- 简写 --\u0026gt; 单向数据绑定：\u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;br/\u0026gt; 双向数据绑定：\u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;br/\u0026gt; el与data的两种写法 data与el的2种写法\n​ 1.el有2种写法\n​ (1).new Vue时候配置el属性。\n​ (2).先创建Vue实例，随后再通过vm.$mount('#root')指定el的值。\nconst v = new Vue({ //el:\u0026#39;#root\u0026#39;, //第一种写法  data:{ name:\u0026#39;Vue\u0026#39; } }) v.$mount(\u0026#39;#root\u0026#39;) //第二种写法 ​ 2.data有2种写法\n​ (1).对象式\n​ (2).函数式\n​ 如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。\nnew Vue({ el:\u0026#39;#root\u0026#39;, //data的第一种写法：对象式  /* data:{ name:\u0026#39;Vue\u0026#39; } */ //data的第二种写法：函数式  data(){ console.log(\u0026#39;@@@\u0026#39;,this) //此处的this是Vue实例对象  return{ name:\u0026#39;Vue\u0026#39; } } }) ​ 3.一个重要的原则：\n​ 由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。\n数据代理 在讲Vue中的数据代理之前，先讲一下js中Object.defineproperty方法\nlet number = 18 let person = { name:\u0026#39;张三\u0026#39;, sex:\u0026#39;男\u0026#39;, } Object.defineProperty(person,\u0026#39;age\u0026#39;,{ // value:18,  // enumerable:true, //控制属性是否可以枚举，默认值是false  // writable:true, //控制属性是否可以被修改，默认值是false  // configurable:true //控制属性是否可以被删除，默认值是false  //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值  get(){ console.log(\u0026#39;有人读取age属性了\u0026#39;) return number }, //当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值  set(value){ console.log(\u0026#39;有人修改了age属性，且值是\u0026#39;,value) number = value } }) // 输出person中所有的key // console.log(Object.keys(person))  console.log(person) 通过Object.defineProperty添加进的属性，默认是不可枚举、不可修改、不可删除的，可以通过上面的三条配置项，让其和普通的属性一样。\n所谓数据代理，就是指通过一个对象代理对另一个对象中属性的操作（读/写）。\n1.Vue中的数据代理：\n​ 通过vm对象来代理data对象中属性的操作（读/写）\n2.Vue中数据代理的好处：\n​ 更加方便的操作data中的数据\n3.基本原理：\n​ 通过Object.defineProperty()把data对象中所有属性添加到vm上。\n​ 为每一个添加到vm上的属性，都指定一个getter/setter。\n​ 在getter/setter内部去操作（读/写）data中对应的属性。\nconst vm = new Vue({ el:\u0026#39;#root\u0026#39;, data:{ name:\u0026#39;Vue\u0026#39;, password:123 } }) 通过在控制台查看vm，可以发现data中的数据都通过数据代理在vm身上了\n事件处理 事件的基本使用：\n​ 1.使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；\n​ 2.事件的回调需要配置在methods对象中，最终会在vm上；\n​ 3.methods中配置的函数，不要用箭头函数！否则this就不是vm了；\n​ 4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；\n​ 5.@click=\u0026ldquo;demo\u0026rdquo; 和 @click=\u0026ldquo;demo($event)\u0026rdquo; 效果一致，但后者可以传参；\n\u0026lt;!-- 准备好一个容器--\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Hello,{{name}}\u0026lt;/h2\u0026gt; \u0026lt;!-- \u0026lt;button v-on:click=\u0026#34;showInfo\u0026#34;\u0026gt;点我提示信息\u0026lt;/button\u0026gt; --\u0026gt; \u0026lt;button @click=\u0026#34;showInfo1\u0026#34;\u0026gt;点我提示信息1（不传参）\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;showInfo2($event,66)\u0026#34;\u0026gt;点我提示信息2（传参）\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; const vm = new Vue({ el:\u0026#39;#root\u0026#39;, data:{ name:\u0026#39;Vue\u0026#39;, }, methods:{ showInfo1(event){ // console.log(event.target.innerText)  // console.log(this) //此处的this是vm  alert(\u0026#39;同学你好！\u0026#39;) }, showInfo2(event,number){ console.log(event,number) // console.log(event.target.innerText)  // console.log(this) //此处的this是vm  alert(\u0026#39;同学你好！！\u0026#39;) } } }) \u0026lt;/script\u0026gt; Vue中的事件修饰符：\n​ 1.prevent：阻止默认事件（常用）；\n​ 2.stop：阻止事件冒泡（常用）；\n​ 3.once：事件只触发一次（常用）；\n​ 4.capture：使用事件的捕获模式；\n​ 5.self：只有event.target是当前操作的元素时才触发事件；\n​ 6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；\n\u0026lt;!-- 阻止默认事件（常用） --\u0026gt; \u0026lt;a href=\u0026#34;http://www.baidu.com\u0026#34; @click.prevent=\u0026#34;showInfo\u0026#34;\u0026gt;点我提示信息\u0026lt;/a\u0026gt; \u0026lt;!-- 阻止事件冒泡（常用） --\u0026gt; \u0026lt;div class=\u0026#34;demo1\u0026#34; @click=\u0026#34;showInfo\u0026#34;\u0026gt; \u0026lt;button @click.stop=\u0026#34;showInfo\u0026#34;\u0026gt;点我提示信息\u0026lt;/button\u0026gt; \u0026lt;!-- 修饰符可以连续写 --\u0026gt; \u0026lt;!-- \u0026lt;a href=\u0026#34;http://www.baidu.com\u0026#34; @click.prevent.stop=\u0026#34;showInfo\u0026#34;\u0026gt;点我提示信息\u0026lt;/a\u0026gt; --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 事件只触发一次（常用） --\u0026gt; \u0026lt;button @click.once=\u0026#34;showInfo\u0026#34;\u0026gt;点我提示信息\u0026lt;/button\u0026gt; 1.Vue中常用的按键别名：\n​ 回车 =\u0026gt; enter\n​ 删除 =\u0026gt; delete (捕获“删除”和“退格”键)\n​ 退出 =\u0026gt; esc\n​ 空格 =\u0026gt; space\n​ 换行 =\u0026gt; tab (特殊，必须配合keydown去使用)\n​ 上 =\u0026gt; up\n​ 下 =\u0026gt; down\n​ 左 =\u0026gt; left\n​ 右 =\u0026gt; right\n2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）\n3.系统修饰键（用法特殊）：ctrl、alt、shift、meta\n​ (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。\n​ (2).配合keydown使用：正常触发事件。\n4.也可以使用keyCode去指定具体的按键（不推荐）\n5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名\n一般都是@keydown.xxx或者@keyup.xxx来绑定按键\n计算属性 计算属性：\n​ 1.定义：要用的属性不存在，要通过已有属性计算得来。\n​ 2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。\n​ 3.get函数什么时候执行？\n​ (1).初次读取时会执行一次。\n​ (2).当依赖的数据发生改变时会被再次调用。\n​ 4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。\n​ 5.备注：\n​ 1.计算属性最终会出现在vm上，直接读取使用即可。\n​ 2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。\nconst vm = new Vue({ el:\u0026#39;#root\u0026#39;, data:{ firstName:\u0026#39;张\u0026#39;, lastName:\u0026#39;三\u0026#39;, x:\u0026#39;你好\u0026#39; }, computed:{ fullName:{ //get有什么作用？当有人读取fullName时，get就会被调用，且返回值就作为fullName的值  //get什么时候调用？1.初次读取fullName时。2.所依赖的数据发生变化时。  get(){ console.log(\u0026#39;get被调用了\u0026#39;) // console.log(this) //此处的this是vm  return this.firstName + \u0026#39;-\u0026#39; + this.lastName }, //set什么时候调用? 当fullName被修改时。  set(value){ console.log(\u0026#39;set\u0026#39;,value) const arr = value.split(\u0026#39;-\u0026#39;) this.firstName = arr[0] this.lastName = arr[1] } } } }) 计算属性调用就和普通属性的调用一样，用{{key}}就行了。\n当我们不需要计算属性的set方法时，我们就可以使用简写方法：\nconst vm = new Vue({ el:\u0026#39;#root\u0026#39;, data:{ firstName:\u0026#39;张\u0026#39;, lastName:\u0026#39;三\u0026#39;, }, computed:{ //简写  fullName(){ console.log(\u0026#39;get被调用了\u0026#39;) return this.firstName + \u0026#39;-\u0026#39; + this.lastName } } }) 监视属性 监视属性watch：\n1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作\n2.监视的属性必须存在，才能进行监视！！\n3.监视的两种写法：\n​ (1).new Vue时传入watch配置\n​ (2).通过vm.$watch监视\n\u0026lt;!-- 准备好一个容器--\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;今天天气很{{info}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeWeather\u0026#34;\u0026gt;切换天气\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; const vm = new Vue({ el:\u0026#39;#root\u0026#39;, data:{ isHot:true, }, computed:{ info(){ return this.isHot ? \u0026#39;炎热\u0026#39; : \u0026#39;凉爽\u0026#39; } }, methods: { changeWeather(){ this.isHot = !this.isHot } }, /* watch:{ isHot:{ immediate:true, //初始化时让handler调用一下 //handler什么时候调用？当isHot发生改变时。 handler(newValue,oldValue){ console.log(\u0026#39;isHot被修改了\u0026#39;,newValue,oldValue) } } } */ }) vm.$watch(\u0026#39;isHot\u0026#39;,{ immediate:true, //初始化时让handler调用一下  //handler什么时候调用？当isHot发生改变时。  handler(newValue,oldValue){ console.log(\u0026#39;isHot被修改了\u0026#39;,newValue,oldValue) } }) \u0026lt;/script\u0026gt; 深度监视：\n​ (1).Vue中的watch默认不监测对象内部值的改变（一层）。\n​ (2).配置deep:true可以监测对象内部值改变（多层）。\n备注：\n​ (1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！\n​ (2).使用watch时根据数据的具体结构，决定是否采用深度监视。\n计算属性也同样可以简写：\nwatch:{ //简写  isHot(newValue,oldValue){ console.log(\u0026#39;isHot被修改了\u0026#39;,newValue,oldValue,this) } } computed和watch之间的区别：\n​ 1.computed能完成的功能，watch都可以完成。\n​ 2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。\n两个重要的小原则：\n​ 1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。\n​ 2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，\n​ 这样this的指向才是vm 或 组件实例对象。\n绑定样式 绑定样式：\n  class样式\n写法:class=\u0026ldquo;xxx\u0026rdquo; xxx可以是字符串、对象、数组。\n字符串写法适用于：类名不确定，要动态获取。\n对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。\n数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。\n  style样式\n:style=\u0026quot;{fontSize: xxx}\u0026ldquo;其中xxx是动态值。\n:style=\u0026quot;[a,b]\u0026ldquo;其中a、b是样式对象。\n  \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --\u0026gt; \u0026lt;div class=\u0026#34;basic\u0026#34; :class=\u0026#34;mood\u0026#34; @click=\u0026#34;changeMood\u0026#34;\u0026gt;{{name}}\u0026lt;/div\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 --\u0026gt; \u0026lt;div class=\u0026#34;basic\u0026#34; :class=\u0026#34;classArr\u0026#34;\u0026gt;{{name}}\u0026lt;/div\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --\u0026gt; \u0026lt;div class=\u0026#34;basic\u0026#34; :class=\u0026#34;classObj\u0026#34;\u0026gt;{{name}}\u0026lt;/div\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;!-- 绑定style样式--对象写法 --\u0026gt; \u0026lt;div class=\u0026#34;basic\u0026#34; :style=\u0026#34;styleObj\u0026#34;\u0026gt;{{name}}\u0026lt;/div\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;!-- 绑定style样式--数组写法 --\u0026gt; \u0026lt;div class=\u0026#34;basic\u0026#34; :style=\u0026#34;styleArr\u0026#34;\u0026gt;{{name}}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; Vue.config.productionTip = false const vm = new Vue({ el:\u0026#39;#root\u0026#39;, data:{ name:\u0026#39;尚硅谷\u0026#39;, mood:\u0026#39;normal\u0026#39;, classArr:[\u0026#39;atguigu1\u0026#39;,\u0026#39;atguigu2\u0026#39;,\u0026#39;atguigu3\u0026#39;], classObj:{ atguigu1:false, atguigu2:false, }, styleObj:{ fontSize: \u0026#39;40px\u0026#39;, color:\u0026#39;red\u0026#39;, }, styleObj2:{ backgroundColor:\u0026#39;orange\u0026#39; }, styleArr:[ { fontSize: \u0026#39;40px\u0026#39;, color:\u0026#39;blue\u0026#39;, }, { backgroundColor:\u0026#39;gray\u0026#39; } ] }, methods: { changeMood(){ const arr = [\u0026#39;happy\u0026#39;,\u0026#39;sad\u0026#39;,\u0026#39;normal\u0026#39;] const index = Math.floor(Math.random()*3) this.mood = arr[index] } }, }) \u0026lt;/script\u0026gt; 条件渲染 条件渲染：\n​ 1.v-if\n​ 写法：\n​ (1).v-if=\u0026ldquo;表达式\u0026rdquo;\n​ (2).v-else-if=\u0026ldquo;表达式\u0026rdquo;\n​ (3).v-else=\u0026ldquo;表达式\u0026rdquo;\n​ 适用于：切换频率较低的场景。\n​ 特点：不展示的DOM元素直接被移除。\n​ 注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。\n​ 2.v-show\n​ 写法：v-show=\u0026ldquo;表达式\u0026rdquo;\n​ 适用于：切换频率较高的场景。\n​ 特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉\n​ 3.备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。\n\u0026lt;!-- 使用v-show做条件渲染 --\u0026gt; \u0026lt;h2 v-show=\u0026#34;false\u0026#34;\u0026gt;欢迎来到{{name}}\u0026lt;/h2\u0026gt; \u0026lt;h2 v-show=\u0026#34;1 === 1\u0026#34;\u0026gt;欢迎来到{{name}}\u0026lt;/h2\u0026gt; \u0026lt;!-- 使用v-if做条件渲染 --\u0026gt; \u0026lt;h2 v-if=\u0026#34;1 === 1\u0026#34;\u0026gt;欢迎来到{{name}}\u0026lt;/h2\u0026gt; \u0026lt;h2 v-if=\u0026#34;false\u0026#34;\u0026gt;欢迎来到{{name}}\u0026lt;/h2\u0026gt; \u0026lt;!-- v-else和v-else-if --\u0026gt; \u0026lt;div v-if=\u0026#34;n === 1\u0026#34;\u0026gt;Angular\u0026lt;/div\u0026gt; \u0026lt;div v-else-if=\u0026#34;n === 2\u0026#34;\u0026gt;React\u0026lt;/div\u0026gt; \u0026lt;div v-else-if=\u0026#34;n === 3\u0026#34;\u0026gt;Vue\u0026lt;/div\u0026gt; \u0026lt;div v-else\u0026gt;哈哈\u0026lt;/div\u0026gt; \u0026lt;!-- v-if与template的配合使用 --\u0026gt; \u0026lt;template v-if=\u0026#34;n === 1\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;你好\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;尚硅谷\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;北京\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; 列表渲染 基本列表 v-for指令:\n​ 1.用于展示列表数据\n​ 2.语法：v-for=\u0026quot;(item, index) in xxx\u0026rdquo; :key=\u0026ldquo;yyy\u0026rdquo;\n​ 3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）\n\u0026lt;!-- 遍历数组 --\u0026gt; \u0026lt;h2\u0026gt;人员列表（遍历数组）\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(p,index) of persons\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt; {{p.name}}-{{p.age}} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;!-- 遍历对象 --\u0026gt; \u0026lt;h2\u0026gt;汽车信息（遍历对象）\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(value,k) of car\u0026#34; :key=\u0026#34;k\u0026#34;\u0026gt; {{k}}-{{value}} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;!-- 遍历字符串 --\u0026gt; \u0026lt;h2\u0026gt;测试遍历字符串（用得少）\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(char,index) of str\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt; {{char}}-{{index}} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;!-- 遍历指定次数 --\u0026gt; \u0026lt;h2\u0026gt;测试遍历指定次数（用得少）\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(number,index) of 5\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt; {{index}}-{{number}} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; new Vue({ el:\u0026#39;#root\u0026#39;, data:{ persons:[ {id:\u0026#39;001\u0026#39;,name:\u0026#39;张三\u0026#39;,age:18}, {id:\u0026#39;002\u0026#39;,name:\u0026#39;李四\u0026#39;,age:19}, {id:\u0026#39;003\u0026#39;,name:\u0026#39;王五\u0026#39;,age:20} ], car:{ name:\u0026#39;奥迪A8\u0026#39;, price:\u0026#39;70万\u0026#39;, color:\u0026#39;黑色\u0026#39; }, str:\u0026#39;hello\u0026#39; } }) \u0026lt;/script\u0026gt; 面试题：react、vue中的key有什么作用？（key的内部原理）\n 虚拟DOM中key的作用：  ​ key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】,\n​ 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：\n​ 2.对比规则：\n​ (1).旧虚拟DOM中找到了与新虚拟DOM相同的key：\n​ ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！\n​ ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。\n​ (2).旧虚拟DOM中未找到与新虚拟DOM相同的key\n​ 创建新的真实DOM，随后渲染到到页面。\n​ 3. 用index作为key可能会引发的问题：\n​ 1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作:\n​ 会产生没有必要的真实DOM更新 ==\u0026gt; 界面效果没问题, 但效率低。\n​ 2. 如果结构中还包含输入类的DOM：\n​ 会产生错误DOM更新 ==\u0026gt; 界面有问题。\n​ 4. 开发中如何选择key?:\n​ 1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。\n​ 2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，\n​ 使用index作为key是没有问题的。\n列表过滤 可以通过watch或者computed实现。\n\u0026lt;!-- 准备好一个容器--\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;人员列表\u0026lt;/h2\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;请输入名字\u0026#34; v-model=\u0026#34;keyWord\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(p,index) of filPerons\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt; {{p.name}}-{{p.age}}-{{p.sex}} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; Vue.config.productionTip = false //用watch实现  //#region  new Vue({ el:\u0026#39;#root\u0026#39;, data:{ keyWord:\u0026#39;\u0026#39;, persons:[ {id:\u0026#39;001\u0026#39;,name:\u0026#39;马冬梅\u0026#39;,age:19,sex:\u0026#39;女\u0026#39;}, {id:\u0026#39;002\u0026#39;,name:\u0026#39;周冬雨\u0026#39;,age:20,sex:\u0026#39;女\u0026#39;}, {id:\u0026#39;003\u0026#39;,name:\u0026#39;周杰伦\u0026#39;,age:21,sex:\u0026#39;男\u0026#39;}, {id:\u0026#39;004\u0026#39;,name:\u0026#39;温兆伦\u0026#39;,age:22,sex:\u0026#39;男\u0026#39;} ], filPerons:[] }, watch:{ keyWord:{ immediate:true, handler(val){ this.filPerons = this.persons.filter((p)=\u0026gt;{ return p.name.indexOf(val) !== -1 }) } } } }) //#endregion  //用computed实现  new Vue({ el:\u0026#39;#root\u0026#39;, data:{ keyWord:\u0026#39;\u0026#39;, persons:[ {id:\u0026#39;001\u0026#39;,name:\u0026#39;马冬梅\u0026#39;,age:19,sex:\u0026#39;女\u0026#39;}, {id:\u0026#39;002\u0026#39;,name:\u0026#39;周冬雨\u0026#39;,age:20,sex:\u0026#39;女\u0026#39;}, {id:\u0026#39;003\u0026#39;,name:\u0026#39;周杰伦\u0026#39;,age:21,sex:\u0026#39;男\u0026#39;}, {id:\u0026#39;004\u0026#39;,name:\u0026#39;温兆伦\u0026#39;,age:22,sex:\u0026#39;男\u0026#39;} ] }, computed:{ filPerons(){ return this.persons.filter((p)=\u0026gt;{ return p.name.indexOf(this.keyWord) !== -1 }) } } }) \u0026lt;/script\u0026gt; 列表排序 \u0026lt;!-- 准备好一个容器--\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;人员列表\u0026lt;/h2\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;请输入名字\u0026#34; v-model=\u0026#34;keyWord\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;sortType = 2\u0026#34;\u0026gt;年龄升序\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;sortType = 1\u0026#34;\u0026gt;年龄降序\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;sortType = 0\u0026#34;\u0026gt;原顺序\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(p,index) of filPerons\u0026#34; :key=\u0026#34;p.id\u0026#34;\u0026gt; {{p.name}}-{{p.age}}-{{p.sex}} \u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; Vue.config.productionTip = false new Vue({ el:\u0026#39;#root\u0026#39;, data:{ keyWord:\u0026#39;\u0026#39;, sortType:0, //0原顺序 1降序 2升序  persons:[ {id:\u0026#39;001\u0026#39;,name:\u0026#39;马冬梅\u0026#39;,age:30,sex:\u0026#39;女\u0026#39;}, {id:\u0026#39;002\u0026#39;,name:\u0026#39;周冬雨\u0026#39;,age:31,sex:\u0026#39;女\u0026#39;}, {id:\u0026#39;003\u0026#39;,name:\u0026#39;周杰伦\u0026#39;,age:18,sex:\u0026#39;男\u0026#39;}, {id:\u0026#39;004\u0026#39;,name:\u0026#39;温兆伦\u0026#39;,age:19,sex:\u0026#39;男\u0026#39;} ] }, computed:{ filPerons(){ const arr = this.persons.filter((p)=\u0026gt;{ return p.name.indexOf(this.keyWord) !== -1 }) //判断一下是否需要排序  if(this.sortType){ arr.sort((p1,p2)=\u0026gt;{ return this.sortType === 1 ? p2.age-p1.age : p1.age-p2.age }) } return arr } } }) \u0026lt;/script\u0026gt; Vue监视数据的原理：\n  vue会监视data中所有层次的数据。\n  如何监测对象中的数据？\n  ​ 通过setter实现监视，且要在new Vue时就传入要监测的数据。\n​ (1).对象中后追加的属性，Vue默认不做响应式处理\n​ (2).如需给后添加的属性做响应式，请使用如下API：\n​ Vue.set(target，propertyName/index，value) 或\n​ vm.$set(target，propertyName/index，value)\n如何监测数组中的数据？  ​ 通过包裹数组更新元素的方法实现，本质就是做了两件事：\n​ (1).调用原生对应的方法对数组进行更新。\n​ (2).重新解析模板，进而更新页面。\n4.在Vue修改数组中的某个元素一定要用如下方法：\n​ 1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()\n​ 2.Vue.set() 或 vm.$set()\n特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！\n收集表单数据 若：\u0026lt;input type=\u0026quot;text\u0026quot;/\u0026gt;，则v-model收集的是value值，用户输入的就是value值。\n若：\u0026lt;input type=\u0026quot;radio\u0026quot;/\u0026gt;，则v-model收集的是value值，且要给标签配置value值。\n若：\u0026lt;input type=\u0026quot;checkbox\u0026quot;/\u0026gt;\n​ 1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）\n​ 2.配置input的value属性:\n​ (1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）\n​ (2)v-model的初始值是数组，那么收集的的就是value组成的数组\n备注：v-model的三个修饰符：\n​ lazy：失去焦点再收集数据\n​ number：输入字符串转为有效的数字\n​ trim：输入首尾空格过滤\n\u0026lt;form @submit.prevent=\u0026#34;demo\u0026#34;\u0026gt; 账号：\u0026lt;input type=\u0026#34;text\u0026#34; v-model.trim=\u0026#34;userInfo.account\u0026#34;\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; 密码：\u0026lt;input type=\u0026#34;password\u0026#34; v-model=\u0026#34;userInfo.password\u0026#34;\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; 年龄：\u0026lt;input type=\u0026#34;number\u0026#34; v-model.number=\u0026#34;userInfo.age\u0026#34;\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; 性别： 男\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; v-model=\u0026#34;userInfo.sex\u0026#34; value=\u0026#34;male\u0026#34;\u0026gt; 女\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; v-model=\u0026#34;userInfo.sex\u0026#34; value=\u0026#34;female\u0026#34;\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; 爱好： 学习\u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;userInfo.hobby\u0026#34; value=\u0026#34;study\u0026#34;\u0026gt; 打游戏\u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;userInfo.hobby\u0026#34; value=\u0026#34;game\u0026#34;\u0026gt; 吃饭\u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;userInfo.hobby\u0026#34; value=\u0026#34;eat\u0026#34;\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; 所属校区 \u0026lt;select v-model=\u0026#34;userInfo.city\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;\u0026#34;\u0026gt;请选择校区\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;beijing\u0026#34;\u0026gt;北京\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;shanghai\u0026#34;\u0026gt;上海\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;shenzhen\u0026#34;\u0026gt;深圳\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;wuhan\u0026#34;\u0026gt;武汉\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; 其他信息： \u0026lt;textarea v-model.lazy=\u0026#34;userInfo.other\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;userInfo.agree\u0026#34;\u0026gt;阅读并接受\u0026lt;a href=\u0026#34;http://www.atguigu.com\u0026#34;\u0026gt;《用户协议》\u0026lt;/a\u0026gt; \u0026lt;button\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt; new Vue({ el:\u0026#39;#root\u0026#39;, data:{ userInfo:{ account:\u0026#39;\u0026#39;, password:\u0026#39;\u0026#39;, age:18, sex:\u0026#39;female\u0026#39;, hobby:[], city:\u0026#39;beijing\u0026#39;, other:\u0026#39;\u0026#39;, agree:\u0026#39;\u0026#39; } }, methods: { demo(){ console.log(JSON.stringify(this.userInfo)) } } }) \u0026lt;/script\u0026gt; 过滤器 过滤器：\n定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。\n语法：\n​ 1.注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}\n​ 2.使用过滤器：{{ xxx | 过滤器名}} 或 v-bind:属性 = \u0026ldquo;xxx | 过滤器名\u0026rdquo;\n备注：\n​ 1.过滤器也可以接收额外参数、多个过滤器也可以串联\n​ 2.并没有改变原本的数据, 是产生新的对应的数据\n\u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;显示格式化后的时间\u0026lt;/h2\u0026gt; \u0026lt;!-- 计算属性实现 --\u0026gt; \u0026lt;h3\u0026gt;现在是：{{fmtTime}}\u0026lt;/h3\u0026gt; \u0026lt;!-- methods实现 --\u0026gt; \u0026lt;h3\u0026gt;现在是：{{getFmtTime()}}\u0026lt;/h3\u0026gt; \u0026lt;!-- 过滤器实现 --\u0026gt; \u0026lt;h3\u0026gt;现在是：{{time | timeFormater}}\u0026lt;/h3\u0026gt; \u0026lt;!-- 过滤器实现（传参） --\u0026gt; \u0026lt;h3\u0026gt;现在是：{{time | timeFormater(\u0026#39;YYYY_MM_DD\u0026#39;) | mySlice}}\u0026lt;/h3\u0026gt; \u0026lt;h3 :x=\u0026#34;msg | mySlice\u0026#34;\u0026gt;尚硅谷\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;root2\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;{{msg | mySlice}}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.filter(\u0026#39;mySlice\u0026#39;,function(value){ return value.slice(0,4) }) new Vue({ el:\u0026#39;#root\u0026#39;, data:{ time:1621561377603, //时间戳  msg:\u0026#39;你好，尚硅谷\u0026#39; }, computed: { fmtTime(){ return dayjs(this.time).format(\u0026#39;YYYY年MM月DD日 HH:mm:ss\u0026#39;) } }, methods: { getFmtTime(){ return dayjs(this.time).format(\u0026#39;YYYY年MM月DD日 HH:mm:ss\u0026#39;) } }, //局部过滤器  filters:{ timeFormater(value,str=\u0026#39;YYYY年MM月DD日 HH:mm:ss\u0026#39;){ // console.log(\u0026#39;@\u0026#39;,value)  return dayjs(value).format(str) } } }) new Vue({ el:\u0026#39;#root2\u0026#39;, data:{ msg:\u0026#39;hello,atguigu!\u0026#39; } }) \u0026lt;/script\u0026gt; 内置指令 我们学过的指令：\n​ v-bind : 单向绑定解析表达式, 可简写为 :xxx\n​ v-model : 双向数据绑定\n​ v-for : 遍历数组/对象/字符串\n​ v-on : 绑定事件监听, 可简写为@\n​ v-if : 条件渲染（动态控制节点是否存存在）\n​ v-else : 条件渲染（动态控制节点是否存存在）\n​ v-show : 条件渲染 (动态控制节点是否展示)\nv-text指令：\n​ 1.作用：向其所在的节点中渲染文本内容。\n​ 2.与插值语法的区别：v-text会替换掉节点中的内容，{{xx}}则不会。\nv-html指令：\n​ 1.作用：向指定节点中渲染包含html结构的内容。\n​ 2.与插值语法的区别：\n​ (1).v-html会替换掉节点中所有的内容，{{xx}}则不会。\n​ (2).v-html可以识别html结构。\n​ 3.严重注意：v-html有安全性问题！！！！\n​ (1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。\n​ (2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！\nv-cloak指令（没有值）：\n​ 1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。\n​ 2.使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题。\nv-once指令：\n​ 1.v-once所在节点在初次动态渲染后，就视为静态内容了。\n​ 2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。\nv-pre指令：\n​ 1.跳过其所在节点的编译过程。\n​ 2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。\n生命周期 话不多说先上图：\n 生命周期 \n生命周期：\n​ 1.又名：生命周期回调函数、生命周期函数、生命周期钩子。\n​ 2.是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。\n​ 3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。\n​ 4.生命周期函数中的this指向是vm 或 组件实例对象。\n常用的生命周期钩子：\n​ 1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。\n​ 2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。\n关于销毁Vue实例\n​ 1.销毁后借助Vue开发者工具看不到任何信息。\n​ 2.销毁后自定义事件会失效，但原生DOM事件依然有效。\n​ 3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。\n组件 Vue中使用组件的三大步骤：\n​ 一、定义组件(创建组件)\n​ 二、注册组件\n​ 三、使用组件(写组件标签)\n一、如何定义一个组件？\n​ 使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；\n​ 区别如下：\n​ 1.el不要写，为什么？ ——— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。\n​ 2.data必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。\n​ 备注：使用template可以配置组件结构。\n二、如何注册组件？\n​ 1.局部注册：靠new Vue的时候传入components选项\n​ 2.全局注册：靠Vue.component(\u0026lsquo;组件名\u0026rsquo;,组件)\n三、编写组件标签：\n​ \u0026lt;school\u0026gt;\u0026lt;/school\u0026gt;\n几个注意点：\n​ 1.关于组件名:\n​ 一个单词组成：\n​ 第一种写法(首字母小写)：school\n​ 第二种写法(首字母大写)：School\n​ 多个单词组成：\n​ 第一种写法(kebab-case命名)：my-school\n​ 第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)\n​ 备注：\n​ (1).组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。\n​ (2).可以使用name配置项指定组件在开发者工具中呈现的名字。\n​ 2.关于组件标签:\n​ 第一种写法：​ 第二种写法：​ 备注：不用使用脚手架时，会导致后续组件不能渲染。\n​ 3.一个简写方式：\n​ const school = Vue.extend(options) 可简写为：const school = options\n关于VueComponent：\n​ 1.school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。\n​ 2.我们只需要写或，Vue解析时会帮我们创建school组件的实例对象，\n​ 即Vue帮我们执行的：new VueComponent(options)。\n​ 3.特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！\n​ 4.关于this指向：\n​ (1).组件配置中：\n​ data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。\n​ (2).new Vue(options)配置中：\n​ data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。\n​ 5.VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。\n​ Vue的实例对象，以后简称vm。\nVue2进阶 到这一部分，就要使用到脚手架了，同时也向正式的项目靠近了。\n脚手架文件结构 ├── node_modules ├── public │ ├── favicon.ico: 页签图标 │ └── index.html: 主页面 ├── src │ ├── assets: 存放静态资源 │ │ └── logo.png │ │── component: 存放组件 │ │ └── HelloWorld.vue │ │── App.vue: 汇总所有组件 │ │── main.js: 入口文件 ├── .gitignore: git版本管制忽略的配置 ├── babel.config.js: babel的配置文件 ├── package.json: 应用包配置文件 ├── README.md: 应用描述文件 ├── package-lock.json：包版本控制文件 关于不同版本的Vue  vue.js与vue.runtime.xxx.js的区别：  vue.js是完整版的Vue，包含：核心功能 + 模板解析器。 vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。   因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。也就是代码中的这句render: h =\u0026gt; h(App)  vue.config.js配置文件  使用vue inspect \u0026gt; output.js可以查看到Vue脚手架的默认配置。 使用vue.config.js可以对脚手架进行个性化定制，详情见：https://cli.vuejs.org/zh  ref属性  被用来给元素或子组件注册引用信息（id的替代者） 应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc） 使用方式：  打标识：\u0026lt;h1 ref=\u0026quot;xxx\u0026quot;\u0026gt;.....\u0026lt;/h1\u0026gt; 或 \u0026lt;School ref=\u0026quot;xxx\u0026quot;\u0026gt;\u0026lt;/School\u0026gt; 获取：this.$refs.xxx    props配置项   功能：让组件接收外部传过来的数据\n  传递数据：\u0026lt;Demo name=\u0026quot;xxx\u0026quot;/\u0026gt;\n  接收数据：\n  第一种方式（只接收）：props:['name'] \n  第二种方式（限制类型）：props:{name:String}\n  第三种方式（限制类型、限制必要性、指定默认值）：\nprops:{ name:{ type:String, //类型 \trequired:true, //必要性 \tdefault:\u0026#39;老王\u0026#39; //默认值 \t} }    备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。\n   mixin(混入)   功能：可以把多个组件共用的配置提取成一个混入对象\n  使用方式：\n第一步定义混合：\n{ data(){....}, methods:{....} .... } 第二步使用混入：\n​\t全局混入：Vue.mixin(xxx) ​\t局部混入：mixins:['xxx']\t\n  插件   功能：用于增强Vue\n  本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。\n  定义插件：\n对象.install = function (Vue, options) { // 1. 添加全局过滤器  Vue.filter(....) // 2. 添加全局指令  Vue.directive(....) // 3. 配置全局混入(合)  Vue.mixin(....) // 4. 添加实例方法  Vue.prototype.$myMethod = function () {...} Vue.prototype.$myProperty = xxxx }   使用插件：Vue.use()\n  scoped样式  作用：让样式在局部生效，防止冲突。 写法：\u0026lt;style scoped\u0026gt;  总结TodoList案例   组件化编码流程：\n​\t(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。\n​\t(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：\n​\t1).一个组件在用：放在组件自身即可。\n​\t2). 一些组件在用：放在他们共同的父组件上（状态提升）。\n​\t(3).实现交互：从绑定事件开始。\n  props适用于：\n​\t(1).父组件 ==\u0026gt; 子组件 通信\n​\t(2).子组件 ==\u0026gt; 父组件 通信（要求父先给子一个函数）\n  使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！\n  props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。\n  webStorage   存储内容大小一般支持5MB左右（不同浏览器可能还不一样）\n  浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。\n  相关API：\n  xxxxxStorage.setItem('key', 'value'); 该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。\n  xxxxxStorage.getItem('person');\n​\t该方法接受一个键名作为参数，返回键名对应的值。\n  xxxxxStorage.removeItem('key');\n​\t该方法接受一个键名作为参数，并把该键名从存储中删除。\n   xxxxxStorage.clear()\n​\t该方法会清空存储中的所有数据。\n    备注：\n SessionStorage存储的内容会随着浏览器窗口关闭而消失。 LocalStorage存储的内容，需要手动清除才会消失。 xxxxxStorage.getItem(xxx)如果xxx对应的value获取不到，那么getItem的返回值是null。 JSON.parse(null)的结果依然是null。    组件的自定义事件   一种组件间通信的方式，适用于：子组件 ===\u0026gt; 父组件  使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中）。\n  绑定自定义事件：\n  第一种方式，在父组件中：\u0026lt;Demo @atguigu=\u0026quot;test\u0026quot;/\u0026gt; 或 \u0026lt;Demo v-on:atguigu=\u0026quot;test\u0026quot;/\u0026gt;\n  第二种方式，在父组件中：\n\u0026lt;Demo ref=\u0026#34;demo\u0026#34;/\u0026gt; ...... mounted(){ this.$refs.xxx.$on(\u0026#39;atguigu\u0026#39;,this.test) }   若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法。\n    触发自定义事件：this.$emit('atguigu',数据)\n  解绑自定义事件this.$off('atguigu')\n  组件上也可以绑定原生DOM事件，需要使用native修饰符。\n  注意：通过this.$refs.xxx.$on('atguigu',回调)绑定自定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出问题！\n  全局事件总线（GlobalEventBus）   一种组件间通信的方式，适用于任意组件间通信。\n  安装全局事件总线：\nnew Vue({ ...... beforeCreate() { Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm \t}, ...... })   使用事件总线：\n  接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。methods(){ demo(data){......} } ...... mounted() { this.$bus.$on(\u0026#39;xxxx\u0026#39;,this.demo) }   提供数据：this.$bus.$emit('xxxx',数据)\n    最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件。\n  消息订阅与发布（pubsub）   一种组件间通信的方式，适用于任意组件间通信。\n  使用步骤：\n  安装pubsub：npm i pubsub-js\n  引入: import pubsub from 'pubsub-js'\n  接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身。methods(){ demo(data){......} } ...... mounted() { this.pid = pubsub.subscribe(\u0026#39;xxx\u0026#39;,this.demo) //订阅消息 }   提供数据：pubsub.publish('xxx',数据)\n  最好在beforeDestroy钩子中，用PubSub.unsubscribe(pid)去取消订阅。    nextTick  语法：this.$nextTick(回调函数) 作用：在下一次 DOM 更新结束后执行其指定的回调。 什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。  Vue封装的过度与动画   作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。\n  图示：  写法：\n  准备好样式：\n 元素进入的样式：  v-enter：进入的起点 v-enter-active：进入过程中 v-enter-to：进入的终点   元素离开的样式：  v-leave：离开的起点 v-leave-active：离开过程中 v-leave-to：离开的终点      使用\u0026lt;transition\u0026gt;包裹要过度的元素，并配置name属性：\n\u0026lt;transition name=\u0026#34;hello\u0026#34;\u0026gt; \u0026lt;h1 v-show=\u0026#34;isShow\u0026#34;\u0026gt;你好啊！\u0026lt;/h1\u0026gt; \u0026lt;/transition\u0026gt;   备注：若有多个元素需要过度，则需要使用：\u0026lt;transition-group\u0026gt;，且每个元素都要指定key值。\n    vue脚手架配置代理 方法一 ​\t在vue.config.js中添加如下配置：\ndevServer:{ proxy:\u0026#34;http://localhost:5000\u0026#34; } 说明：\n 优点：配置简单，请求资源时直接发给前端（8080）即可。 缺点：不能配置多个代理，不能灵活的控制请求是否走代理。 工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）  方法二 ​\t编写vue.config.js配置具体代理规则：\nmodule.exports = { devServer: { proxy: { \u0026#39;/api1\u0026#39;: {// 匹配所有以 \u0026#39;/api1\u0026#39;开头的请求路径  target: \u0026#39;http://localhost:5000\u0026#39;,// 代理目标的基础路径  changeOrigin: true, pathRewrite: {\u0026#39;^/api1\u0026#39;: \u0026#39;\u0026#39;} }, \u0026#39;/api2\u0026#39;: {// 匹配所有以 \u0026#39;/api2\u0026#39;开头的请求路径  target: \u0026#39;http://localhost:5001\u0026#39;,// 代理目标的基础路径  changeOrigin: true, pathRewrite: {\u0026#39;^/api2\u0026#39;: \u0026#39;\u0026#39;} } } } } /* changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000 changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080 changeOrigin默认值为true */ 说明：\n 优点：可以配置多个代理，且可以灵活的控制请求是否走代理。 缺点：配置略微繁琐，请求资源时必须加前缀。  插槽   作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 父组件 ===\u0026gt; 子组件。\n  分类：默认插槽、具名插槽、作用域插槽\n  使用方式：\n  默认插槽：\n父组件中： \u0026lt;Category\u0026gt; \u0026lt;div\u0026gt;html结构1\u0026lt;/div\u0026gt; \u0026lt;/Category\u0026gt; 子组件中： \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 定义插槽 --\u0026gt; \u0026lt;slot\u0026gt;插槽默认内容...\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt;   具名插槽：\n父组件中： \u0026lt;Category\u0026gt; \u0026lt;template slot=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;div\u0026gt;html结构1\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:footer\u0026gt; \u0026lt;div\u0026gt;html结构2\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Category\u0026gt; 子组件中： \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 定义插槽 --\u0026gt; \u0026lt;slot name=\u0026#34;center\u0026#34;\u0026gt;插槽默认内容...\u0026lt;/slot\u0026gt; \u0026lt;slot name=\u0026#34;footer\u0026#34;\u0026gt;插槽默认内容...\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt;   作用域插槽：\n  理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）\n  具体编码：\n父组件中： \u0026lt;Category\u0026gt; \u0026lt;template scope=\u0026#34;scopeData\u0026#34;\u0026gt; \u0026lt;!-- 生成的是ul列表 --\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;g in scopeData.games\u0026#34; :key=\u0026#34;g\u0026#34;\u0026gt;{{g}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Category\u0026gt; \u0026lt;Category\u0026gt; \u0026lt;template slot-scope=\u0026#34;scopeData\u0026#34;\u0026gt; \u0026lt;!-- 生成的是h4标题 --\u0026gt; \u0026lt;h4 v-for=\u0026#34;g in scopeData.games\u0026#34; :key=\u0026#34;g\u0026#34;\u0026gt;{{g}}\u0026lt;/h4\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Category\u0026gt; 子组件中： \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;slot :games=\u0026#34;games\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name:\u0026#39;Category\u0026#39;, props:[\u0026#39;title\u0026#39;], //数据在子组件自身  data() { return { games:[\u0026#39;红色警戒\u0026#39;,\u0026#39;穿越火线\u0026#39;,\u0026#39;劲舞团\u0026#39;,\u0026#39;超级玛丽\u0026#39;] } }, } \u0026lt;/script\u0026gt;       Vuex 概念 ​\t在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。\n何时使用？ ​\t多个组件需要共享数据时\n搭建vuex环境   创建文件：src/store/index.js\n//引入Vue核心库 import Vue from \u0026#39;vue\u0026#39; //引入Vuex import Vuex from \u0026#39;vuex\u0026#39; //应用Vuex插件 Vue.use(Vuex) //准备actions对象——响应组件中用户的动作 const actions = {} //准备mutations对象——修改state中的数据 const mutations = {} //准备state对象——保存具体的数据 const state = {} //创建并暴露store export default new Vuex.Store({ actions, mutations, state })   在main.js中创建vm时传入store配置项\n...... //引入store import store from \u0026#39;./store\u0026#39; ...... //创建vm new Vue({ el:\u0026#39;#app\u0026#39;, render: h =\u0026gt; h(App), store })   基本使用   初始化数据、配置actions、配置mutations，操作文件store.js\n//引入Vue核心库 import Vue from \u0026#39;vue\u0026#39; //引入Vuex import Vuex from \u0026#39;vuex\u0026#39; //引用Vuex Vue.use(Vuex) const actions = { //响应组件中加的动作 \tjia(context,value){ // console.log(\u0026#39;actions中的jia被调用了\u0026#39;,miniStore,value)  context.commit(\u0026#39;JIA\u0026#39;,value) }, } const mutations = { //执行加 \tJIA(state,value){ // console.log(\u0026#39;mutations中的JIA被调用了\u0026#39;,state,value)  state.sum += value } } //初始化数据 const state = { sum:0 } //创建并暴露store export default new Vuex.Store({ actions, mutations, state, })   组件中读取vuex中的数据：$store.state.sum\n  组件中修改vuex中的数据：$store.dispatch('action中的方法名',数据) 或 $store.commit('mutations中的方法名',数据)\n 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写dispatch，直接编写commit\n   getters的使用   概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。\n  在store.js中追加getters配置\n...... const getters = { bigSum(state){ return state.sum * 10 } } //创建并暴露store export default new Vuex.Store({ ...... getters })   组件中读取数据：$store.getters.bigSum\n  四个map方法的使用   mapState方法：用于帮助我们映射state中的数据为计算属性\ncomputed: { //借助mapState生成计算属性：sum、school、subject（对象写法）  ...mapState({sum:\u0026#39;sum\u0026#39;,school:\u0026#39;school\u0026#39;,subject:\u0026#39;subject\u0026#39;}), //借助mapState生成计算属性：sum、school、subject（数组写法）  ...mapState([\u0026#39;sum\u0026#39;,\u0026#39;school\u0026#39;,\u0026#39;subject\u0026#39;]), },   mapGetters方法：用于帮助我们映射getters中的数据为计算属性\ncomputed: { //借助mapGetters生成计算属性：bigSum（对象写法）  ...mapGetters({bigSum:\u0026#39;bigSum\u0026#39;}), //借助mapGetters生成计算属性：bigSum（数组写法）  ...mapGetters([\u0026#39;bigSum\u0026#39;]) },   mapActions方法：用于帮助我们生成与actions对话的方法，即：包含$store.dispatch(xxx)的函数\nmethods:{ //靠mapActions生成：incrementOdd、incrementWait（对象形式）  ...mapActions({incrementOdd:\u0026#39;jiaOdd\u0026#39;,incrementWait:\u0026#39;jiaWait\u0026#39;}) //靠mapActions生成：incrementOdd、incrementWait（数组形式）  ...mapActions([\u0026#39;jiaOdd\u0026#39;,\u0026#39;jiaWait\u0026#39;]) }   mapMutations方法：用于帮助我们生成与mutations对话的方法，即：包含$store.commit(xxx)的函数\nmethods:{ //靠mapActions生成：increment、decrement（对象形式）  ...mapMutations({increment:\u0026#39;JIA\u0026#39;,decrement:\u0026#39;JIAN\u0026#39;}), //靠mapMutations生成：JIA、JIAN（对象形式）  ...mapMutations([\u0026#39;JIA\u0026#39;,\u0026#39;JIAN\u0026#39;]), }    备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。\n 模块化+命名空间   目的：让代码更好维护，让多种数据分类更加明确。\n  修改store.js\nconst countAbout = { namespaced:true,//开启命名空间  state:{x:1}, mutations: { ... }, actions: { ... }, getters: { bigSum(state){ return state.sum * 10 } } } const personAbout = { namespaced:true,//开启命名空间  state:{ ... }, mutations: { ... }, actions: { ... } } const store = new Vuex.Store({ modules: { countAbout, personAbout } })   开启命名空间后，组件中读取state数据：\n//方式一：自己直接读取 this.$store.state.personAbout.list //方式二：借助mapState读取： ...mapState(\u0026#39;countAbout\u0026#39;,[\u0026#39;sum\u0026#39;,\u0026#39;school\u0026#39;,\u0026#39;subject\u0026#39;]),   开启命名空间后，组件中读取getters数据：\n//方式一：自己直接读取 this.$store.getters[\u0026#39;personAbout/firstPersonName\u0026#39;] //方式二：借助mapGetters读取： ...mapGetters(\u0026#39;countAbout\u0026#39;,[\u0026#39;bigSum\u0026#39;])   开启命名空间后，组件中调用dispatch\n//方式一：自己直接dispatch this.$store.dispatch(\u0026#39;personAbout/addPersonWang\u0026#39;,person) //方式二：借助mapActions： ...mapActions(\u0026#39;countAbout\u0026#39;,{incrementOdd:\u0026#39;jiaOdd\u0026#39;,incrementWait:\u0026#39;jiaWait\u0026#39;})   开启命名空间后，组件中调用commit\n//方式一：自己直接commit this.$store.commit(\u0026#39;personAbout/ADD_PERSON\u0026#39;,person) //方式二：借助mapMutations： ...mapMutations(\u0026#39;countAbout\u0026#39;,{increment:\u0026#39;JIA\u0026#39;,decrement:\u0026#39;JIAN\u0026#39;}),   路由  理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。 前端路由：key是路径，value是组件。  基本使用   安装vue-router，命令：npm i vue-router\n  应用插件：Vue.use(VueRouter)\n  编写router配置项:\n//引入VueRouter import VueRouter from \u0026#39;vue-router\u0026#39; //引入Luyou 组件 import About from \u0026#39;../components/About\u0026#39; import Home from \u0026#39;../components/Home\u0026#39; //创建router实例对象，去管理一组一组的路由规则 const router = new VueRouter({ routes:[ { path:\u0026#39;/about\u0026#39;, component:About }, { path:\u0026#39;/home\u0026#39;, component:Home } ] }) //暴露router export default router   实现切换（active-class可配置高亮样式）\n\u0026lt;router-link active-class=\u0026#34;active\u0026#34; to=\u0026#34;/about\u0026#34;\u0026gt;About\u0026lt;/router-link\u0026gt;   指定展示位置\n\u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt;   几个注意点  路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹。 通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。 每个组件都有自己的$route属性，里面存储着自己的路由信息。 整个应用只有一个router，可以通过组件的$router属性获取到。  多级路由（多级路由）   配置路由规则，使用children配置项：\nroutes:[ { path:\u0026#39;/about\u0026#39;, component:About, }, { path:\u0026#39;/home\u0026#39;, component:Home, children:[ //通过children配置子级路由  { path:\u0026#39;news\u0026#39;, //此处一定不要写：/news  component:News }, { path:\u0026#39;message\u0026#39;,//此处一定不要写：/message  component:Message } ] } ]   跳转（要写完整路径）：\n\u0026lt;router-link to=\u0026#34;/home/news\u0026#34;\u0026gt;News\u0026lt;/router-link\u0026gt;   路由的query参数   传递参数\n\u0026lt;!-- 跳转并携带query参数，to的字符串写法 --\u0026gt; \u0026lt;router-link :to=\u0026#34;/home/message/detail?id=666\u0026amp;title=你好\u0026#34;\u0026gt;跳转\u0026lt;/router-link\u0026gt; \u0026lt;!-- 跳转并携带query参数，to的对象写法 --\u0026gt; \u0026lt;router-link :to=\u0026#34;{ path:\u0026#39;/home/message/detail\u0026#39;, query:{ id:666, title:\u0026#39;你好\u0026#39; } }\u0026#34; \u0026gt;跳转\u0026lt;/router-link\u0026gt;   接收参数：\n$route.query.id $route.query.title   命名路由   作用：可以简化路由的跳转。\n  如何使用\n  给路由命名：\n{ path:\u0026#39;/demo\u0026#39;, component:Demo, children:[ { path:\u0026#39;test\u0026#39;, component:Test, children:[ { name:\u0026#39;hello\u0026#39; //给路由命名  path:\u0026#39;welcome\u0026#39;, component:Hello, } ] } ] }   简化跳转：\n\u0026lt;!--简化前，需要写完整的路径 --\u0026gt; \u0026lt;router-link to=\u0026#34;/demo/test/welcome\u0026#34;\u0026gt;跳转\u0026lt;/router-link\u0026gt; \u0026lt;!--简化后，直接通过名字跳转 --\u0026gt; \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;hello\u0026#39;}\u0026#34;\u0026gt;跳转\u0026lt;/router-link\u0026gt; \u0026lt;!--简化写法配合传递参数 --\u0026gt; \u0026lt;router-link :to=\u0026#34;{ name:\u0026#39;hello\u0026#39;, query:{ id:666, title:\u0026#39;你好\u0026#39; } }\u0026#34; \u0026gt;跳转\u0026lt;/router-link\u0026gt;     路由的params参数   配置路由，声明接收params参数\n{ path:\u0026#39;/home\u0026#39;, component:Home, children:[ { path:\u0026#39;news\u0026#39;, component:News }, { component:Message, children:[ { name:\u0026#39;xiangqing\u0026#39;, path:\u0026#39;detail/:id/:title\u0026#39;, //使用占位符声明接收params参数  component:Detail } ] } ] }   传递参数\n\u0026lt;!-- 跳转并携带params参数，to的字符串写法 --\u0026gt; \u0026lt;router-link :to=\u0026#34;/home/message/detail/666/你好\u0026#34;\u0026gt;跳转\u0026lt;/router-link\u0026gt; \u0026lt;!-- 跳转并携带params参数，to的对象写法 --\u0026gt; \u0026lt;router-link :to=\u0026#34;{ name:\u0026#39;xiangqing\u0026#39;, params:{ id:666, title:\u0026#39;你好\u0026#39; } }\u0026#34; \u0026gt;跳转\u0026lt;/router-link\u0026gt;  特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！\n   接收参数：\n$route.params.id $route.params.title   路由的props配置 ​\t作用：让路由组件更方便的收到参数\n{ name:\u0026#39;xiangqing\u0026#39;, path:\u0026#39;detail/:id\u0026#39;, component:Detail, //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件 \t// props:{a:900}  //第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件 \t// props:true \t//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件 \tprops(route){ return { id:route.query.id, title:route.query.title } } } \u0026lt;router-link\u0026gt;的replace属性  作用：控制路由跳转时操作浏览器历史记录的模式 浏览器的历史记录有两种写入方式：分别为push和replace，push是追加历史记录，replace是替换当前记录。路由跳转时候默认为push 如何开启replace模式：\u0026lt;router-link replace .......\u0026gt;News\u0026lt;/router-link\u0026gt;  编程式路由导航   作用：不借助\u0026lt;router-link\u0026gt; 实现路由跳转，让路由跳转更加灵活\n  具体编码：\n//$router的两个API this.$router.push({ name:\u0026#39;xiangqing\u0026#39;, params:{ id:xxx, title:xxx } }) this.$router.replace({ name:\u0026#39;xiangqing\u0026#39;, params:{ id:xxx, title:xxx } }) this.$router.forward() //前进 this.$router.back() //后退 this.$router.go() //可前进也可后退   缓存路由组件   作用：让不展示的路由组件保持挂载，不被销毁。\n  具体编码：\n\u0026lt;keep-alive include=\u0026#34;News\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/keep-alive\u0026gt;   两个新的生命周期钩子  作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。 具体名字：  activated路由组件被激活时触发。 deactivated路由组件失活时触发。    路由守卫   作用：对路由进行权限控制\n  分类：全局守卫、独享守卫、组件内守卫\n  全局守卫:\n//全局前置守卫：初始化时执行、每次路由切换前执行 router.beforeEach((to,from,next)=\u0026gt;{ console.log(\u0026#39;beforeEach\u0026#39;,to,from) if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制  if(localStorage.getItem(\u0026#39;school\u0026#39;) === \u0026#39;atguigu\u0026#39;){ //权限控制的具体规则  next() //放行  }else{ alert(\u0026#39;暂无权限查看\u0026#39;) // next({name:\u0026#39;guanyu\u0026#39;})  } }else{ next() //放行 \t} }) //全局后置守卫：初始化时执行、每次路由切换后执行 router.afterEach((to,from)=\u0026gt;{ console.log(\u0026#39;afterEach\u0026#39;,to,from) if(to.meta.title){ document.title = to.meta.title //修改网页的title \t}else{ document.title = \u0026#39;vue_test\u0026#39; } })   独享守卫:\nbeforeEnter(to,from,next){ console.log(\u0026#39;beforeEnter\u0026#39;,to,from) if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制  if(localStorage.getItem(\u0026#39;school\u0026#39;) === \u0026#39;atguigu\u0026#39;){ next() }else{ alert(\u0026#39;暂无权限查看\u0026#39;) // next({name:\u0026#39;guanyu\u0026#39;})  } }else{ next() } }   组件内守卫：\n//进入守卫：通过路由规则，进入该组件时被调用 beforeRouteEnter (to, from, next) { }, //离开守卫：通过路由规则，离开该组件时被调用 beforeRouteLeave (to, from, next) { }   路由器的两种工作模式   对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。\n  hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。\n  hash模式：\n 地址中永远带着#号，不美观 。 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。 兼容性较好。    history模式：\n 地址干净，美观 。 兼容性和hash模式相比略差。 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。    ","date":"2021-09-22T08:21:14+08:00","image":"https://lbqaq.top/p/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/88417243.webp","permalink":"https://lbqaq.top/p/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Vue学习笔记"},{"content":"最近做项目需要前后端分离，所以需要接口文档给前端方便联调。手写文档是不可能的，这时就需要使用Swagger了。网上的教程大部分版本都在2.x甚至是1.x，很少有3.0的教程，我个人就是喜欢用最新版，所以我就来分享一下我使用Swagger3的体验和坑吧。\n配置 这里就分享springboot版本的方法了，现在的项目应该都用springboot创建了吧。\n  导入Maven依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   在启动类上加上@EnableOpenApi就行了。\n  当然，这样只是默认的，我们要用肯定要配置一下，我们去创建一个Config类，在里面建立一个函数返回Docket类，我们所有的配置就在这个Docket类里配置。\n@Configuration @EnableOpenApi public class SwaggerConfig { @Bean public Docket docket(){ return new Docket(DocumentationType.OAS_30)\t//3.0版本用OAS_30这个标准  .apiInfo(getApiInfo()) .select() //扫描指定包下的接口  .apis(RequestHandlerSelectors.basePackage(\u0026#34;top.lbqaq.controller\u0026#34;)) .build(); } /** * 配置swagger信息 */ private ApiInfo getApiInfo(){ //这里是作者信息，分别为姓名、个人主页、邮箱  Contact contact = new Contact(\u0026#34;luoboQAQ\u0026#34;,\u0026#34;https://lbqaq.top\u0026#34;,\u0026#34;123@xx.com\u0026#34;); return new ApiInfo( \u0026#34;项目名\u0026#34;, \u0026#34;项目描述\u0026#34;, \u0026#34;版本\u0026#34;, \u0026#34;项目主页\u0026#34;, contact, \u0026#34;Apache 2.0\u0026#34;, \u0026#34;https://www.apache.org/licenses/LICENSE-2.0\u0026#34;, new ArrayList()); } } 这样一个带有个人信息的配置页就做好了。\n注解 首先是2.0版本的注解，当然新版本也同样通用。\n   Swagger注解 简单说明     @Api(tags = \u0026ldquo;xxx模块说明\u0026rdquo;) 作用在模块类上   @ApiOperation(\u0026ldquo;xxx接口说明\u0026rdquo;) 作用在接口方法上   @ApiModel(\u0026ldquo;xxxPOJO说明\u0026rdquo;) 作用在模型类上：如VO、BO   @ApiModelProperty(value = \u0026ldquo;xxx属性说明\u0026rdquo;,hidden = true) 作用在类方法和属性上，hidden设置为true可以隐藏该属性   @ApiParam(\u0026ldquo;xxx参数说明\u0026rdquo;) 作用在参数、方法和字段上，类似@ApiModelProperty    既然用了3.0，也就可以使用3.0的新注释。\n先放上官网链接：\n Swagger注解 SpringFox文档  Swagger是底层，实现是由SpringFox来完成的，所以有些在Swagger文档里的注解放到SpringFox里就无法实现，比如@RequestBody这个注解就无法实现。下面就列举我测试过可以成功的注解：\n在方法上进行注释\n@Operation(summary = \u0026#34;这会显示在主页上\u0026#34;, description = \u0026#34;这显示在内页里\u0026#34;, tags = {\u0026#34;test\u0026#34;})\t//会将接口分类出去 在参数上注释\n@Parameter(description = \u0026#34;这里是描述\u0026#34;, required = true) 只测了这么多，之前为了测试@RequestBody花了太多时间，结果一无所获。因为2.0的注解还能用，这里就挖个坑，等之后有时间再来完善吧。\n","date":"2021-09-09T15:09:04+08:00","image":"https://lbqaq.top/p/swagger/92079701.webp","permalink":"https://lbqaq.top/p/swagger/","title":"Swagger3初体验"},{"content":"每次写完博客，需要在本地编译，然后再手动通过WinSCP送到服务器上。作为一个懒人，这上面几步下来还是觉得麻烦，而且每次编译又会生成一顿不需要的文件，于是便决定整点自动化的流程，直接解放双手。\n因为我的博客在没买服务器之前都是托管在Github上的，于是自然而然地就想到了Webhook，在每次Push后自动发送消息给服务器，让其自动拉取代码。\n网上的教程大多都是在本地编译，然而我觉得既然要懒，就一懒到底吧，编译也直接通过Github Actions来完成就行了。\n流程 需要2个Github仓库（1个应该也可以），一个存放网站的源码，一个是存放编译好的html文件。整个工作流程就如下图所示：\n 流程图 \n步骤 设置脚本 首先要写一个shell脚本，功能很简单就是自动拉取代码。\n#!/bin/bash cd /home/luobo/Blog git pull 创建webhook服务后端 这里就直接使用NodeJS来创建，使用的原因很简单，因为已经有现成的插件可以使用了。\n首先安装依赖\nnpm i -S github-webhook-handler npm i -g pm2 然后创建webhook.js作为后端\nvar http = require(\u0026#39;http\u0026#39;); var spawn = require(\u0026#39;child_process\u0026#39;).spawn; var createHandler = require(\u0026#39;github-webhook-handler\u0026#39;); //注意要将 secret 修改你自己的 var handler = createHandler({ path: \u0026#39;/webhook\u0026#39;, secret: \u0026#39;xxxxx\u0026#39; }); http.createServer(function (req, res) { handler(req, res, function (err) { res.statusCode = 404; res.end(\u0026#39;no such location\u0026#39;); }) }).listen(6666); handler.on(\u0026#39;error\u0026#39;, function (err) { console.error(\u0026#39;Error:\u0026#39;, err.message) }); handler.on(\u0026#39;push\u0026#39;, function (event) { console.log(\u0026#39;Received a push event for %s to %s\u0026#39;, event.payload.repository.name, event.payload.ref); runCommand(\u0026#39;sh\u0026#39;, [\u0026#39;./deploy.sh\u0026#39;], function( txt ){ console.log(txt); }); }); function runCommand( cmd, args, callback ){ var child = spawn( cmd, args ); var resp = \u0026#39;Deploy OK\u0026#39;; child.stdout.on(\u0026#39;data\u0026#39;, function( buffer ){ resp += buffer.toString(); }); child.stdout.on(\u0026#39;end\u0026#39;, function(){ callback( resp ) }); } 最后启动服务即可\npm2 start webhook.js Nginx设置反代 location /webhook { proxy_pass http://127.0.0.1:6666; } 配置Github Webhook 在 html仓库的 Settings - webhooks 设置中创建一个新的 webhook。\n将Content Type 设置为 application/json，secret 设置成与 webhook.js 中的相同。\ntrigeer选择Just the push event. 。\n完成后Github会自动发起一个测试请求，如果返回为200说明配置完成，\n配置自动编译 在源代码仓库的.github/workflows目录下创建deploy.yml，并填入以下内容。\nname:Build and Deployon:[push]# 任务jobs:build-and-deploy:# 服务器环境：最新版 Ubunturuns-on:ubuntu-lateststeps:# 拉取代码- name:Checkoutuses:actions/checkout@v2# 安装Hugo- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:latestextended:true- name:Build run:hugo# 部署到 GitHub Pages- name:Deploy to GitHub Pagesuses:JamesIves/github-pages-deploy-action@4.1.4with:BRANCH:mainFOLDER:publictoken:${{ secrets.GP_TOKEN }}repository-name:luoboQAQ/luoboQAQ.github.io注意要将最后的repository-name换为你自己的仓库，同时需要申请和配置Github Token，这里我就不展开了。\n参考  使用 GitHub Webhook 实现静态网站自动化部署  ","date":"2021-08-23T15:44:59+08:00","image":"https://lbqaq.top/p/%E4%BD%BF%E7%94%A8webhooks%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/90550307.webp","permalink":"https://lbqaq.top/p/%E4%BD%BF%E7%94%A8webhooks%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/","title":"使用Webhooks实现自动部署"},{"content":"一个完整的博客，怎么能少的了评论系统呢。评论的实现已经有许许多多的方法了，挑来挑去，还是选择了Waline。\n一开始我是采用官方推荐的LeanCloud+Vercel的方式进行部署的，结果步骤全部走完后才发现Vercel已经在国内被墙了，不科学根本上不去😇。总不能要求用户还要开梯子才能评论吧，所幸官方提供了其他的部署方式，因为我才买了自己的服务器~~（不榨干怎么行呢）~~，所以就选择本地部署+SQLlite的方式了。\n部署步骤 安装node.js 由于Waline的服务端是由js写的，所以需要安装node.js\n  在nodejs中文网找到需要的版本，选择阿里云镜像，将下载链接复制下来\n  连接服务器，选择nodejs的安装目录，这里我安装在/usr/local/bin/\ncd /usr/local/bin/   下载安装包到本地\nwget https://npm.taobao.org/mirrors/node/v14.17.5/node-v14.17.5-linux-x64.tar.gz   解压\ntar -xvf node-v14.17.5-linux-x64.tar.gz   重命名目录\nmv node-v14.17.5-linux-x64 nodejs   添加目录到系统变量\ncd /etc/profile.d vim custom.sh 在文件末尾添加export PATH=$PATH:/usr/local/bin/nodejs/bin\n  测试，输入下面3条命令，如果不报错则安装成功。\nnode -v npm version npx -v   （可选）安装cnpm\nnpm install -g cnpm --registry=https://registry.npm.taobao.org   安装Waline服务端   安装waline的服务端\nnpm install -g @waline/vercel   配置数据库。这里我采用的是SQLite，只需要下载 waline.sqlite 文件至合适的位置。\n其他的数据库可以看官方文档来配置。\n  配置环境变量。\n这里我选择新建waline.sh，方便日后维护。\ncd /etc/profile.d vim waline.sh export SQLITE_PATH=/home/luobo export JWT_TOKEN=eqdVMaEwd  SQLITE_PATH：表示SQLite文件的位置。 JWT_TOKEN：随机一串字符串就行。    启动模块\ncd /usr/local/bin/nodejs/lib node node_modules/@waline/vercel/vanilla.js   配置nginx反代 #waline server { listen 80; listen 443 ssl http2; server_name waline.lbqaq.top; if ($server_port !~ 443){ rewrite ^(/.*)$ https://$host$1 permanent; } ssl_certificate cert/waline.lbqaq.top.pem; ssl_certificate_key cert/waline.lbqaq.top.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { proxy_pass http://127.0.0.1:8360; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header REMOTE-HOST $remote_addr; add_header X-Cache $upstream_cache_status; # cache  add_header Cache-Control no-cache; expires 12h; } } 在hugo中启用Waline 由于我用的主题已经支持Waline评论，所以只需要填入serverURL就行了。\n添加QQ推送（可选） 官方提供了四种通知方法，分别为邮箱、微信、QQ、Telegram。\n邮箱基本不会去看，Telegram没科学也上不去，微信由于是走的Server酱，没有捐赠一天就支持5条消息。\n最终还是决定采用Qmsg 酱。\n注册就不在这展开了，具体写一下环境变量的配置。\ncd /etc/profile.d vim waline.sh export QMSG_KEY=xxxxxx export QQ_ID=xxxxxx export AUTHOR_EMAIL=xxxxxxx export SITE_NAME=Blog export SITE_URL=lbqaq.top 踩坑 本以为启用评论是一件很简单的事，结果花了整个下午加晚上，踩了好多好多坑。在这里就把我踩的坑记录下来，避免之后出现一样的问题。\n  npm install -g @waline/vercel报错\n使用cnpm进行安装\n  想使用lbqaq.top/waline/这样的链接来设置服务端\n直接报404错误，还是选择上文中的子域名方法\n  nginx提示没找到http2模块\n在安装nginx时加上--with-http_v2_module如果已经安装好了，可以重新安装一遍\n  设置了server_name waline.lbqaq.top还是跳转首页\n增加一个默认的server，将所有不匹配的链接阻止\nserver { listen 80 default_server; server_name _; return 444; }   nginx配置不生效\n如果配置没有问题，除了nginx -s reload还可以尝试重启nginx\n  参考链接  Waline官方文档 nginx中文文档  ","date":"2021-08-21T15:37:44+08:00","image":"https://lbqaq.top/p/waline/78502982.webp","permalink":"https://lbqaq.top/p/waline/","title":"为博客添加评论系统"},{"content":"SpringMVC也告一段落了，终于要到SpringBoot了。\n还是和之前一样，笔记是基于遇见狂神说的SpringMVC视频教程而来，在此感谢能提供这么优秀的教程。\n回顾MVC 什么是MVC  MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 将业务逻辑、数据、显示分离的方法来组织代码。  **Model（模型）：**数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。\n拓展：在前端数据传输给后端时，有些字段是不需要的，这是可能会细分出Vo层（视图）\n比如：用户有账号、密码、年龄等一系列字段\n这时前端登录只传了账号密码\n此时可以用UserVo来表示，里面只有账号和密码\n**View（视图）：**负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。\n**Controller（控制器）：**接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。\n最典型的MVC就是JSP + servlet + javabean的模式。\n 用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面  职责分析：\nController：控制器\n 取得表单数据 调用业务逻辑 转向指定的页面  Model：模型\n 业务逻辑 保存数据的状态  View：视图\n 显示页面  复习Servlet   父工程添加依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.13\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet.jsp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsp-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jstl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   编写Servlet\npublic class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取前端操作  String method = req.getParameter(\u0026#34;method\u0026#34;); if (method.equals(\u0026#34;add\u0026#34;)){ req.getSession().setAttribute(\u0026#34;msg\u0026#34;,\u0026#34;执行了add方法\u0026#34;); } if (method.equals(\u0026#34;delete\u0026#34;)){ req.getSession().setAttribute(\u0026#34;msg\u0026#34;,\u0026#34;执行了delete方法\u0026#34;); } //调用业务层  //视图转发或重定向  req.getRequestDispatcher(\u0026#34;/WEB-INF/jsp/test.jsp\u0026#34;).forward(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } }   编写test.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建test.jsp\n\u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ${msg} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   在web.xml中注册Servlet\n\u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;hello\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;top.lbqaq.servlet.HelloServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;hello\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/hello\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt;   配置TomCat，进行测试\n  MVC框架要做哪些事情\n 将url映射到java类或java类的方法 . 封装用户提交的数据 . 处理请求\u0026ndash;调用相关的业务处理\u0026ndash;封装响应数据 . 将响应的数据进行渲染 . jsp / html 等表示层数据 .  说明：\n​\t常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等\u0026hellip;.\n什么是SpringMVC 概述 Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。\n中文文档\n我们为什么要学习SpringMVC呢?\nSpring MVC的特点：\n 轻量级，简单易学 高效 , 基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 功能强大：RESTful、数据验证、格式化、本地化、主题等 简洁灵活  中心控制器 ​\tSpring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。\n​\tSpring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。\n DispatcherServlet \nSpringMVC的原理如下图所示：\n​\t当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。\n SpringMVC流程 \nSpringMVC执行原理  执行流程 \n图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。\n简要分析执行流程\n  DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。\n我们假设请求的url为 : http://localhost:8080/SpringMVC/hello\n如上url拆分成三部分：\nhttp://localhost:8080服务器域名\nSpringMVC部署在服务器上的web站点\nhello表示控制器\n通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。\n  HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。\n  HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。\n  HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。\n  HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。\n  Handler让具体的Controller执行。\n  Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。\n  HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。\n  DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。\n  视图解析器将解析的逻辑视图名传给DispatcherServlet。\n  DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。\n  最终视图呈现给用户。\n  这里比较绕，所以直接把原文搬来了，之后等理解加深了再来补充自己的看法。\n第一个SpringMVC程序 由于我们是采用子模块的方式，那么需要去IDEA里设置一下让lib会打包出去。否则就会提示404错误。\n在点击IDEA右上角的小齿轮，选择项目结构，在工件下看WEB-INF里是否有lib目录，没有的话就创建一个，然后点击+号，选择库文件将所有的包导入进去。\n配置版   准备要看的视图。在WEB-INF目录下创建jsp目录，在里面创建test.jsp，填入${msg}\n  配置SpringMVC。在web.xml里添加下面的代码。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;!--配置DispatchServlet：这是SpringMVC的核心：请求分发器、前端控制器--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--DispatchServlet要绑定Spring的配置文件--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--启动级别1：随服务器一起启动--\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 备注：/和/*的区别：/匹配所有请求，不匹配jsp页面；/*会匹配jsp页面，这样会导致嵌套，一般不会用\n  编写SpringMVC的配置文件springmvc-servlet.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--处理器映射器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\u0026#34;/\u0026gt; \u0026lt;!--处理器适配器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\u0026#34;/\u0026gt; \u0026lt;!--视图解析器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;!--前缀--\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34;/\u0026gt; \u0026lt;!--后缀--\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   实现Controller接口\npackage top.lbqaq.Controller; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class HelloController implements Controller { @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { ModelAndView mv = new ModelAndView(); //业务代码  String result = \u0026#34;HelloSpringMVC\u0026#34;; mv.addObject(\u0026#34;msg\u0026#34;,result); //视图跳转  mv.setViewName(\u0026#34;test\u0026#34;); return mv; } }   将Controller在Spring中注册(springmvc-servlet.xml)\n\u0026lt;!--BeanNameUrlHandlerMapping:按BeanName匹配--\u0026gt; \u0026lt;bean id=\u0026#34;/hello\u0026#34; class=\u0026#34;top.lbqaq.Controller.HelloController\u0026#34;/\u0026gt;   运行TomCat查看结果\n  然而正常开发并不会使用这样的方式，这样做只是为了理解底层的操作。_(:з)∠)_\n注解版   配置Web.xml\n\u0026lt;!--配置DispatchServlet：这是SpringMVC的核心：请求分发器、前端控制器--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--DispatchServlet要绑定Spring的配置文件--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--启动级别1：随服务器一起启动；越小级别越高--\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; 还是老样子，这里没有什么需要改动的。\n  在resources目录下添加SpringMVC配置文件springmvc-servlet.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\u0026#34;\u0026gt; \u0026lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;top.lbqaq.controller\u0026#34;/\u0026gt; \u0026lt;!-- 让Spring MVC不处理静态资源 --\u0026gt; \u0026lt;mvc:default-servlet-handler /\u0026gt; \u0026lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --\u0026gt; \u0026lt;mvc:annotation-driven /\u0026gt; \u0026lt;!-- 视图解析器 --\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;!-- 前缀 --\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34; /\u0026gt; \u0026lt;!-- 后缀 --\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   创建Controller\n@Controller public class HelloController { @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(Model model){ //封装数据  model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;Hello,SpringMVCAnnotation!\u0026#34;); return \u0026#34;hello\u0026#34;; //会被视图解析器处理  } }  @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。    创建视图层，在WEB-INF/jsp目录中创建hello.jsp\n\u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ${msg} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   运行TomCat查看结果\n  小结 实现步骤其实非常的简单：\n 新建一个web项目 导入相关jar包 编写web.xml , 注册DispatcherServlet 编写springmvc配置文件 接下来就是去创建对应的控制类 , controller 最后完善前端视图和controller之间的对应 测试运行调试.  使用springMVC必须配置的三大件：\n处理器映射器、处理器适配器、视图解析器\n通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置\nRestFul风格 概念\nRestful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。\n功能\n资源：互联网所有的事物都可以被抽象为资源\n资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。\n分别对应 添加、 删除、修改、查询。\n传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get\n​\thttp://127.0.0.1/item/queryItem.action?id=1 查询,GET\n​\thttp://127.0.0.1/item/saveItem.action 新增,POST\n​\thttp://127.0.0.1/item/updateItem.action 更新,POST\n​\thttp://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST\n使用RESTful操作资源 ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！\n​\thttp://127.0.0.1/item/1 查询,GET\n​\thttp://127.0.0.1/item 新增,POST\n​\thttp://127.0.0.1/item 更新,PUT\n​\thttp://127.0.0.1/item/1 删除,DELETE\n使用方法\n创建一个类RestFulController\n@Controller public class RestFulController { //原来的：localhost:8085/add?a=1\u0026amp;b=2  //Restful:localhost:8085/add/1/2  @RequestMapping(\u0026#34;/add/{a}/{b}\u0026#34;) public String test1(@PathVariable int a,@PathVariable int b, Model model){ int res = a+b; model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;结果为\u0026#34;+res); return \u0026#34;test\u0026#34;; } } @RequestMapping里面的{a}就代表这里是传给a变量的值；下面的a变量前要加@PathVariable\n使用路径变量的好处？\n 使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。  我们也可以进行方法约束，让其只响应某一种请求\n@GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping 拿@GetMapping来说，就是@RequestMapping(method =RequestMethod.GET)意思，如果使用其他的方法，将会报405错误。\n重定向和转发 重定向不需要视图解析器，本质就是重新请求一个新地方。\n可以重定向到另外一个请求实现。\n@Controller public class ResultSpringMVC2 { @RequestMapping(\u0026#34;/rsm2/t1\u0026#34;) public String test1(){ //转发  return \u0026#34;test\u0026#34;; } @RequestMapping(\u0026#34;/rsm2/t2\u0026#34;) public String test2(){ //重定向  return \u0026#34;redirect:/index.jsp\u0026#34;; //return \u0026#34;redirect:hello.do\u0026#34;; //hello.do为另一个请求/  } } 数据处理 处理提交数据 1、提交的域名称和处理方法的参数名一致\n提交数据 : http://localhost:8080/hello?name=lbqaq\n处理方法 :\n@RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(String name){ System.out.println(name); return \u0026#34;hello\u0026#34;; } 后台输出 : lbqaq\n2、提交的域名称和处理方法的参数名不一致\n提交数据 : http://localhost:8080/hello?username=lbqaq\n处理方法 :\n//@RequestParam(\u0026#34;username\u0026#34;) : username提交的域的名称 . @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(@RequestParam(\u0026#34;username\u0026#34;) String name){ System.out.println(name); return \u0026#34;hello\u0026#34;; } 后台输出 : lbqaq\n3、提交的是一个对象\n要求提交的表单域和对象的属性名一致 , 参数使用对象即可\n1、实体类\npublic class User { private int id; private String name; private int age; //构造  //get/set  //tostring() } 2、提交数据 : http://localhost:8080/mvc04/user?name=lbqaq\u0026amp;id=1\u0026amp;age=15\n3、处理方法 :\n@RequestMapping(\u0026#34;/user\u0026#34;) public String user(User user){ System.out.println(user); return \u0026#34;hello\u0026#34;; } 后台输出 : User { id=1, name=\u0026lsquo;lbqaq\u0026rsquo;, age=15 }\n说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。\n数据显示到前端 第一种 : 通过ModelAndView\n我们前面一直都是如此 . 就不过多解释\npublic class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象  ModelAndView mv = new ModelAndView(); mv.addObject(\u0026#34;msg\u0026#34;,\u0026#34;ControllerTest1\u0026#34;); mv.setViewName(\u0026#34;test\u0026#34;); return mv; } } 第二种 : 通过ModelMap\nModelMap\n@RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(@RequestParam(\u0026#34;username\u0026#34;) String name, ModelMap model){ //封装要显示到视图中的数据  //相当于req.setAttribute(\u0026#34;name\u0026#34;,name);  model.addAttribute(\u0026#34;name\u0026#34;,name); System.out.println(name); return \u0026#34;hello\u0026#34;; } 第三种 : 通过Model\nModel\n@RequestMapping(\u0026#34;/ct2/hello\u0026#34;) public String hello(@RequestParam(\u0026#34;username\u0026#34;) String name, Model model){ //封装要显示到视图中的数据  //相当于req.setAttribute(\u0026#34;name\u0026#34;,name);  model.addAttribute(\u0026#34;msg\u0026#34;,name); System.out.println(name); return \u0026#34;test\u0026#34;; } 对比 就对于新手而言简单来说使用区别就是：\n Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解； ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性； ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。  当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。\n这里都是概念性的内容，所以就直接复制笔记了😌\n解决乱码 直接把Spring的乱码处理器放入web.xml里\n\u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; JSON  JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。  使用Jackson   导入依赖\n\u0026lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.12.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   编写Controller\n@Controller public class UserController { @RequestMapping(\u0026#34;/json1\u0026#34;) @ResponseBody public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据  ObjectMapper mapper = new ObjectMapper(); //创建一个对象  User user = new User(\u0026#34;小明\u0026#34;, 3, \u0026#34;男\u0026#34;); //将我们的对象解析成为json格式  String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便  return str; } 如果出现乱码，可以指定编码格式为UTF8来解决\n@RequestMapping(value = \u0026quot;/json1\u0026quot;,produces = \u0026quot;application/json;charset=utf-8\u0026quot;)\n  这样处理乱码还是太麻烦了，可以让Spring统一管理，在SpringMVC的配置文件里加上下面的代码。\n\u0026lt;mvc:annotation-driven\u0026gt; \u0026lt;mvc:message-converters register-defaults=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.StringHttpMessageConverter\u0026#34;\u0026gt; \u0026lt;constructor-arg value=\u0026#34;UTF-8\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;objectMapper\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;failOnEmptyBeans\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt; 在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！\n@RestController public class UserController { //produces:指定响应体返回类型和编码  @RequestMapping(value = \u0026#34;/json1\u0026#34;) public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据  ObjectMapper mapper = new ObjectMapper(); //创建一个对象  User user = new User(\u0026#34;小明\u0026#34;, 3, \u0026#34;男\u0026#34;); //将我们的对象解析成为json格式  String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便  return str; } } 自定义工具类，可以是JSON转换变得更简单\npublic class JsonUtils { public static String getJson(Object object) { return getJson(object,\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); } public static String getJson(Object object,String dateFormat) { ObjectMapper mapper = new ObjectMapper(); //不使用时间差的方式  mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象  SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //指定日期格式  mapper.setDateFormat(sdf); try { return mapper.writeValueAsString(object); } catch (JsonProcessingException e) { e.printStackTrace(); } return null; } } 使用FastJson \u0026lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.78\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 为了使@RestController有效，需要在Spring配置里加上下面的内容\n\u0026lt;mvc:annotation-driven\u0026gt; \u0026lt;mvc:message-converters register-defaults=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;!-- 配置Fastjson支持 --\u0026gt; \u0026lt;bean class=\u0026#34;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;supportedMediaTypes\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;application/json\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;text/html;charset=UTF-8\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt; fastjson 三个主要的类：\nJSONObject 代表 json 对象\n JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。 JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取\u0026quot;键：值\u0026quot;对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。  JSONArray 代表 json 对象数组\n 内部是有List接口中的方法来完成操作的。  JSON代表 JSONObject和JSONArray的转化\n JSON类源码分析与使用 仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。  测试代码\npublic class FastJsonDemo { public static void main(String[] args) { //创建一个对象  User user1 = new User(\u0026#34;1号\u0026#34;, 3, \u0026#34;男\u0026#34;); User user2 = new User(\u0026#34;2号\u0026#34;, 3, \u0026#34;男\u0026#34;); User user3 = new User(\u0026#34;3号\u0026#34;, 3, \u0026#34;男\u0026#34;); User user4 = new User(\u0026#34;4号\u0026#34;, 3, \u0026#34;男\u0026#34;); List\u0026lt;User\u0026gt; list = new ArrayList\u0026lt;User\u0026gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); System.out.println(\u0026#34;*******Java对象 转 JSON字符串*******\u0026#34;); String str1 = JSON.toJSONString(list); System.out.println(\u0026#34;JSON.toJSONString(list)==\u0026gt;\u0026#34;+str1); String str2 = JSON.toJSONString(user1); System.out.println(\u0026#34;JSON.toJSONString(user1)==\u0026gt;\u0026#34;+str2); System.out.println(\u0026#34;\\n****** JSON字符串 转 Java对象*******\u0026#34;); User jp_user1=JSON.parseObject(str2,User.class); System.out.println(\u0026#34;JSON.parseObject(str2,User.class)==\u0026gt;\u0026#34;+jp_user1); System.out.println(\u0026#34;\\n****** Java对象 转 JSON对象 ******\u0026#34;); JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2); System.out.println(\u0026#34;(JSONObject) JSON.toJSON(user2)==\u0026gt;\u0026#34;+jsonObject1.getString(\u0026#34;name\u0026#34;)); System.out.println(\u0026#34;\\n****** JSON对象 转 Java对象 ******\u0026#34;); User to_java_user = JSON.toJavaObject(jsonObject1, User.class); System.out.println(\u0026#34;JSON.toJavaObject(jsonObject1, User.class)==\u0026gt;\u0026#34;+to_java_user); } } Jackson刚刚测试没成功，还是选择FastJson吧😇。\n拦截器 概述 SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。\n**过滤器与拦截器的区别：**拦截器是AOP思想的具体应用。\n过滤器\n servlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截  拦截器\n 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的  使用方法   自定义拦截器需要实现接口HandlerInterceptor\npublic class MyInterceptor implements HandlerInterceptor { //在请求处理的方法之前执行  //如果返回true执行下一个拦截器  //如果返回false就不执行下一个拦截器  public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception { System.out.println(\u0026#34;------------处理前------------\u0026#34;); return true; } //在请求处理方法执行之后执行  public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;------------处理后------------\u0026#34;); } //在dispatcherServlet处理后执行,做清理工作.  public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception { System.out.println(\u0026#34;------------清理------------\u0026#34;); } }   在springmvc的配置文件中配置拦截器\n\u0026lt;!--关于拦截器的配置--\u0026gt; \u0026lt;mvc:interceptors\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;!--/** 包括路径及其子路径--\u0026gt; \u0026lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--\u0026gt; \u0026lt;!--/admin/** 拦截的是/admin/下的所有--\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/**\u0026#34;/\u0026gt; \u0026lt;!--bean配置的就是拦截器--\u0026gt; \u0026lt;bean class=\u0026#34;top.lbqaq.interceptor.MyInterceptor\u0026#34;/\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;/mvc:interceptors\u0026gt;   执行顺序如下：\n------------处理前------------ Controller方法 ------------处理后------------ ------------清理------------ 拦截器可以用来做登录验证等等内容，这里就不展开了（才不是懒得写）\n文件传输 文件上传是项目开发中最常见的功能之一 ,springMVC 可以很好的支持文件上传，但是SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。\n前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器；\n对表单中的 enctype 属性做个详细的说明：\n application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。 multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。 text/plain：除了把空格转换为 \u0026ldquo;+\u0026rdquo; 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。  \u0026lt;form action=\u0026#34;\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 文件上传   导入依赖包\n\u0026lt;!--文件上传--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-fileupload\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-fileupload\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--servlet-api导入高版本的--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   配置multipartResolver\n这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！\n\u0026lt;!--文件上传配置--\u0026gt; \u0026lt;bean id=\u0026#34;multipartResolver\u0026#34; class=\u0026#34;org.springframework.web.multipart.commons.CommonsMultipartResolver\u0026#34;\u0026gt; \u0026lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --\u0026gt; \u0026lt;property name=\u0026#34;defaultEncoding\u0026#34; value=\u0026#34;utf-8\u0026#34;/\u0026gt; \u0026lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --\u0026gt; \u0026lt;property name=\u0026#34;maxUploadSize\u0026#34; value=\u0026#34;10485760\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;maxInMemorySize\u0026#34; value=\u0026#34;40960\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   编写前端页面\n\u0026lt;form action=\u0026#34;/upload\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;upload\u0026#34;\u0026gt; \u0026lt;/form\u0026gt;   配置Controller\npackage com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.multipart.commons.CommonsMultipartFile; import javax.servlet.http.HttpServletRequest; import java.io.*; @Controller public class FileController { //@RequestParam(\u0026#34;file\u0026#34;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象  //批量上传CommonsMultipartFile则为数组即可  @RequestMapping(\u0026#34;/upload\u0026#34;) public String fileUpload(@RequestParam(\u0026#34;file\u0026#34;) CommonsMultipartFile file , HttpServletRequest request) throws IOException { //获取文件名 : file.getOriginalFilename();  String uploadFileName = file.getOriginalFilename(); //如果文件名为空，直接回到首页！  if (\u0026#34;\u0026#34;.equals(uploadFileName)){ return \u0026#34;redirect:/index.jsp\u0026#34;; } System.out.println(\u0026#34;上传文件名 : \u0026#34;+uploadFileName); //上传路径保存设置  String path = request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;); //如果路径不存在，创建一个  File realPath = new File(path); if (!realPath.exists()){ realPath.mkdir(); } System.out.println(\u0026#34;上传文件保存地址：\u0026#34;+realPath); InputStream is = file.getInputStream(); //文件输入流  OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流  //读取写出  int len=0; byte[] buffer = new byte[1024]; while ((len=is.read(buffer))!=-1){ os.write(buffer,0,len); os.flush(); } os.close(); is.close(); return \u0026#34;redirect:/index.jsp\u0026#34;; } }   方法二：使用file.Transto 来保存上传的文件\n/* * 采用file.Transto 来保存上传的文件 */ @RequestMapping(\u0026#34;/upload2\u0026#34;) public String fileUpload2(@RequestParam(\u0026#34;file\u0026#34;) CommonsMultipartFile file, HttpServletRequest request) throws IOException { //上传路径保存设置  String path = request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;); File realPath = new File(path); if (!realPath.exists()){ realPath.mkdir(); } //上传文件地址  System.out.println(\u0026#34;上传文件保存地址：\u0026#34;+realPath); //通过CommonsMultipartFile的方法直接写文件（注意这个时候）  file.transferTo(new File(realPath +\u0026#34;/\u0026#34;+ file.getOriginalFilename())); return \u0026#34;redirect:/index.jsp\u0026#34;; } 文件下载 @RequestMapping(value=\u0026#34;/download\u0026#34;) public String downloads(HttpServletResponse response ,HttpServletRequest request) throws Exception{ //要下载的图片地址  String path = request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;); String fileName = \u0026#34;基础语法.jpg\u0026#34;; //1、设置response 响应头  response.reset(); //设置页面不缓存,清空buffer  response.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); //字符编码  response.setContentType(\u0026#34;multipart/form-data\u0026#34;); //二进制传输数据  //设置响应头  response.setHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment;fileName=\u0026#34;+URLEncoder.encode(fileName, \u0026#34;UTF-8\u0026#34;)); File file = new File(path,fileName); //2、 读取文件--输入流  InputStream input=new FileInputStream(file); //3、 写出文件--输出流  OutputStream out = response.getOutputStream(); byte[] buff =new byte[1024]; int index=0; //4、执行 写出操作  while((index= input.read(buff))!= -1){ out.write(buff, 0, index); out.flush(); } out.close(); input.close(); return null; } 或者直接用a标签\n\u0026lt;a href=\u0026quot;/1.jpg\u0026quot;\u0026gt;点击下载\u0026lt;/a\u0026gt;\n","date":"2021-08-15T09:06:00+08:00","image":"https://lbqaq.top/p/springmvc/65411813.webp","permalink":"https://lbqaq.top/p/springmvc/","title":"SpringMVC学习笔记"},{"content":"花了3天时间，Spring也终于看完了,SSM已经干完了两个了，感觉人都要没了😇。还是老样子，留下笔记以免遗忘。\n下面的内容都是基于遇见狂神说的Spring5视频教程而来，在此感谢能提供这么优秀的教程。\nSpring 简介 Spring就是用来简化Java开发的，只能说学Java不学Spring，就像读四大名著不读红楼梦\u0026hellip;\u0026hellip;\n2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。\n2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。\n很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。\nSpring理念 : 使现有技术更加实用。 本身就是一个大杂烩 , 整合现有的框架技术。\nSSM：SpringMVC+Spring+MyBatis\n几个常用的网址：\n  官网\n  官方文档（英文）\n  中文文档\n  GitHub\n  \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 优点   Spring是一个开源免费的框架 , 容器\n  Spring是一个轻量级的框架 , 非侵入式的\n  控制反转（IoC）,面向切面（Aop）\n  对事务的支持 , 对框架的支持\n  一句话概括：\n Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。\n 拓展  Spring Boot  一套快速配置脚手架 可以基于Spring Boot 快速开发单个微服务   Spring Cloud  Spring Cloud是基于Spring Boot实现的    学习路线：Spring -\u0026gt; SpringMVC -\u0026gt; Spring Boot -\u0026gt; Spring Cloud\nIOC理论推导 原先的开发模式：\n  先写一个UserDao接口\npublic interface UserDao { public void getUser(); }   再去写Dao的实现类\npublic class UserDaoImpl implements UserDao { @Override public void getUser() { System.out.println(\u0026#34;获取用户数据\u0026#34;); } }   然后去写UserService的接口\npublic interface UserService { public void getUser(); }   最后写Service的实现类\npublic class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoImpl(); @Override public void getUser() { userDao.getUser(); } }   测试一下\n@Test public void test(){ //用户实际调用的是业务层，dao层他们并不需要接触！  UserService service = new UserServiceImpl(); service.getUser(); }   如果需要更换Dao层的实现方法，每次都需要在UserServiceImpl里手动修改new的对象，这样做十分麻烦。\n现在可以使用set接口实现\npublic class UserServiceImpl implements UserService { private UserDao userDao; // 利用set进行动态实现值的注入  public void setUserDao(UserDao userDao) { this.userDao = userDao; } @Override public void getUser() { userDao.getUser(); } }  以前所有东西都是由程序去进行控制创建。 而现在是由我们自行控制创建对象，把主动权交给了调用者。程序不用去管怎么创建,怎么实现了，它只负责提供一个接口。  这种思想，从本质上解决了问题，我们程序员不再去管理对象的创建了，更多的去关注业务的实现。耦合性大大降低， 这也就是IOC的原型！\nIOC本质 控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。\n IoC图示 \nSpring的工作原理：\n container magic \n 控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。\n 第一个Spring程序   添加Maven依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   在pojo包下创建实体类Hello\npackage top.lbqaq.pojo; /** * @author luoboQAQ * @Date 2021/8/12 上午 10:49 */ public class Hello { private String str; public String getStr() { return str; } public void setStr(String str) { this.str = str; } @Override public String toString() { return \u0026#34;Hello{\u0026#34; + \u0026#34;str=\u0026#39;\u0026#34; + str + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } }   在resources目录下编写Spring的配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--bean就是java对象 , 由Spring创建和管理 原来是 类型 变量名 = new 类型(); Hello hello = new Hello(); 现在 id=变量名 class=new的对象 property是给变量赋的初值 --\u0026gt; \u0026lt;bean id=\u0026#34;hello\u0026#34; class=\u0026#34;top.lbqaq.pojo.Hello\u0026#34;\u0026gt; \u0026lt;!--引用另外一个bean , 不是用value 而是用 ref--\u0026gt; \u0026lt;property name=\u0026#34;str\u0026#34; value=\u0026#34;Spring\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   进行测试\nimport org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import top.lbqaq.pojo.Hello; /** * @author luoboQAQ * @Date 2021/8/12 上午 10:53 */ public class MyTest { public static void main(String[] args) { //获取Spring的上下文对象  ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); //我们的对象都在Spring中管理了，我们要使用直接从中取即可  Hello hello = (Hello) context.getBean(\u0026#34;hello\u0026#34;); System.out.println(hello); } }   现在Hello对象由Spring来创建和管理，这个过程就叫控制反转\n  控制：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring后，对象是由Spring来创建的。\n  反转：程序本身不创建对象，而变成被动的接收对象。\n  依赖注入：就是利用set方法来进行注入的。\nIOC是一种编程思想，由主动的编程变成被动的接收。\nIOC创建对象方式   通过无参构造函数（默认）\n  通过有参构造函数，有三种方式\n  下标赋值\n\u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   用类型赋值（不推荐）\n\u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg type=\u0026#34;java.lang.String\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   通过参数名创建\n\u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;     在配置文件加载的时候，其中管理的对象都已经初始化了！\nSpring配置 别名（alias） \u0026lt;!--设置别名：在获取Bean的时候可以使用别名获取--\u0026gt; \u0026lt;alias name=\u0026#34;user\u0026#34; alias=\u0026#34;userNew\u0026#34;/\u0026gt; Bean的配置 \u0026lt;!--bean就是java对象,由Spring创建和管理--\u0026gt; \u0026lt;!-- id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符 如果配置id,又配置了name,那么name是别名 name可以设置多个别名,可以用逗号,分号,空格隔开 如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象; class是bean的全限定名=包名+类名 --\u0026gt; \u0026lt;bean id=\u0026#34;hello\u0026#34; name=\u0026#34;hello2 h2,h3;h4\u0026#34; class=\u0026#34;top.lbqaq.pojo.Hello\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Spring\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; import 一般用于团队开发，将多个配置文件合为一个配置文件applicationContext.xml\n\u0026lt;import resource=\u0026#34;{path}/beans.xml\u0026#34;/\u0026gt; 依赖注入 概念  依赖注入（Dependency Injection,DI）。 依赖 : 指Bean对象的创建依赖于容器，Bean对象的依赖资源。 注入 : 指Bean对象所依赖的资源，由容器来设置和装配。  构造器注入 见前面的IOC创建对象方式\nset注入【重点】 测试环境 public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } public class Student { private String name; private Address address; private String[] books; private List\u0026lt;String\u0026gt; hobbys; private Map\u0026lt;String,String\u0026gt; card; private Set\u0026lt;String\u0026gt; games; private String wife; private Properties info; } xml编写 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;address\u0026#34; class=\u0026#34;top.lbqaq.pojo.Address\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; value=\u0026#34;西安\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;student\u0026#34; class=\u0026#34;top.lbqaq.pojo.Student\u0026#34;\u0026gt; \u0026lt;!--普通值注入，value--\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;!--Bean注入，ref--\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; ref=\u0026#34;address\u0026#34;/\u0026gt; \u0026lt;!--数组注入--\u0026gt; \u0026lt;property name=\u0026#34;books\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;红楼梦\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;西游记\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;水浒传\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;三国演义\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--list--\u0026gt; \u0026lt;property name=\u0026#34;hobbys\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;听歌\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;看电影\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;打游戏\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--map--\u0026gt; \u0026lt;property name=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;身份证\u0026#34; value=\u0026#34;112233445566778899\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;银行卡\u0026#34; value=\u0026#34;123987879172197\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Set--\u0026gt; \u0026lt;property name=\u0026#34;games\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;LOL\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;CSGO\u0026lt;/value\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--null--\u0026gt; \u0026lt;property name=\u0026#34;wife\u0026#34;\u0026gt; \u0026lt;null/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Properties--\u0026gt; \u0026lt;property name=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;driver\u0026#34;\u0026gt;20211213\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;url\u0026#34;\u0026gt;女\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;username\u0026#34;\u0026gt;root\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;password\u0026#34;\u0026gt;123456\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 具体用法见上面的代码就行了。\n扩展方式注入 p命名空间   导入命名空间\nxmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34;   在bean标签里直接使用\n\u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34; p:age=\u0026#34;18\u0026#34; p:name=\u0026#34;小明\u0026#34;/\u0026gt;   相当于set注入\nc命名空间   导入命名空间\nxmlns:c=\u0026#34;http://www.springframework.org/schema/c\u0026#34;   在bean标签里直接使用\n\u0026lt;bean id=\u0026#34;user2\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34; c:age=\u0026#34;20\u0026#34; c:name=\u0026#34;小红\u0026#34;/\u0026gt;   相当于有参构造函数注入\nBean的作用域    类别 说明     singleton (默认)将每个 Spring IoC 容器的单个 bean 定义范围限定为单个对象实例。   prototype 将单个 bean 定义的作用域限定为任意数量的对象实例。   request 将单个 bean 定义的范围限定为单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有一个在单个 bean 定义后面创建的 bean 实例。仅在可感知网络的 Spring ApplicationContext中有效。   session 将单个 bean 定义的范围限定为 HTTP Session的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。   application 将单个 bean 定义的范围限定为ServletContext的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。   websocket 将单个 bean 定义的范围限定为WebSocket的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。      单例模式（默认）：每次获取的都是同一个对象\n\u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34; p:age=\u0026#34;18\u0026#34; p:name=\u0026#34;小明\u0026#34; scope=\u0026#34;singleton\u0026#34;/\u0026gt;   原型模式：每次get都是从容器中产生一个新对象\n\u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34; p:age=\u0026#34;18\u0026#34; p:name=\u0026#34;小明\u0026#34; scope=\u0026#34;prototype\u0026#34;/\u0026gt;   其余request、session、application、websocket这些只在web开发中使用。\n  Bean的自动装配  自动装配是使用spring满足bean依赖的一种方法 spring会在应用上下文中为某个bean寻找其依赖的bean。  Spring中bean有三种装配机制，分别是：\n 在xml中显式配置 在java中显式配置 隐式的bean发现机制和自动装配【重要】  环境搭建 public class Cat { public void shout(){ System.out.println(\u0026#34;miao~\u0026#34;); } } public class Dog { public void shout(){ System.out.println(\u0026#34;wang~\u0026#34;); } } public class People { private Cat cat; private Dog dog; private String name; public Cat getCat() { return cat; } public void setCat(Cat cat) { this.cat = cat; } public Dog getDog() { return dog; } public void setDog(Dog dog) { this.dog = dog; } public String getName() { return name; } public void setName(String name) { this.name = name; } } ByName自动装配 \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;top.lbqaq.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;top.lbqaq.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;people\u0026#34; class=\u0026#34;top.lbqaq.pojo.People\u0026#34; autowire=\u0026#34;byName\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 会自动在容器上下文中查找，和自己对象set方法后面的值相对应的beanid\nByType自动装配 \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;top.lbqaq.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;top.lbqaq.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;people\u0026#34; class=\u0026#34;top.lbqaq.pojo.People\u0026#34; autowire=\u0026#34;byType\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 自动在容器上下文中查找，和自己对象属性类型相同的Bean\n小结：\n byname要保证所有的bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致 bytype的时候，需要保证bean的class唯一，并且这个bean需要和自动注入的属性的类型一致  使用注解自动装配 准备工作   导入aop包\n  导入约束\nxmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd   配置注解支持\u0026lt;context:annotation-config/\u0026gt;\n  @Autowired   在属性或在set方法上使用。\n  使用Autowired可以不需要set方法。\n  @Autowired是按类型自动转配的。\n  @Autowired(required=false) 说明对象可以为null\n  @Qualifier   如果环境比较复杂，自动装配无法通过一个@Autowired完成，可以通过@Qualifier(value=\u0026quot;xxx\u0026quot;)来实现。\n  @Qualifier相当于byName\n  @Autowired @Qualifier(value = \u0026#34;cat2\u0026#34;) private Cat cat; @Autowired @Qualifier(value = \u0026#34;dog2\u0026#34;) private Dog dog; @Resource  @Resource如有指定的name属性，先按该属性进行byName方式查找装配； 其次再进行默认的byName方式进行装配； 如果以上都不成功，则按byType的方式自动装配。 都不成功，则报异常。  public class User { //如果允许对象为null，设置required = false,默认为true  @Resource(name = \u0026#34;cat2\u0026#34;) private Cat cat; @Resource private Dog dog; private String str; } 小结 @Autowired与@Resource异同：\n  @Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。\n  @Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用\n  @Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。\n  它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。\n使用注解开发 使用注解开发需要导入aop的包，导入约束和配置注解支持\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--指定要扫描的包，这个包下的注解就会生效--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;top.lbqaq.pojo\u0026#34;/\u0026gt; \u0026lt;context:annotation-config/\u0026gt; \u0026lt;/beans\u0026gt; Bean的实现 @Component public class User { public String name = \u0026#34;小明\u0026#34;; } 使用@Component注解，相当于配置文件中的\u0026lt;bean id=\u0026quot;user\u0026quot; class=\u0026quot;当前注解的类\u0026quot;/\u0026gt;\n注意需要在配置文件中指定要扫描的包\u0026lt;context:component-scan base-package=\u0026quot;top.lbqaq.pojo\u0026quot;/\u0026gt;\n属性注入 使用@Value注解，相当于配置文件中的\u0026lt;property name=\u0026quot;name\u0026quot; value=\u0026quot;小明\u0026quot;/\u0026gt;\n可以在声明上加，也可以在set方法上加\n@Component public class User { @Value(\u0026#34;小明\u0026#34;) public String name; } @Component public class User { public String name; @Value(\u0026#34;小明\u0026#34;) public void setName(String name) { this.name = name; } } 衍生注解 对于@Component注解，有三个衍生注解，分别对应MVC的三层。\n Dao层：@Repository Service层：@Service Web层：@Controller  这四个注解的作用都是代表将某个类注册到Spring中，装配Bean\n自动装配注解  @Autowired：按类型自动转配 @Qualifier(value=\u0026quot;xxx\u0026quot;)：按name自动装配 @Resource：Java提供的，先name再type，比较复杂  详细的解释可以看上面\n作用域 @Scope\n singleton：单例模式 prototype：多例模式  @Component @Scope(\u0026#34;prototype\u0026#34;) public class User { @Value(\u0026#34;小明\u0026#34;) public String name; } 小结 XML与注解比较\n XML可以适用任何场景 ，结构清晰，维护方便 注解不是自己提供的类使用不了，开发简单方便  推荐用法\n xml管理Bean 注解完成属性注入  使用Java类进行配置 实体类\npublic class User { private String name; @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } public String getName() { return name; } @Value(\u0026#34;小明\u0026#34;) public void setName(String name) { this.name = name; } } 配置类\n@Configuration public class LbqaqConfig { @Bean public User getUser(){ return new User(); } } 这里的@Configuration表明这是Spring的配置\n@Bean是用来注册bean，这里的返回值就Bean的类型，方法名就是bean的id\n测试\npublic class MyTest { @Test public void test1(){ ApplicationContext context = new AnnotationConfigApplicationContext(LbqaqConfig.class); User user = (User) context.getBean(\u0026#34;getUser\u0026#34;); System.out.println(user.getName()); } } 代理模式 AOP的底层机制就是动态代理。\n静态代理 角色分析\n 抽象角色：一般使用接口或者抽象类来实现 真实角色：被代理的角色 代理角色：代理真实角色。代理真实角色后 , 一般会做一些附属的操作。 客户：使用代理角色来进行一些操作。  举例：\nRent.java即抽象角色\n//抽象角色：租房 public interface Rent { public void rent(); } Host.java即真实角色\n//真实角色: 房东，房东要出租房子 public class Host implements Rent{ public void rent() { System.out.println(\u0026#34;房屋出租\u0026#34;); } } Proxy.java即代理角色\n//代理角色：中介 public class Proxy implements Rent { private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } //租房  public void rent(){ seeHouse(); host.rent(); fare(); } //看房  public void seeHouse(){ System.out.println(\u0026#34;带房客看房\u0026#34;); } //收中介费  public void fare(){ System.out.println(\u0026#34;收中介费\u0026#34;); } } Client.java即客户\n//客户类，一般客户都会去找代理！ public class Client { public static void main(String[] args) { //房东要租房  Host host = new Host(); //中介帮助房东  Proxy proxy = new Proxy(host); //你去找中介！  proxy.rent(); } } 分析：\n在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式。\n静态代理的好处:\n 可以使得我们的真实角色更加纯粹，不再去关注一些公共的事情。 公共的业务由代理来完成，实现了业务的分工。 公共业务发生扩展时变得更加集中和方便。  缺点：\n 类多了，多了代理类，工作量变大了，开发效率降低。  我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想。\n AOP \n动态代理   动态代理的角色和静态代理的一样。\n  动态代理的代理类是动态生成的，静态代理的代理类是我们提前写好的\n  动态代理分为两类：一类是基于接口动态代理，一类是基于类的动态代理\n   基于接口的动态代理\u0026mdash;-JDK动态代理 基于类的动态代理\u0026ndash;cglib 现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist 我们这里使用JDK的原生代码来实现，其余的道理都是一样的！    JDK的动态代理需要了解两个类\n核心 : InvocationHandler、Proxy\n代码实现：\n//租房 public interface Rent { void rent(); } //房东 public class Host implements Rent { @Override public void rent() { System.out.println(\u0026#34;房东要出租\u0026#34;); } } public class ProxyInvocationHandler implements InvocationHandler { //被代理的接口  private Rent rent; public void setRent(Rent rent) { this.rent = rent; } //生成得到的代理类  public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(),rent.getClass().getInterfaces(),this); } @Override //处理代理实例，并返回结果  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //动态代理就是依赖反射实现  Object result = method.invoke(rent, args); return result; } } public class Client { public static void main(String[] args) { //真实角色  Host host=new Host(); ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setRent(host); Rent proxy = (Rent) pih.getProxy(); proxy.rent(); } } 动态代理代理接口\n通用的代码\npublic class ProxyInvocationHandler implements InvocationHandler { private Object target; public void setTarget(Object target) { this.target = target; } //生成代理类  public Object getProxy() { return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); } // proxy : 代理类  // method : 代理类的调用处理程序的方法对象.  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { log(method.getName()); Object result = method.invoke(target, args); return result; } public void log(String methodName) { System.out.println(\u0026#34;执行了\u0026#34; + methodName + \u0026#34;方法\u0026#34;); } } AOP 什么是AOP AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n AOP \n 通俗点说，就是在不改变原有代码的情况下去增加新的功能。\n AOP在Spring中 提供声明式事务；允许用户自定义切面\n 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 \u0026hellip;. 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 目标（Target）：被通知对象。 代理（Proxy）：向目标对象应用通知之后创建的对象。 切入点（PointCut）：切面通知 执行的 “地点”的定义。 连接点（JointPoint）：与切入点匹配的执行点。   2 \nSpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice：\n Advice \n使用Spring实现AOP 导入依赖包\n\u0026lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.7\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 方式一：使用Spring的方法 业务接口和实现类\npublic interface UserService { void add(); void delete(); void update(); void select(); } public class UserServiceImpl implements UserService{ @Override public void add() { System.out.println(\u0026#34;增加一个用户\u0026#34;); } @Override public void delete() { System.out.println(\u0026#34;删除一个用户\u0026#34;); } @Override public void update() { System.out.println(\u0026#34;更新一个用户\u0026#34;); } @Override public void select() { System.out.println(\u0026#34;查询一个用户\u0026#34;); } } 写两个增强类\npublic class Log implements MethodBeforeAdvice { //method : 要执行的目标对象的方法  //objects : 被调用的方法的参数  //o : 目标对象  @Override public void before(Method method, Object[] objects, Object o) throws Throwable { System.out.println(o.getClass().getName()+\u0026#34;的\u0026#34;+method.getName()+\u0026#34;被执行了\u0026#34;); } } public class AfterLog implements AfterReturningAdvice { //o:返回值  @Override public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable { System.out.println(\u0026#34;执行了\u0026#34;+method.getName()+\u0026#34;方法，返回结果为\u0026#34;+o); } } 配置xml，这里需要引入aop命名空间\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;!--注册Bean--\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;top.lbqaq.service.UserServiceImpl\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;log\u0026#34; class=\u0026#34;top.lbqaq.log.Log\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;afterLog\u0026#34; class=\u0026#34;top.lbqaq.log.AfterLog\u0026#34;/\u0026gt; \u0026lt;!--配置aop：需要导入aop约束--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--切入点：expression：表达式 execution()--\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;pointcut\u0026#34; expression=\u0026#34;execution(* top.lbqaq.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt; \u0026lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;log\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;afterLog\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt; execution表达式解析：\n execution(修饰符 返回值 包名.类名/接口名.方法名(参数列表)) 修饰符可以忽略 (..)可以代表所有参数,(*)代表一个参数,(*,String)代表第一个参数为任何值,第二个参数为String类型  最后测试\npublic class MyTest { @Test public void test(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); UserService userService = (UserService) context.getBean(\u0026#34;userService\u0026#34;); userService.select(); } } 方法二：使用自定义类来实现 创建自定义类\npublic class DiyPointCut { public void before(){ System.out.println(\u0026#34;==========方法执行前==========\u0026#34;); } public void after(){ System.out.println(\u0026#34;==========方法执行后==========\u0026#34;); } } 配置xml\n\u0026lt;bean id=\u0026#34;diy\u0026#34; class=\u0026#34;top.lbqaq.diy.DiyPointCut\u0026#34;/\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--自定义切面，ref为要引用的类--\u0026gt; \u0026lt;aop:aspect ref=\u0026#34;diy\u0026#34;\u0026gt; \u0026lt;!--切入点--\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;point\u0026#34; expression=\u0026#34;execution(* top.lbqaq.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt; \u0026lt;!--通知--\u0026gt; \u0026lt;aop:before method=\u0026#34;before\u0026#34; pointcut-ref=\u0026#34;point\u0026#34;/\u0026gt; \u0026lt;aop:after method=\u0026#34;after\u0026#34; pointcut-ref=\u0026#34;point\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; 方式三：使用注解来实现AOP   在类上标注注解@Aspect，如果没有该注解，就在maven配置里把\u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt;去掉\n  在方法前加上@Before()或@After()注解，并在括号中填入表达式\n//使用注解实现AOP @Aspect public class AnnotationPointCut { @Before(\u0026#34;execution(* top.lbqaq.service.UserServiceImpl.*(..))\u0026#34;) public void before(){ System.out.println(\u0026#34;=====方法执行前=====\u0026#34;); } @After(\u0026#34;execution(* top.lbqaq.service.UserServiceImpl.*(..))\u0026#34;) public void after(){ System.out.println(\u0026#34;=====方法执行后=====\u0026#34;); } //在环绕增强中，我们可以给定一个参数，代表我们要获取处理切入的点  @Around(\u0026#34;execution(* top.lbqaq.service.UserServiceImpl.*(..))\u0026#34;) public void around(ProceedingJoinPoint jp) throws Throwable { System.out.println(\u0026#34;环绕前\u0026#34;); //执行方法  Object proceed = jp.proceed(); System.out.println(\u0026#34;环绕后\u0026#34;); } }   在Spring配置文件注册Bean并开启注解支持\n\u0026lt;bean id=\u0026#34;annotationPointCut\u0026#34; class=\u0026#34;top.lbqaq.diy.AnnotationPointCut\u0026#34;/\u0026gt; \u0026lt;!--开启注解支持--\u0026gt; \u0026lt;aop:aspectj-autoproxy/\u0026gt;   整合MyBatis 首先要导入相关jar包\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- junit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.13\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mysql驱动 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.25\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis-spring --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- spring框架 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- spring-jdbc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- AOP 织入器 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 回顾MyBatis   编写实体类\npublic class User { private int id; private String name; private String pwd; //setter,getter  //toString,构造 }   编写Mybatis配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;!--核心配置文件--\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;top.lbqaq.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!--每一个mapper都需要注册--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026#34;top.lbqaq.mapper.UserMapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;   编写接口\npublic interface UserMapper { List\u0026lt;User\u0026gt; selectUser(); }   编写接口对应的xml文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;top.lbqaq.mapper.UserMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;selectUser\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   解决Maven静态资源过滤问题\n\u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt;   测试\npublic class MyTest { @Test public void test() throws IOException { String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u0026lt;User\u0026gt; userList = mapper.selectUser(); for (User user: userList){ System.out.println(user); } sqlSession.close(); } }   MyBatis-Spring MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。官方文档\n整合实现一   引入Spring配置文件spring-dao.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt;   配置数据源\n\u0026lt;!--DataSource:使用Spring的数据源替换MyBatis的配置 这里使用Spring提供的JDBC --\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   配置SqlSessionFactory,关联MyBatis\n\u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34; /\u0026gt; \u0026lt;!--绑定Mybatis配置文件--\u0026gt; \u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;classpath:mybatis-config.xml\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;mapperLocations\u0026#34; value=\u0026#34;classpath:top/lbqaq/mapper/*.xml\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   注册sqlSessionTemplate，关联sqlSessionFactory\n\u0026lt;bean id=\u0026#34;sqlSession\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionTemplate\u0026#34;\u0026gt; \u0026lt;!--使用构造器注入，因为它没有set方法--\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; ref=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   增加Mapper接口的实现类\npublic class UserMapperImpl implements UserMapper{ //原来我们的所有操作，都使用sqlSession来执行；现在都使用SqlSessionTemplate  private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } @Override public List\u0026lt;User\u0026gt; selectUser() { UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); } }   将实现类注册到Spring中\n\u0026lt;bean id=\u0026#34;userMapper\u0026#34; class=\u0026#34;top.lbqaq.mapper.UserMapperImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sqlSession\u0026#34; ref=\u0026#34;sqlSession\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   测试\n@Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;spring-dao.xml\u0026#34;); UserMapper userMapper = context.getBean(\u0026#34;userMapper\u0026#34;, UserMapper.class); for (User user : userMapper.selectUser()) { System.out.println(user); } }   此时再去看MyBatis的配置文件，里面大部分配置都被Spring整合了\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;top.lbqaq.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;/configuration\u0026gt; 这里建议将typeAliases和settings留在MyBatis的配置文件中。\n以后可以将Spring配置文件拆开，spring-dao.xml用来处理数据库相关代码，applicationContext.xml作为总配置文件。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;import resource=\u0026#34;spring-dao.xml\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;userMapper\u0026#34; class=\u0026#34;top.lbqaq.mapper.UserMapperImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sqlSession\u0026#34; ref=\u0026#34;sqlSession\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 整合方式二 使用SqlSessionDaoSupport\n  修改实现类，继承SqlSessionDaoSupport\npublic class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper{ @Override public List\u0026lt;User\u0026gt; selectUser() { return getSqlSession().getMapper(UserMapper.class).selectUser(); } }   配置Bean\n\u0026lt;bean id=\u0026#34;userMapper2\u0026#34; class=\u0026#34;top.lbqaq.mapper.UserMapperImpl2\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sqlSessionFactory\u0026#34; ref=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   测试\n@Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); UserMapper userMapper = context.getBean(\u0026#34;userMapper2\u0026#34;, UserMapper.class); for (User user : userMapper.selectUser()) { System.out.println(user); } }   使用这种方法，就不需要上面的第4步了，步骤就更加简洁了。\n声明式事务 spring中的事务：\n 编程式事务：在代码中进行事务的管理 声明式事务：AOP  一般我们都采用声明式事务，将事务管理作为横切关注点，通过aop方法模块化。\n使用方法：\n  引入头文件约束tx\nxmlns:tx=\u0026#34;http://www.springframework.org/schema/tx\u0026#34; http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\u0026#34;   配置事务管理器\n\u0026lt;!--配置声明式事务--\u0026gt; \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt;   配置事务通知\n\u0026lt;!--配置事务通知--\u0026gt; \u0026lt;tx:advice id=\u0026#34;txAdvice\u0026#34; transaction-manager=\u0026#34;transactionManager\u0026#34;\u0026gt; \u0026lt;!--给那些方法配置事务--\u0026gt; \u0026lt;tx:attributes\u0026gt; \u0026lt;!--配置事务的传播特性 propagation--\u0026gt; \u0026lt;tx:method name=\u0026#34;add\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;delete\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;update\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;query\u0026#34; read-only=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;*\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;/tx:attributes\u0026gt; \u0026lt;/tx:advice\u0026gt; Spring的事务的传播特性一共有7种：\n propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。 propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。 propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。 propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作  一般第一种就够用了。\n  配置AOP\n注意要导入头文件依赖aop，详细的内容在上面，或者IDEA也会自动补全\n\u0026lt;!--配置事务切入--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;txPointCut\u0026#34; expression=\u0026#34;execution(* top.lbqaq.mapper.*(..))\u0026#34;/\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;txAdvice\u0026#34; pointcut-ref=\u0026#34;txPointCut\u0026#34;/\u0026gt; \u0026lt;/aop:config\u0026gt;   ","date":"2021-08-12T09:38:02+08:00","image":"https://lbqaq.top/p/spring/82968220.webp","permalink":"https://lbqaq.top/p/spring/","title":"Spring学习笔记"},{"content":"因为买了一台云服务器，不拿来干点啥实在是太亏了，于是便想到了可以使用云服务器来挂卡。\n步骤 安装.net环境 ASF是基于.netcore开发的程序，所以需要安装环境。这里建议看微软官方的安装文档，里面有不同系统的安装方法。\n我们需要安装的只是ASP.NET Core 运行时。\n我的系统是centos7，这里就只列举我系统上的命令了。\nsudo rpm -Uvh https://packages.microsoft.com/config/centos/7/packages-microsoft-prod.rpm sudo yum install aspnetcore-runtime-5.0 安装ASF 在ASF的发布页面上下载系统对应的版本解压即可。\n我这里是在本地先下载好后用WinSCP直接传上服务器。\n配置ASF 这里就采用官方的**在线配置文件生成器**自动生成即可。\n我们这里选择机器人，将steam的账号和密码填入，并将Enabled设置为True就行了。\n详细的配置内容可以在官方Wiki上看到，这里就不再赘述了。\n下面放上我的配置文件：\n{ \u0026#34;SteamLogin\u0026#34;: \u0026#34;xxx\u0026#34;, \u0026#34;SteamPassword\u0026#34;: \u0026#34;xxx\u0026#34;, \u0026#34;Enabled\u0026#34;: true, \u0026#34;CustomGamePlayedWhileFarming\u0026#34;: \u0026#34;挂卡中...\u0026#34;, \u0026#34;CustomGamePlayedWhileIdle\u0026#34;: \u0026#34;空闲中...\u0026#34;, \u0026#34;FarmingOrders\u0026#34;: [ 15, 12 ], \u0026#34;HoursUntilCardDrops\u0026#34;: 0, \u0026#34;OnlineStatus\u0026#34;: 1 }  CustomGamePlayedWhileFarming：表示挂卡时显示的游戏名 CustomGamePlayedWhileIdle：表示空闲时显示的游戏名 HoursUntilCardDrops：表示至少将游戏挂到几小时，如果是非限制账户，调到0是最好的。  我们也可以配置ASF本身的设置，这里也同样贴上我的配置：\n{ \u0026#34;s_SteamOwnerID\u0026#34;: \u0026#34;xxx\u0026#34;, \u0026#34;CurrentCulture\u0026#34;: \u0026#34;zh-CN\u0026#34;, \u0026#34;IPCPassword\u0026#34;: \u0026#34;xxx\u0026#34; }  s_SteamOwnerID：该属性定义 ASF 进程所有者的 64 位 Steam ID，直接设置成自己的大号就行 CurrentCulture：ASF的语言 IPCPassword：由于ASF默认会开启IPC服务，为了安全起见建议设置密码或关闭IPC服务。  将配置文件放入config目录里就行了。\n启动ASF 首先将ASF的主程序设置为可执行：\nsudo chmod 755 ./ArchiSteamFarm 然后运行即可：\n./ArchiSteamFarm 附加步骤 使用ASCF 由于服务器在大陆境内，由于众所周知的原因是无法访问steam社区的，这时就需要使用大佬开发的转发工具了。\n【更新2.0】另一个SteamCommunityFix | 支持Win/Linux/MacOS 【2018-08-29】\n下载地址：https://pan.baidu.com/s/1nvBW8qP\n使用步骤：\n  下载并解压缩\n  打开终端（Terminal），进入到ascf程序目录： 如ascf程序在 /Users/Makazeu/Downloads/文件夹中，那么在终端中输入\ncd /Users/Makazeu/Downloads   赋予程序可执行权限，在终端中输入命令：\nchmod +x ./ascf   使用root用户（管理员用户）运行程序，在终端中输入\nsudo ./ascf 输入root用户密码后，看程序是否运行 因为程序涉及到hosts文件修改，需要高权限，所以你需要输入root密码\n  若程序已经成功运行，此时就不要关闭终端窗口了，否则程序就会退出！试下Steam社区能否正常打开\n  使用Tmux 由于我们在服务器上使用，不可能一直开着ssh，这时就需要将终端窗口和会话解绑，Tmux就是做这个工作的。\n安装：\n# Ubuntu 或 Debian $ sudo apt-get install tmux # CentOS 或 Fedora $ sudo yum install tmux # Mac $ brew install tmux 常用命令/快捷键：\n  新建会话：Tmux 窗口默认是以0、1、2\u0026hellip;\u0026hellip;来编号的，为了便于区分，可以为每个会话起名\ntmux new -s \u0026lt;session-name\u0026gt;   分离当前会话：Ctrl+b d\n  列出所有会话：Ctrl+b s或tmux ls\n  重命名当前会话：Ctrl+b $或tmux rename-session -t 0 \u0026lt;new-name\u0026gt;\n  接入到某个会话：\n# 使用会话编号 $ tmux attach -t 0 # 使用会话名称 $ tmux attach -t \u0026lt;session-name\u0026gt;   切换到某个会话：\n# 使用会话编号 $ tmux switch -t 0 # 使用会话名称 $ tmux switch -t \u0026lt;session-name\u0026gt;   参考链接  Tmux 使用教程 - 阮一峰的网络日志 ASF官方Wiki NET开发文档  ","date":"2021-08-11T21:46:24+08:00","image":"https://lbqaq.top/p/asf/82970659.webp","permalink":"https://lbqaq.top/p/asf/","title":"从零开始ASF挂卡"},{"content":"花了四天的时间，终于把MyBatis的视频教程全部看完了，为了以后不要那么快的遗忘掉，还是来写一下笔记比较好。\n下面的内容都是基于遇见狂神说的MyBatis视频教程而来，在此感谢能提供这么优秀的教程。\n简介  MyBatis的作用用我自己的话说，就是不用自己手动搞JDBC了，省事，行！ MyBatis作用于持久层——DAO层 【DAO (Data Access Object) 数据访问对象】，通俗点说就是用来操作数据库的层 选择MyBatis的最大原因还是用的人多，为后面的Spring打基础_(:з)∠)_  第一个MyBatis程序 思路流程：搭建环境\u0026ndash;\u0026gt;导入MyBatis\u0026mdash;\u0026gt;编写代码\u0026mdash;\u0026gt;测试\n具体代码   创建Maven项目\n  引入依赖包\n\u0026lt;!-- 导入依赖 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- mysql驱动 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.25\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- junit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;   在resources目录下创建mybatis-config.xml，作为MyBatis的配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;!--核心配置文件--\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!--每一个mapper都需要注册--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;UserMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;   编写MyBatis工具类，在utils的包下面创建MybatisUtils类，填入以下代码\nimport org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; //SqlSessionFactory  /** * @author luoboQAQ */ public class MybatisUtils { private static SqlSessionFactory sqlSessionFactory; static { try { //使用Mybatis第一步：获取SqlSessionFactory  String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。  //SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。  public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(); } }   在pojo包下创建实体类\npublic class User { private int id; //id  private String name; //姓名  private String pwd; //密码  //构造,有参,无参  //set/get  //toString() }   在dao包下创建接口类，我们需要的功能就填入到这里面\nimport top.lbqaq.pojo.User; import java.util.List; import java.util.Map; public interface UserMapper { //模糊查询  List\u0026lt;User\u0026gt; getUserLike(String value); //查询全部用户  List\u0026lt;User\u0026gt; getUserList(); //根据ID查询用户  User getUserById(int id); //插入用户  int addUser(User user); int addUser2(Map\u0026lt;String,Object\u0026gt; map); //修改用户  int updateUser(User user); //删除用户  int deleteUser(int id); }   编写Mapper.xml配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!--namespace绑定一个对应的Dao/Mapper接口--\u0026gt; \u0026lt;mapper namespace=\u0026#34;top.lbqaq.dao.UserMapper\u0026#34;\u0026gt; \u0026lt;!--id就是namespace中对应的方法名，resultType：sql语句的返回值--\u0026gt; \u0026lt;select id=\u0026#34;getUserList\u0026#34; resultType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;getUserLike\u0026#34; resultType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; select * from user where name like #{value} \u0026lt;/select\u0026gt; \u0026lt;!--parameterType：传入参数类型--\u0026gt; \u0026lt;select id=\u0026#34;getUserById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; select * from user where id=#{id} \u0026lt;/select\u0026gt; \u0026lt;insert id=\u0026#34;addUser\u0026#34; parameterType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; insert into user (id,name,pwd) values (#{id},#{name},#{pwd}) \u0026lt;/insert\u0026gt; \u0026lt;!--传递map的key--\u0026gt; \u0026lt;insert id=\u0026#34;addUser2\u0026#34; parameterType=\u0026#34;map\u0026#34;\u0026gt; insert into user (id,name,pwd) values (#{userid},#{userName},#{passWord}) \u0026lt;/insert\u0026gt; \u0026lt;update id=\u0026#34;updateUser\u0026#34; parameterType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; update user set name =#{name},pwd=#{pwd} where id=#{id} \u0026lt;/update\u0026gt; \u0026lt;delete id=\u0026#34;deleteUser\u0026#34; parameterType=\u0026#34;int\u0026#34;\u0026gt; delete from user where id=#{id} \u0026lt;/delete\u0026gt; \u0026lt;/mapper\u0026gt;   进行测试\nimport org.apache.ibatis.session.SqlSession; import org.junit.Test; import top.lbqaq.pojo.User; import top.lbqaq.utils.MybatisUtils; import java.util.HashMap; import java.util.List; public class UserMapperTest { @Test public void test() { //获得sqlSession对象  try (SqlSession sqlSession = MybatisUtils.getSqlSession()) { //执行SQL  UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u0026lt;User\u0026gt; userList = mapper.getUserList(); for (User user : userList) { System.out.println(user); } } } @Test public void getUserLike() { //获得sqlSession对象  try (SqlSession sqlSession = MybatisUtils.getSqlSession()) { //执行SQL  UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u0026lt;User\u0026gt; userList = mapper.getUserLike(\u0026#34;%李%\u0026#34;); for (User user : userList) { System.out.println(user); } } } @Test public void getUserById() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); sqlSession.close(); } @Test public void addUser(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); int res = mapper.addUser(new User(4, \u0026#34;小明\u0026#34;, \u0026#34;123\u0026#34;)); if(res\u0026gt;0){ System.out.println(\u0026#34;提交成功\u0026#34;); //提交事务  sqlSession.commit(); } sqlSession.close(); } @Test public void addUser2(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap\u0026lt;String,Object\u0026gt; map= new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;userid\u0026#34;,5); map.put(\u0026#34;userName\u0026#34;,\u0026#34;小绿\u0026#34;); map.put(\u0026#34;passWord\u0026#34;,\u0026#34;1234\u0026#34;); int res = mapper.addUser2(map); if(res\u0026gt;0){ System.out.println(\u0026#34;提交成功\u0026#34;); //提交事务  sqlSession.commit(); } sqlSession.close(); } @Test public void updateUser(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); int res = mapper.updateUser(new User(4, \u0026#34;小明\u0026#34;, \u0026#34;123456\u0026#34;)); if(res\u0026gt;0){ System.out.println(\u0026#34;提交成功\u0026#34;); //提交事务  sqlSession.commit(); } sqlSession.close(); } @Test public void deleteUser(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); int res = mapper.deleteUser(4); if(res\u0026gt;0){ System.out.println(\u0026#34;提交成功\u0026#34;); //提交事务  sqlSession.commit(); } sqlSession.close(); } }   注意事项   如果Mapper.xml创建在java目录里而不是resouces里，需要在Maven配置里配置过滤，否则会保错\n\u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt;   当需要传入参数进行查询而不是传入实体类，有两种方法\n  第一种：直接在方法中传递参数。\n在接口方法的参数前加@Param属性，sql语句编写的时候，直接取@Param中设置的值即可，不需要单独设置参数类型\nUser selectUserByNP(@Param(\u0026#34;username\u0026#34;) String username,@Param(\u0026#34;pwd\u0026#34;) String pwd); /* \u0026lt;select id=\u0026#34;selectUserByNP\u0026#34; resultType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; select * from user where name = #{username} and pwd = #{pwd} \u0026lt;/select\u0026gt; */   第二种：通过map来传递参数。（推荐）\n在接口创建时就直接使用map作为参数\nint addUser2(Map\u0026lt;String,Object\u0026gt; map); 在写sql时直接设置入参为map即可\n\u0026lt;!--传递map的key--\u0026gt; \u0026lt;insert id=\u0026#34;addUser2\u0026#34; parameterType=\u0026#34;map\u0026#34;\u0026gt; insert into user (id,name,pwd) values (#{userid},#{userName},#{passWord}) \u0026lt;/insert\u0026gt;     配置解析 官方文档\n核心配置 MyBatis官方给出的配置项有以下这么多：\nconfiguration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） \u0026lt;!-- 注意元素节点的顺序！顺序不对会报错 --\u0026gt; 我们需要关注的就是properties（属性）、settings（设置）、typeAliases（类型别名）、plugins（插件）、environments（环境配置）、mappers（映射器）这几项配置，其余的可以忽略（基本用不到）\nproperties 数据库这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。\n说白了，就是能将数据库那些配置项从核心配置中剥离出来，降低耦合。\n用法   在resources目录下创建db.properties，填入下面的内容\ndriver=com.mysql.cj.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis username=root password=root   在配置xml中导入\n\u0026lt;!--引用外部配置文件--\u0026gt; \u0026lt;properties resource=\u0026#34;db.properties\u0026#34;\u0026gt; \u0026lt;!--外部文件优先级大于内部（下面）--\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123\u0026#34;/\u0026gt; \u0026lt;/properties\u0026gt; 正常情况下，只需要用\u0026lt;properties resource=\u0026quot;db.properties\u0026quot;/\u0026gt;这短短一句就行了，上面的代码是用来测试优先级的\n  settings 这里存放的是MyBatis的一些设置项，具体的内容在官方文档上可以查看\n常用的设置项有以下几个：\n   设置名 描述 有效值 默认值     cacheEnabled 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。 true | false true   mapUnderscoreToCamelCase 是否开启驼峰命名自动映射，即从经典数据库列名A_COLUMN 映射到经典 Java 属性名 aColumn。 true | false False   logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 未设置    typeAliases 类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。\n也就是在resultType和parameterType中不需要写那么长的类名了\n用法 \u0026lt;!--可以给实体类起别名--\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;!--手动指定--\u0026gt; \u0026lt;typeAlias type=\u0026#34;top.lbqaq.pojo.User\u0026#34; alias=\u0026#34;User\u0026#34;/\u0026gt; \u0026lt;!--自动扫描包下所有类，别名为类名全小写--\u0026gt; \u0026lt;package name=\u0026#34;top.lbqaq.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; 有两种方法，第一种就是手动指定别名，第二种就是通过package标签自动扫描包下所有的类\n在第二种方法下，默认别名是类名全小写（当然首字母大写也同样可用）\n如果在类前加上@Alias注解，则别名就为手动设定的内容。\nplugins 这里是配置mybatis的插件的地方，常用的插件有以下几个：\n PageHelper MyBatis-Plus \u0026hellip; \u0026hellip;  这里是就不展开这些插件了，以后有需要再看\nenvironments 配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定）。\n\u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt;  transactionManager： 事务管理器 。有两个选项：  JDBC：正常的 MANAGED：几乎啥都不干   dataSource：如何使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。有三个选项：  unpooled：这个数据源的实现只是每次被请求时打开和关闭连接。 pooled：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。 jndi：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。    mappers 用于告诉MyBatis我们写的xml文件到底在哪，每个xml文件都需要绑定！\n常用的有以下几种方法：\n\u0026lt;!-- 使用相对于类路径的资源引用 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;top/lbqaq/dao/UserMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;!-- 使用映射器接口实现类的完全限定类名 需要配置文件名称和接口名称一致，并且位于同一目录下 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026#34;top.lbqaq.dao.UserMapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;!-- 将包内的映射器接口实现全部注册为映射器 但是需要配置文件名称和接口名称一致，并且位于同一目录下 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;package name=\u0026#34;org.mybatis.builder\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; ResultMap 属性名和字段名不一致 在实际开发中，会遇到类的属性名和数据库的字段名不一致，这时MyBatis的自动匹配将无法产生作用，这时可以使用ResultMap来解决这个问题。\n\u0026lt;mapper namespace=\u0026#34;top.lbqaq.dao.UserMapper\u0026#34;\u0026gt; \u0026lt;!--结果集映射--\u0026gt; \u0026lt;resultMap id=\u0026#34;UserMap\u0026#34; type=\u0026#34;User\u0026#34;\u0026gt; \u0026lt;!--column:数据库中的字段；property：实体类的属性--\u0026gt; \u0026lt;!-- \u0026lt;result column=\u0026#34;id\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;result column=\u0026#34;name\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;result column=\u0026#34;pwd\u0026#34; property=\u0026#34;password\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getUserById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultMap=\u0026#34;UserMap\u0026#34;\u0026gt; select * from user where id=#{id} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 多对一 在开发时常常会有这样的需求，比如多个学生都被一个老师教，下面将对该实例具体展开来了解多对一如何处理。\n环境搭建   添加Lombok插件\n  引入Maven依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.20\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   编写实体类\n@Data public class Student { private int id; private String name; /** * 学生需要关联一个老师 */ private Teacher teacher; } @Data public class Teacher { private int id; private String name; }   按查询嵌套处理 思路：\n  获取所有学生的信息\n  根据获取的学生信息的老师ID-\u0026gt;获取该老师的信息\n  思考问题，这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般使用关联查询？\n 做一个结果集映射：StudentTeacher StudentTeacher结果集的类型为 Student 学生中老师的属性为teacher，对应数据库中为tid。 多个 [1,\u0026hellip;）学生关联一个老师=\u0026gt; 一对一，一对多 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查询    \u0026lt;select id=\u0026#34;getStudent\u0026#34; resultMap=\u0026#34;StudentTeacher\u0026#34;\u0026gt; select * from student \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;StudentTeacher\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;id\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;name\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;!--复杂的属性需要单独处理 对象：association 集合：collection--\u0026gt; \u0026lt;association column=\u0026#34;tid\u0026#34; property=\u0026#34;teacher\u0026#34; javaType=\u0026#34;Teacher\u0026#34; select=\u0026#34;getTeacher\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultType=\u0026#34;Teacher\u0026#34;\u0026gt; select * from teacher where id=#{tid} \u0026lt;/select\u0026gt; 注意点：\n\u0026lt;resultMap id=\u0026#34;StudentTeacher\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--\u0026gt; \u0026lt;association property=\u0026#34;teacher\u0026#34; column=\u0026#34;{id=tid,name=tid}\u0026#34; javaType=\u0026#34;Teacher\u0026#34; select=\u0026#34;getTeacher\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!-- 这里传递过来的id，只有一个属性的时候，下面可以写任何值 association中column多参数配置： column=\u0026#34;{key=value,key=value}\u0026#34; 其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。 --\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultType=\u0026#34;teacher\u0026#34;\u0026gt; select * from teacher where id = #{id} and name = #{name} \u0026lt;/select\u0026gt; 这个还是比较难以理解的，一般我选择用第二种方法\n按结果嵌套处理 \u0026lt;!--按照结果嵌套处理--\u0026gt; \u0026lt;select id=\u0026#34;getStudent2\u0026#34; resultMap=\u0026#34;StudentTeacher2\u0026#34;\u0026gt; select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid=t.id \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;StudentTeacher2\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;sid\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;sname\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;association property=\u0026#34;teacher\u0026#34; javaType=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;tname\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; 这种就比较好理解了，难度主要在sql部分，好在之前数据库学的还行，这种方法还是比较适合我。\n一对多 一个老师会教多个学生。\n环境搭建 @Data public class Student { private int id; private String name; private int tid; } @Data public class Teacher { private int id; private String name; /** * 一个老师有多个学生 */ private List\u0026lt;Student\u0026gt; students; } 按结果嵌套查询 \u0026lt;!--按结果嵌套查询--\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultMap=\u0026#34;TeacherStudent\u0026#34;\u0026gt; select s.id sid,s.name sname,t.name tname,t.id tid from student s,teacher t where s.tid=t.id and t.id=#{tid} \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;TeacherStudent\u0026#34; type=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;tid\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;tname\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;!--集合中的泛型信息用ofType获取--\u0026gt; \u0026lt;collection property=\u0026#34;students\u0026#34; ofType=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;sid\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;sname\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;tid\u0026#34; property=\u0026#34;tid\u0026#34;/\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt; JavaType和ofType都是用来指定对象类型的。\nJavaType是用来指定pojo中属性的类型。\nofType指定的是映射到list集合属性中pojo的类型。\n按查询嵌套 \u0026lt;!--按查询嵌套--\u0026gt; \u0026lt;select id=\u0026#34;getTeacher2\u0026#34; resultMap=\u0026#34;TeacherStudent2\u0026#34;\u0026gt; select * from teacher where id=#{tid} \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;TeacherStudent2\u0026#34; type=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;collection property=\u0026#34;students\u0026#34; javaType=\u0026#34;ArrayList\u0026#34; ofType=\u0026#34;Student\u0026#34; select=\u0026#34;getStudentByTeacherId\u0026#34; column=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getStudentByTeacherId\u0026#34; resultType=\u0026#34;Student\u0026#34;\u0026gt; select * from student where tid = #{tid} \u0026lt;/select\u0026gt; 日志工厂 如果一个数据库相关的操作出现了问题，我们可以根据输出的SQL语句快速排查问题。可见打印出SQL语句是十分重要的。（还记得之前项目综合实践为了搞日志忙了半天，结果还是没搞出来😭）\n标准日志 在MyBatis里自带了通过控制台打印的日志功能，如果项目并不是很复杂，用它就足够了。\n只需要在设置里设置启用就可以了。\n\u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;STDOUT_LOGGING\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; log4j log4j相比标准日志，那不知道高到哪里去了，具体的功能我就不写了，毕竟一百度就能出来了。\n使用步骤：\n  导入log4j的包\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   在resources目录下新建log4j.properties，并填入以下配置文件\n#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码 log4j.rootLogger=DEBUG,console,file #控制台输出的相关设置 log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n #文件输出的相关设置 log4j.appender.file = org.apache.log4j.RollingFileAppender log4j.appender.file.File=./log/log.log log4j.appender.file.MaxFileSize=10mb log4j.appender.file.Threshold=DEBUG log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n #日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG   在MyBatis里启用\n\u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;LOG4J\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt;   在程序中使用Log4j进行输出\nimport org.apache.log4j.Logger; import org.junit.Test; public class UserMapperTest { static Logger logger = Logger.getLogger(UserMapperTest.class); @Test public void testLog4j(){ logger.info(\u0026#34;info:进入了testLog4j\u0026#34;); logger.debug(\u0026#34;debug:进入了testLog4j\u0026#34;); logger.error(\u0026#34;error:进入了testLog4j\u0026#34;); } }   使用注解开发 MyBatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。\n而到MyBatis 3提供了新的基于注解的配置。不幸的是，Java 注解的的表达力和灵活性十分有限。最强大的 MyBatis 映射并不能用注解来构建。\n在注解开发中，主要使用这几个注解：@select ()、@update ()、@Insert ()、@delete ()\n举例：\npublic interface UserMapper { @Select(\u0026#34;select * from user\u0026#34;) List\u0026lt;User\u0026gt; getUser(); @Select(\u0026#34;select * from user where id=#{id}\u0026#34;) User getUserByID(@Param(\u0026#34;id\u0026#34;) int id); @Insert(\u0026#34;insert into user(id,name,pwd) values(#{id},#{name},#{pwd})\u0026#34;) int addUser(User user); } 改造MybatisUtils工具类的getSession() 方法，重载实现。\n//获取SqlSession连接 public static SqlSession getSession(){ return getSession(true); //事务自动提交 } public static SqlSession getSession(boolean flag){ return sqlSessionFactory.openSession(flag); } @Param注解用于给方法参数起一个名字。以下是总结的使用原则：\n 在方法只接受一个参数的情况下，可以不使用@Param。 在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。 如果参数是 JavaBean ， 则不能使用@Param。 不使用@Param注解时，参数只能有一个，并且是JavaBean。  动态SQL 动态SQL指的是根据不同的查询条件 , 生成不同的sql语句。\n主要使用这几个标签：if、choose、where、set、foreach\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;top.lbqaq.dao.BlogMapper\u0026#34;\u0026gt; \u0026lt;insert id=\u0026#34;addBook\u0026#34; parameterType=\u0026#34;Blog\u0026#34;\u0026gt; insert into blog(id, title, author, create_time, views) values (#{id}, #{title}, #{author}, #{createTime}, #{views}) \u0026lt;/insert\u0026gt; \u0026lt;select id=\u0026#34;queryBlogIF\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;queryBlogChoose\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; and views = #{view} \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;update id=\u0026#34;updateBlog\u0026#34; parameterType=\u0026#34;map\u0026#34;\u0026gt; update blog \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id = #{id} \u0026lt;/update\u0026gt; \u0026lt;select id=\u0026#34;queryBlogForeach\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;!--collection:指定输入对象中的集合属性 item:每次遍历生成的对象 open:开始遍历时的拼接字符串 close:结束时拼接的字符串 separator:遍历对象之间需要拼接的字符串--\u0026gt; \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34; separator=\u0026#34;or\u0026#34;\u0026gt; id = #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; SQL片段 有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。\n提取SQL片段：\n\u0026lt;sql id=\u0026#34;if-title-author\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/sql\u0026gt; 引用SQL片段：\n\u0026lt;select id=\u0026#34;queryBlogIf\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --\u0026gt; \u0026lt;include refid=\u0026#34;if-title-author\u0026#34;\u0026gt;\u0026lt;/include\u0026gt; \u0026lt;!-- 在这里还可以引用其他的 sql 片段 --\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 注意：\n①、最好基于 单表来定义 sql 片段，提高片段的可重用性\n②、在 sql 片段中不要包括 where\n缓存 简介 1、什么是缓存 [ Cache ]？\n 存在内存中的临时数据。 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。  2、为什么使用缓存？\n 减少和数据库的交互次数，减少系统开销，提高系统效率。  3、什么样的数据能使用缓存？\n 经常查询并且不经常改变的数据。  MyBatis缓存   MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。\n  MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存\n   默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存    一级缓存 一级缓存也叫本地缓存：\n 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；  一级缓存失效的四种情况  sqlSession不同 sqlSession相同，查询条件不同 sqlSession相同，两次查询之间执行了增删改操作！ sqlSession相同，手动清除一级缓存  二级缓存   二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存\n  基于namespace级别的缓存，一个名称空间，对应一个二级缓存；\n  工作机制\n   一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存（map）中；    使用方法   开启全局缓存 mybatis-config.xml\n\u0026lt;setting name=\u0026#34;cacheEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt;   去每个mapper.xml中配置使用二级缓存，这个配置非常简单。\n\u0026lt;cache/\u0026gt; 官方示例 \u0026lt;cache eviction=\u0026#34;FIFO\u0026#34; flushInterval=\u0026#34;60000\u0026#34; size=\u0026#34;512\u0026#34; readOnly=\u0026#34;true\u0026#34;/\u0026gt; 这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。   ","date":"2021-08-11T11:11:10+08:00","image":"https://lbqaq.top/p/mybatis/86164137.webp","permalink":"https://lbqaq.top/p/mybatis/","title":"MyBatis学习笔记"},{"content":"这篇文章我打算来介绍一下如何构建qsqlmysql.dll，由于版权原因，在新版的Qt里是不自带该dll的，这样对我们编写数据库程序会很麻烦。（你用ODBC？那没事了）\n我在网上也查了很多资料，但根据步骤来总是会报错，提示没有mysql.h这个头文件。下面就记录一下我成功编译的过程。\n基于cmake的步骤 在6.1之后的Qt版本中，Qt公司删除了qmake而更换成了cmake的方式来构建项目文件，下面就是我总结的使用cmake生成的方法。\n注意： 路径的前段部分(软件的安装位置)每个人可能都不一样，但是路径的后段部分应该是一样的，请自行修改。\n1.准备好Qt的源代码，如果没有可以在Qt的安装目录打开MaintenanceTool.exe启动Qt组件管理，在里面勾选Src把源码下载下来。\n2.打开cmake-gui，选择目标文件夹为D:\\Qt\\6.1.1\\Src\\qtbase\\src\\plugins\\sqldrivers，并设置生成文件夹为D:/Qt/6.1.1/Src/qtbase/src/plugins/sqldrivers/build\n 配置文件夹 \n3.点击左下角的Configure，会提示生成的目录不存在是否创建，直接点是就可以了。\n4.编译器这里选择MinGW Makefiles,然后点击Finish\n 选择编译器 \n5.等待生成完成后，把FEATURE_sql_mysql后面的勾勾上，然后把其余的FEATURE_sql后面的勾取消。\n 选择生成模块 \n6.再次点击左下角的Configure，可以发现上面的红框已经消失了，说明配置成功了。然后点击Generate，生成Makefiles。\n 配置成功 \n7.这时配置文件已经构建完成了，接下来就是生成dll了，打开PowerShell切换目录至D:/Qt/6.1.1/Src/qtbase/src/plugins/sqldrivers/build，输入mingw32-make开始编译生成dll。\n 编译成功 \n没有报错，说明生成成功。\n8.最后打开目录D:\\Qt\\6.1.1\\Src\\qtbase\\src\\plugins\\sqldrivers\\build\\plugins\\sqldrivers，就可以看到生成好的qsqlmysql.dll了。\n基于qmake的步骤 注意： 路径的前段部分(软件的安装位置)每个人可能都不一样，但是路径的后段部分应该是一样的，请自行修改。\n1.准备好Qt的源代码，如果没有可以在Qt的安装目录打开MaintenanceTool.exe启动Qt组件管理，在里面勾选Src把源码下载下来。\n2.进入D:\\Qt\\6.0.3\\Src\\qtbase\\src\\plugins\\sqldrivers目录下，打开sqldrivers.pro这个文件。\n3.在左侧文件树中打开mysql文件夹，选择mysql.pro打开。\n4.修改里面的内容：\n  注释掉QMAKE_USE += mysql这一句\n  增加下面三行代码(注意把D:/MySQL/改为你MySQL的安装路径)：\nLIBS +=-LD:/MySQL/lib -llibmysql INCLUDEPATH += D:/MySQL/include DEPENDPATH += D:/MySQL/include   5.点击Qt左下角的小锤子进行构建，不出意外的话就可以在D:\\Qt\\6.0.3\\Src\\qtbase\\src\\plugins这个路径下看到build开头的文件夹，在.\\plugins\\sqldrivers目录下就能看到编译好的dll了。\n6.最后将qsqlmysql.dll放入D:\\Qt\\6.0.3\\mingw81_64\\plugins\\sqldrivers\\里就行了。如果链接数据库时还报错，就把libmysql.dll复制到Qt的编译器的D:\\Qt\\6.0.3\\mingw81_64\\bin\\目录。\n","date":"2021-06-03T15:44:17+08:00","image":"https://lbqaq.top/p/qt%E6%9E%84%E5%BB%BAqsqlmysql.dll/89217963.webp","permalink":"https://lbqaq.top/p/qt%E6%9E%84%E5%BB%BAqsqlmysql.dll/","title":"Qt构建qsqlmysql.dll"},{"content":"1202年了，是时候抛弃老旧的cmd窗口和臃肿的VM虚拟机了，来试试巨硬推出的WSL2+Windows Terminal(～￣▽￣)～。\n起因 在知乎上刷到了一篇回答，是关于Windows编程的体验的。在这篇文章中提到了WSL2和Windows Terminal，我一下就被那精美的界面吸引了（管他好不好用，好看就完事了）。正好现在在上操作系统这门课，需要使用Linux进行实验，这还说什么，直接开冲。\n 精美的界面 \nWSL2安装 安装其实很简单，按照微软的教程一步一步做就完事了。\n0.前置条件 想要用WSL2，首先你得是 Windows 10，而且还有版本号要求。\n 对于 x64 系统：版本 1903 或更高版本，采用 内部版本 18362 或更高版本。 对于 ARM64 系统：版本 2004 或更高版本，采用 内部版本 19041 或更高版本。  1. 开启WSL服务 在Powershell(管理员)中输入下面的命令：\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 2. 启用虚拟机服务 在Powershell(管理员)中输入下面的命令：\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 重新启动 计算机，以完成 WSL 安装并更新到 WSL 2。\n3. 下载 Linux 内核更新包 下载最新包并安装：\n 适用于 x64 计算机的 WSL2 Linux 内核更新包  4. 将 WSL 2 设置为默认版本 在Powershell中输入下面的命令：\nwsl --set-default-version 2 5.安装 Linux  打开 Microsoft Store，并选择你偏好的 Linux 分发版并点击获取进行安装。 等安装好后，打开并设置用户名和密码。  到此WSL2就安装完事了。\nWindows Terminal安装 1. 下载和安装   从Microsoft Store中下载\n  从Github上下载\n  2. 配置 为了让Windows Terminal看起来更好看一些，我们还要对其进行一些配置。\n 设置 \n打开Windows Terminal的设置选项，然后选打开JSON文件，把我配好的配置文件粘贴进去\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://aka.ms/terminal-profiles-schema\u0026#34;, // Add custom actions and keybindings to this array. // To unbind a key combination from your defaults.json, set the command to \u0026#34;unbound\u0026#34;. // To learn more about actions and keybindings, visit https://aka.ms/terminal-keybindings \u0026#34;actions\u0026#34;: [ // Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json. // These two lines additionally bind them to Ctrl+C and Ctrl+V. // To learn more about selection, visit https://aka.ms/terminal-selection { \u0026#34;command\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;copy\u0026#34;, \u0026#34;singleLine\u0026#34;: false }, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+c\u0026#34; }, { \u0026#34;command\u0026#34;: \u0026#34;paste\u0026#34;, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+v\u0026#34; }, // Press Ctrl+Shift+F to open the search box { \u0026#34;command\u0026#34;: \u0026#34;find\u0026#34;, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+shift+f\u0026#34; }, // Press Alt+Shift+D to open a new pane. // - \u0026#34;split\u0026#34;: \u0026#34;auto\u0026#34; makes this pane open in the direction that provides the most surface area. // - \u0026#34;splitMode\u0026#34;: \u0026#34;duplicate\u0026#34; makes the new pane use the focused pane\u0026#39;s profile. // To learn more about panes, visit https://aka.ms/terminal-panes { \u0026#34;command\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;splitPane\u0026#34;, \u0026#34;split\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;splitMode\u0026#34;: \u0026#34;duplicate\u0026#34; }, \u0026#34;keys\u0026#34;: \u0026#34;alt+shift+d\u0026#34; } ], \u0026#34;copyFormatting\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;copyOnSelect\u0026#34;: false, \u0026#34;defaultProfile\u0026#34;: \u0026#34;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\u0026#34;, \u0026#34;initialCols\u0026#34;: 120, \u0026#34;initialRows\u0026#34;: 30, \u0026#34;profiles\u0026#34;: { \u0026#34;defaults\u0026#34;: { \u0026#34;acrylicOpacity\u0026#34;: 0.75, \u0026#34;closeOnExit\u0026#34;: \u0026#34;graceful\u0026#34;, \u0026#34;colorScheme\u0026#34;: \u0026#34;Campbell\u0026#34;, \u0026#34;cursorColor\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, \u0026#34;cursorShape\u0026#34;: \u0026#34;bar\u0026#34;, \u0026#34;fontFace\u0026#34;: \u0026#34;Consolas\u0026#34;, \u0026#34;fontSize\u0026#34;: 13, \u0026#34;historySize\u0026#34;: 9001, \u0026#34;padding\u0026#34;: \u0026#34;0, 0, 0, 0\u0026#34;, \u0026#34;snapOnInput\u0026#34;: true, \u0026#34;startingDirectory\u0026#34;: \u0026#34;./\u0026#34;, \u0026#34;useAcrylic\u0026#34;: true }, \u0026#34;list\u0026#34;: [ { \u0026#34;commandline\u0026#34;: \u0026#34;powershell.exe -NoLogo\u0026#34;, \u0026#34;guid\u0026#34;: \u0026#34;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Windows PowerShell\u0026#34; }, { \u0026#34;commandline\u0026#34;: \u0026#34;cmd.exe\u0026#34;, \u0026#34;guid\u0026#34;: \u0026#34;{0caa0dad-35be-5f56-a8ff-afceeeaa6101}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Command Prompt\u0026#34; }, { \u0026#34;guid\u0026#34;: \u0026#34;{b453ae62-4e3d-5e58-b989-0a998ec441b8}\u0026#34;, \u0026#34;hidden\u0026#34;: true, \u0026#34;name\u0026#34;: \u0026#34;Azure Cloud Shell\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;Windows.Terminal.Azure\u0026#34; }, { \u0026#34;guid\u0026#34;: \u0026#34;{2c4de342-38b7-51cf-b940-2309a097f518}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Ubuntu\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;Windows.Terminal.Wsl\u0026#34;, \u0026#34;startingDirectory\u0026#34;: \u0026#34;//wsl$/Ubuntu/home/luobo\u0026#34; } ] } } 一般要修改这几项：\n fontFace - 字体，我的字体为Consolas，适合1080P的屏幕。高分辩率屏建议用monaco或者fira code fontSize - 字体大小，因人而异，因屏幕而异，自己根据视觉效果调整大小 acrylicOpacity - 背景透明度，同样因人而异，因屏幕而异，自己根据视觉效果调整大小 initialCols - 初始窗口宽度，同样因人而异，因屏幕而异，自己根据视觉效果调整大小 initialRows - 初始窗口高度，同样因人而异，因屏幕而异，自己根据视觉效果调整大小 startingDirectory - Ubuntu的默认打开路径，把其中的luobo换成你自己的用户名。  WSL+VSCode 毕竟都是微软家的软件，直接就能通过VSCode来远程编辑Linux里的文件。vim太难上手？我直接在Windows里编程(雾)。\n只要在项目目录里键入code .，就会自动跳到Windows里的VSCode里了。\n小结 WSL+Windows Terminal+VSCode，将三者配合起来，我觉得可以实现1+1+1\u0026gt;3的功能，毕竟，谁不喜欢颜值高的软件呢ヾ(≧▽≦*)o\n参考链接  微软官方WSL2教程 微软官方Windows Terminal教程 Windows Terminal 终端入门  ","date":"2021-04-08T13:14:20+08:00","image":"https://lbqaq.top/p/wsl2-wt%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93/43493473.webp","permalink":"https://lbqaq.top/p/wsl2-wt%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93/","title":"WSL2+WT配置小结"},{"content":"PyAipao简介 该项目可实现阳光体育一键跑步，同时可基于GitHub Actions来实现云跑步。\n仅需一次配置，即可轻松跑完一学期ヾ(≧▽≦*)o\n准备工作 1.一个github账号 2.抓包抓到的IMEICode 3.Server酱的SCKEY或企业微信（可选，用于微信推送跑步结果）  云跑步上手教程 1.点击fork按钮将该仓库复制到你的仓库  fork \n2.获取 IMEICode\n 打开抓包软件抓包, 再打开阳光体育 App 登录, 在所有的数据包中找后缀有 IMEICode=  的 URL 请求, 等号后面的字段即为七天有效的 IMEICode (若多次没抓到: 可来回切换几次飞行模式, 杀掉 App 后台重复尝试多次)  如果不需要推送，可以直接略过第3步\n3.1基于Server酱的推送\n 完成Server酱的注册和绑定 点我直达 在 SendKey这一页中找到SendKey并记录  SendKey   3.2基于企业微信应用消息的推送\n由于Server酱不捐助是无法查看消息内容的，所以为了白嫖我自己写了推送部分的代码，可以直接使用微信官方接口来推送。\n企业微信的配置方法可以在Server酱的消息通道里看到，这里就不赘述了。\n weisend \n和Server酱一样，我们也需要企业ID(CORPID)，应用ID(AGENTID)，应用Secret(SECRET)这三个值。\n4.配置Github Actions\n  打开仓库的secrets，在其中建立IMEICODE并将IMEICode填入  4.1 \n  （可选）使用Server酱推送，需要建立SCKEY并填入SendKey\n  （可选）使用企业微信应用消息推送，需要建立CORPID\u0026ndash;填入企业ID，AGENTID\u0026ndash;填入应用ID，SECRET\u0026ndash;填入应用Secret\n  打开Code-.github/workflows-autorun.yml，点击右上角的铅笔图标进行编辑，将时间改为你想让它每天按时跑的时间，默认为每天上午9点；同时修改推送方式，默认不推送。\n   4.2 \n注意：autorun.yml里的时间为UTC时间而不是北京时间 点我转换\n  启用Github Actions\n workflow \n   4.3 \n到这步已经配置完成了，它每天就会自己跑了。\n5.(可选)手动开始跑步\n 如果想手动开始跑步，点击Actions，按照图示步骤操作即可。  5.1   6.关闭自动跑步\n  在仓库Settings-Actions中选择Disable Actions\n 6.1 \n  参考链接  AutoAction AiPao  注意事项 License GPL v3.0\n本文仅供研究，使用者造成的任何后果由使用者自行承担，与作者无关。\n","date":"2021-03-11T10:25:00+08:00","image":"https://lbqaq.top/p/pyaipao/87856451.webp","permalink":"https://lbqaq.top/p/pyaipao/","title":"PyAipao"},{"content":"看到zsnmwy大佬的博客，和我使用的是同样的主题，但是人家却多了一些动画，瞬间就高级起来了。于是打开百度搜素一波，发现只要改一下CSS就可以实现了。\n准备工具   hugo的扩展版（extended）\n这里一定要下扩展版，因为我使用的主题都是利用scss来生成css的，如果用普通版是无法利用scss生成对应的css的。之前不知道下的是普通版，结果怎么改scss都没有效果，浪费了很多时间😥。\n  相关代码 1.头像转动 在themes/hugo-theme-stack/assets/scss/partials/sidebar.scss中增加以下代码：\n.site-logo { transition: all 1.75s ease-out; } .site-logo:hover { transform: rotate(360deg); } 2.文章头图缩放 在themes/hugo-theme-stack/assets/scss/partials/article.scss中增加以下代码：\n.article-image { overflow:hidden; } .article-image { img { transition:all .5s ease; } \u0026amp;:hover{ transform:scale(1.2); } 3.Archives页面缩放 在themes/hugo-theme-stack/assets/scss/partials/article.scss中增加以下代码：\narticle{ transition:.5s ease; } article { \u0026amp;:hover{ transform:scale(1.05,1.05); background:#f0f8ff; } } 4.菜单缩放 在themes/hugo-theme-stack/assets/scss/partials/menu.scss中增加以下代码：\noverflow-y: visible; //把auto改为visible，为了图标放大溢出时不显示滚动条 li { transition:.5s ease; } li{ \u0026amp;:hover{ transform:scale(1.1,1.1); } } 有了动画后，感觉整个博客都变得高级起来了ヾ(•ω•`)o\n在这感谢zsnmwy大佬，上面有些动画懒得自己写了，就直接从他的css中复制了ヾ(￣▽￣)\n","date":"2021-02-01T13:55:05+08:00","image":"https://lbqaq.top/p/%E7%BB%99blog%E5%A2%9E%E5%8A%A0%E5%8A%A8%E7%94%BB/86589864.webp","permalink":"https://lbqaq.top/p/%E7%BB%99blog%E5%A2%9E%E5%8A%A0%E5%8A%A8%E7%94%BB/","title":"给Blog增加动画"},{"content":"最近刷了好几道关于STL的竞赛题，许多知识点还是不熟练，在继续学习之前，还是来好好整理一下一些常见的STL和容器吧。紫书上介绍的有以下几种：\n 线性：vector,list,string 关联：map,set 特殊：stack,queue,priority_queue 算法：sort,lower_bound,find  vector vector可以理解为可以自由变换长度的数组(不定长数组)，个人感觉使用频率还是很高的。vector是连续的，意味着可以使用[]或at()。\n声明： vector\u0026lt;int\u0026gt; a\n常用函数   push_back：在尾部添加一个数据\n  pop_back：删除尾部的一个数据\n  size：当前的大小（就是有多少元素）\n  erase：删除指针指向的数据项\n  clear：清空\n  empty：判断是否为空\n  deque deque可以看作是双向队列，是连续存储结构。vector有的功能它都有，还支持高效的首/尾端插入/删除操作。\n新增函数  push_front：在头部添加一个数据 pop_front：在头部删除一个数据  list list可以看作是双链表，是非连续存储结构。可在两端进行push、pop，同时在内部可以很方便的进行插入和删除操作。不过我没怎么用到这个容器。等我做到相关的题目再来补充一些信息吧。\nstring string就是字符串。相比char[]那可是方便不少，c++的cin/cout就只支持string类型而不支持char型数组。string还支持+、=、+=等运算符。\n常用函数   append：在字符串后添加（相当于+=）\n  substr(n,m)：返回string的子串，从n处开始，取m个。当m省略或超过了字符串的长度，则一直取到字符串结束。\n  查找相关函数：\n如果没有查到，返回string::npos。\n  find：从前往后查找子串或字符出现的位置。\n  rfind：从后往前查找子串或字符出现的位置。\n  find_first_of：从前往后查找何处出现另一个字符串中包含的字符。例如：\n  s1.find_first_of(\u0026ldquo;abc\u0026rdquo;); //查找s1中第一次出现\u0026quot;abc\u0026quot;中任一字符的位置\n  find_last_of：从后往前查找何处出现另一个字符串中包含的字符。\n  find_first_not_of：从前往后查找何处出现另一个字符串中没有包含的字符。\n  find_last_not_of：从后往前查找何处出现另一个字符串中没有包含的字符。\n  流处理 可以通过\u0026lt;sstream\u0026gt;，将string对象作为一个流。例如：\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;sstream\u0026gt;#include \u0026lt;string\u0026gt;using namespace std; int main(){ string line; while(getline(cin,line)){ stringstream ss(line); while(ss\u0026gt;\u0026gt;x){...} } } set set就是数学中的集合，每个元素只能出现一次，set中的元素已经从小到大排好了。\n常用函数  insert：插入一个元素 erase：删除，可以传入定位器，也可直接传入值 count：统计元素出现的个数，因为只有0/1个，所以一般用来判断元素是否存在 find：查找  对于自己定义的结构体，需要重载\u0026lt;运算符。\n常用算法 在\u0026lt;algorithm\u0026gt;中提供了关于set的两种算法（目前只知道两种）\n  set_union：取两个集合的并集，例如：\n#define ALL(x) x.begin(),x.end() #define INS(x) inserter(x,x.begin()) set_union(ALL(x1),ALL(x2),INS(x)); //将x1和x2的内容取并集后放入x中   set_intersection：取两个集合的交集，例如：\nset_intersection(ALL(x1),ALL(x2),INS(x)); //将x1和x2的内容取交集放入x中   map map是映射，支持[]运算符，还是非常实用的。\nmap的函数和set基本一致，这里就不重复写了。\nstack stack就是数据结构中的栈，数据是“后进先出”。\n基本函数  push：入栈 pop：出栈 top：取栈顶元素  要注意的是，使用pop()出栈并不会返回被删除的元素值，如果想要需要先top()一下\nqueue queue就是数据结构里的队列，数据符合“先进先出”的规则。\n基本函数   push：入队\n  pop：出队\n  front：取队首\n  priority_queue 优先队列，将按照优先级来排序，取队首的front()的函数将换为top()。该容器也定义在头文件\u0026lt;queue\u0026gt;里。\n对于自定义数据类型的队列，需要定义\u0026lt;运算。对于已经定义过的数据类型，我们可以通过定义一个结构体，在其中重载()运算符来看起来像一个函数，例如：\nstruct cmp { bool operator()(const int a, const int b) const { return abs(a) \u0026lt; abs(b); } }; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, cmp\u0026gt; p_queue; 这样就定义了一个绝对值大小优先的队列\n","date":"2021-01-31T20:39:29+08:00","image":"https://lbqaq.top/p/%E7%AB%9E%E8%B5%9B%E7%94%A8stl%E6%95%B4%E7%90%86/85526504.webp","permalink":"https://lbqaq.top/p/%E7%AB%9E%E8%B5%9B%E7%94%A8stl%E6%95%B4%E7%90%86/","title":"竞赛用STL整理"},{"content":"考前整理的算法，也顺便放到博客上吧ヾ(•ω•`)o\n数据结构代码复习 3.单链表逆置 带头结点\nint Inverse_Link(LinkList *L) { LinkList *cur, *p; if (L-\u0026gt;next \u0026amp;\u0026amp; L-\u0026gt;next-\u0026gt;next) { p = L-\u0026gt;next-\u0026gt;next; L-\u0026gt;next-\u0026gt;next = NULL; while (p) { cur = L-\u0026gt;next; L-\u0026gt;next = p; p = p-\u0026gt;next; L-\u0026gt;next-\u0026gt;next = cur; } } return 0; } 5.双向链表 双链表定义：\ntypedef struct DuLinkList { int data; struct DuLinkList *prior; struct DuLinkList *next; } DuLinkList; 遍历：\nvoid Printlist_DuL(DuLinkList *L) { DuLinkList *s; s = L-\u0026gt;next; if (L-\u0026gt;next != NULL) { printf(\u0026#34;当前的双向链表值为：\u0026#34;); do { printf(\u0026#34;%d \u0026#34;, s-\u0026gt;data); s = s-\u0026gt;next; } while (s != NULL); } printf(\u0026#34;\\n\u0026#34;); } 交换：\nint ListSwap_DuL(DuLinkList *L, int i) { //在带头结点的双向链表中交换第i个，i+1个位置的元素  DuLinkList *p = L, *q; int j = 0; while (p \u0026amp;\u0026amp; j \u0026lt; i - 1) { p = p-\u0026gt;next; j += 1; } if (!p || j \u0026gt; i - 1) return -1; p = p-\u0026gt;next; q = p-\u0026gt;next; p-\u0026gt;prior-\u0026gt;next = q; //1 -\u0026gt;q p 2  q-\u0026gt;prior = p-\u0026gt;prior; //1\u0026lt;--\u0026gt;q p 2  p-\u0026gt;next = q-\u0026gt;next; //1\u0026lt;--\u0026gt;q p -\u0026gt;2  q-\u0026gt;next-\u0026gt;prior = p; //1\u0026lt;--\u0026gt;q p\u0026lt;--\u0026gt;2  q-\u0026gt;next = p; //1\u0026lt;--\u0026gt;q -\u0026gt;p\u0026lt;--\u0026gt;2  p-\u0026gt;prior = q; //1\u0026lt;--\u0026gt;q\u0026lt;--\u0026gt;p\u0026lt;--\u0026gt;2  return 0; } 6.链表回文 bool isPalindrome(struct ListNode *head) { Lstack *s; int e; struct ListNode *p = head; s = (Lstack *)malloc(sizeof(Lstack)); Initlist_Stack(s); while (p) { push(s, p-\u0026gt;val); p = p-\u0026gt;next; } p = head; while (p) { e = pop(s); if (p-\u0026gt;val != e) break; p = p-\u0026gt;next; } if (p) return false; else return true; } 7-1.链队列 定义：\ntypedef struct QNode //队列 { int data; struct QNode *next; } QNode; typedef struct LinkQueue //对列相关的指针 { QNode *front; //对头指针  QNode *rear; //队尾指针 } LinkQueue; 插入：\nint EnQueue(LinkQueue *q, int e) { //[入队]将元素e放入队尾，带头结点  QNode *p; p = (QNode *)malloc(sizeof(QNode)); p-\u0026gt;data = e; p-\u0026gt;next = NULL; q-\u0026gt;rear-\u0026gt;next = p; q-\u0026gt;rear = p; return 0; } 7-2.循环链表 插入和普通单链表没区别，这里就列举部分\ns = (LinkList *)malloc(sizeof(LinkList)); s-\u0026gt;data = e; s-\u0026gt;next = p-\u0026gt;next; p-\u0026gt;next = s; 8.求二叉树各种数的算法 （1）求高度 高度很简单，来个递归就完事了\nint BiTreeHeight(BiTNode *T) { //求二叉树的高度  int treeHeight = 0; if (T != NULL) { int leftHeight = BiTreeHeight(T-\u0026gt;lchild); int rightHeight = BiTreeHeight(T-\u0026gt;rchild); treeHeight = leftHeight \u0026gt;= rightHeight ? leftHeight + 1 : rightHeight + 1; } return treeHeight; } （2）求叶子数 叶子数也一样，递归永远滴神\nvoid BiTreeLeafCount(BiTNode *T, int *count) { //求二叉树叶子结点数  if (!T) return; if (T-\u0026gt;lchild == NULL \u0026amp;\u0026amp; T-\u0026gt;rchild == NULL) *count += 1; BiTreeLeafCount(T-\u0026gt;lchild, count); BiTreeLeafCount(T-\u0026gt;rchild, count); } （3）求结点数 这不就遍历嘛，直接看下面吧=￣ω￣=\n9.二叉树的中序遍历 递归：\nint InOrderTraverse(BiTNode *T) { //中序遍历二叉树T的递归算法  if (T == NULL) return 0; InOrderTraverse(T-\u0026gt;lchild); printf(\u0026#34;%c \u0026#34;, T-\u0026gt;data); InOrderTraverse(T-\u0026gt;rchild); } 非递归（重要）：\nint inorder(BiTNode *T) { //中序遍历二叉树T的非递归算法  BiTNode *s[MAXSIZE + 1]; int top = 0; while (T != NULL || top != 0) { while (T != NULL) { s[++top] = T; T = T-\u0026gt;lchild; } if (top != 0) { T = s[top--]; printf(\u0026#34;%c \u0026#34;, T-\u0026gt;data); T = T-\u0026gt;rchild; } } return 0; } 10.二叉排序树 int Search_BST(BSTree t, int key, BSTree f, BSTree *p) { //在指针t所指的二叉排序树上查找key，成功则p指向该元素数据结点并返回0  //否则p指向查找路径上最后一个结点并返回1，f指向T的双亲，初始值为NULL  if (!t) { *p = f; return 1; } else if (key == t-\u0026gt;data) { *p = t; return 0; } else if (key \u0026lt; t-\u0026gt;data) { return Search_BST(t-\u0026gt;lchild, key, t, p); } else return Search_BST(t-\u0026gt;rchild, key, t, p); } int Insert_BST(BSTree *t, int key) { //二叉排序树的插入，当不存在key时插入并返回0，否则返回1  BSTree p, s; p = NULL; if (Search_BST(*t, key, NULL, \u0026amp;p)) { s = (BSTree)malloc(sizeof(BSTNode)); s-\u0026gt;data = key; s-\u0026gt;lchild = s-\u0026gt;rchild = NULL; if (!p) *t = s; else if (key \u0026lt; p-\u0026gt;data) p-\u0026gt;lchild = s; else p-\u0026gt;rchild = s; return 0; } else return 1; } 14.图的遍历 （1）深度优先 入栈时打印结点信息\n递归：\nvoid DFS(ALGraph *G, int v, int visited[]) { ArcNode *p; int w, i; visited[v] = 1; printf(\u0026#34;%d \u0026#34;, v); p = G-\u0026gt;vertices[v].firstarc; while (p != NULL) { w = p-\u0026gt;adjvex; if (visited[w] == 0) DFS(G, w, visited); p = p-\u0026gt;nextarc; } } 非递归：\nvoid DFS1(ALGraph *G, int v) { ArcNode *p; int w, i; int visited[MAX_VERTEX_NUM]; ArcNode *s[MAX_VERTEX_NUM]; //顺序栈  int top = 0; for (i = 1; i \u0026lt;= G-\u0026gt;vexnum; i++) visited[i] = 0; //访问标志数组初始化  visited[v] = 1; printf(\u0026#34;%2d\u0026#34;, v); p = G-\u0026gt;vertices[v].firstarc; while (p != NULL || top != 0) { while (p != NULL) { w = p-\u0026gt;adjvex; if (visited[w] == 0) { printf(\u0026#34;%2d\u0026#34;, w); visited[w] = 1; s[++top] = p; p = G-\u0026gt;vertices[w].firstarc; } else p = p-\u0026gt;nextarc; } if (top != 0) { p = s[top--]; p = p-\u0026gt;nextarc; } } } （2）广度优先 出队列时打印结点信息\nvoid BFS(ALGraph *G, int v) { ArcNode *p; int w, i; int queue[MAX_VERTEX_NUM], front = 0, rear = 0; // 定义循环队列  int visited[MAX_VERTEX_NUM]; for (i = 1; i \u0026lt;= G-\u0026gt;vexnum; i++) visited[i] = 0; //访问标志数组初始化  printf(\u0026#34;%2d\u0026#34;, v); //输出被访问顶点的编号  visited[v] = 1; //置已访问标记  rear = (rear + 1) % MAX_VERTEX_NUM; queue[rear] = v; //v进队  while (front != rear) // 队列不空时循环  { front = (front + 1) % MAX_VERTEX_NUM; w = queue[front]; //出队并赋给w  p = G-\u0026gt;vertices[w].firstarc; //找w的第一个的邻接点  while (p != NULL) { if (visited[p-\u0026gt;adjvex] == 0) { printf(\u0026#34;%2d\u0026#34;, p-\u0026gt;adjvex); //访问之  visited[p-\u0026gt;adjvex] = 1; rear = (rear + 1) % MAX_VERTEX_NUM; //相邻顶点进队  queue[rear] = p-\u0026gt;adjvex; } p = p-\u0026gt;nextarc; //找下一个邻接顶点  } } } 15.双向冒泡 void BubbleSort1(int R[], int n) { //双向冒泡  int i, j, lastExchange, lastExchange1, i1, temp; i = n; //i 指示无序序列中最后一个记录的位置  i1 = 1; while (i \u0026gt; i1) { lastExchange = 1; //记录正序最后一次交换发生的位置  lastExchange1 = n; //记录逆序最后一次交换发生的位置  for (j = i1; j \u0026lt; i; j++) if (R[j] \u0026gt; R[j + 1]) { temp = R[j]; R[j] = R[j + 1]; R[j + 1] = temp; //逆序时交换  lastExchange = j; } for (j = lastExchange; j \u0026gt; i1; j--) if (R[j] \u0026lt; R[j - 1]) { temp = R[j]; R[j] = R[j - 1]; R[j - 1] = temp; //逆序时交换  lastExchange1 = j; } i = lastExchange; i1 = lastExchange1; } } ","date":"2021-01-10T15:06:20+08:00","image":"https://lbqaq.top/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/83667969.webp","permalink":"https://lbqaq.top/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/","title":"数据结构算法复习"},{"content":"生成随机数 在C语言中，生成随机数可以使用stdlib.h头文件里的rand()来生成，例如：\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;int main(){ int a = rand(); printf(\u0026#34;%d\\n\u0026#34;,a); return 0; } rand() 会随机生成一个位于 0 ~ RAND_MAX 之间的整数。\n但是这样生成的随机数每次开启程序都是一样的，则需要使用srand()来重新播种，一般常与\u0026lt;time.h\u0026gt;里的time()函数一起使用。\nsrand((unsigned)time(NULL)); 连续生成多个随机数 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;time.h\u0026gt;int main() { int a, i; srand((unsigned)time(NULL)); //使用for循环生成10个随机数  for (i = 0; i \u0026lt; 10; i++) { a = rand(); printf(\u0026#34;%d \u0026#34;, a); } return 0; } 生成指定范围的随机数 想要生成指定范围的随机数，只要进行%运算就好了\nint a = rand() % 10; //产生0~9的随机数 int a = rand() % 10 + 1; //产生1~10的随机数 连续生成不重复的随机数 这就是本文的重点了ヾ(•ω•`)o （其实就是为了记下这个算法才水了一篇文章）\nint *GetRandom(int m) { //根据给定的m生成随机不重复的数组a  int i, n, w, t; int *a; n = 2 * m; srand((unsigned int)time(0)); a = (int *)malloc(n * sizeof(int)); for (i = 0; i \u0026lt; n; i++) a[i] = i + 1; for (i = 1; i \u0026lt;= m; i++) { w = rand() % (n - i) + i; t = a[i]; a[i] = a[w]; a[w] = t; } return a; } ","date":"2020-12-22T19:36:53+08:00","image":"https://lbqaq.top/p/c%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/84444030.webp","permalink":"https://lbqaq.top/p/c%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/","title":"C语言生成随机数"},{"content":"基本操作 建立版本库：git init\n查看结果：git status\n查看不同：git diff\n版本回退 查看提交日记：git log\n回退：git reset --hard HEAD^\nHEAD^表示上一个版本，HEAD^^表示前两个版本，HEAD~100表示前100个版本\n恢复：git reflog查看命令历史，确定回到未来的哪个版本\n撤销修改  直接丢弃工作区的修改时，用命令git checkout -- file 已经添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD \u0026lt;file\u0026gt;，第二步按1操作。  上传 git remote add origin 仓库链接 #将远程仓库和本地仓库绑定 git add . git commit -m \u0026quot;提交信息\u0026quot; git push -u origin 自己当前的分支名 #-u将本地库和远程库的分支关联，之后可以不加 下载 git clone 仓库链接 git clone到当前文件夹\ngit clone 仓库链接 . 分支管理 创建与合并分支 查看分支：git branch\n创建分支：git branch \u0026lt;name\u0026gt;\n切换分支：git checkout \u0026lt;name\u0026gt;或者git switch \u0026lt;name\u0026gt;\n创建+切换分支：git checkout -b \u0026lt;name\u0026gt;或者git switch -c \u0026lt;name\u0026gt;\n删除分支：git branch -d \u0026lt;name\u0026gt;\n合并某分支到当前分支：git merge \u0026lt;name\u0026gt;\n 当Git无法自动合并分支时，就必须首先解决冲突，自己手动修改冲突文件再合并即可。 查看分支合并图：git log --graph 使用非快速模式合并，有commit：git merge --no-ff -m \u0026quot;merge with no-ff\u0026quot; dev  Bug分支 需要紧急处理Bug时，可以使用git stash将现在的工作区暂存\n恢复原来的工作区\n 恢复但不删除stash内容：git stash apply 手动删除stash内容：git stash drop 恢复且删除stash内容：git stash pop  可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，如：\ngit stash apply stash@{0} 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick \u0026lt;commit\u0026gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。\n多人协作   查看远程库信息，使用git remote -v\n  从本地推送分支，使用git push origin branch-name\n  如果冲突，先git pull抓取远程的新提交，处理好后再push\n  在本地创建和远程分支对应的分支：git checkout -b branch-name origin/branch-name\n  建立本地分支和远程分支的关联：git branch --set-upstream branch-name origin/branch-name\n  将非直线的提交日记变为直线：git rebase\n  标签管理 创建标签   新建一个标签：git tag \u0026lt;name\u0026gt;,默认为HEAD，也可以指定一个commit id\n  指定标签信息：git tag -a \u0026lt;tagname\u0026gt; -m \u0026quot;blablabla...\u0026quot;\n  查看所有标签：git tag\n  标签管理  推送一个本地标签：git push origin \u0026lt;tagname\u0026gt; 推送全部未推送过的本地标签：git push origin --tags 删除一个本地标签：git tag -d \u0026lt;tagname\u0026gt; 删除一个远程标签：git push origin :refs/tags/\u0026lt;tagname\u0026gt;  ","date":"2020-12-16T13:16:45+08:00","image":"https://lbqaq.top/p/git/79008828.webp","permalink":"https://lbqaq.top/p/git/","title":"Git的常用命令"},{"content":"主题相关 FrontMatter 字段含义\ntitle: 标题 description: 描述 image: 显示的特色图片 comments: 显示 / 隐藏评论区(T/F) license: 文章协议 输入 false 可以隐藏 hidden: 隐藏文章（不在首页，归档等页面显示，但是可以直接通过链接访问） math: 是否加载 KaTeX 脚本 slug: 固定链接 draft: 是否为草稿 categories: 分类 tags: 标签 lastmod: 上次更新时间 MarkDown相关 # 我是一级标题 ## 我是二级标题 可对应1-6级标题 *斜体文本* **粗体文本** ***粗斜体文本*** 一行中用三个以上的星号*、减号-、底线_来建立一个分隔线 ~~删除线~~ \u0026lt;u\u0026gt;带下划线文本\u0026lt;/u\u0026gt; 创建脚注格式类似这样 [^JiaoZhu]。 [^JiaoZhu]: 脚注的内容 列表：*、+、-、1. \u0026gt; 区块 [链接文本](网址) 图片在前加! | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 ","date":"2020-12-15T18:02:14+08:00","image":"https://lbqaq.top/p/blog%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/80228475.webp","permalink":"https://lbqaq.top/p/blog%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/","title":"Blog常用的命令"}]