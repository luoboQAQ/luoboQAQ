[{"content":"这篇文章我打算来介绍一下如何构建qsqlmysql.dll，由于版权原因，在新版的Qt里是不自带该dll的，这样对我们编写数据库程序会很麻烦。（你用ODBC？那没事了）\n我在网上也查了很多资料，但根据步骤来总是会报错，提示没有mysql.h这个头文件。下面就记录一下我成功编译的过程。\n步骤 注意： 路径的前段部分(软件的安装位置)每个人可能都不一样，但是路径的后段部分应该是一样的，请自行修改\n1.准备好Qt的源代码，如果没有可以点Uninstall Qt启动Qt组件管理，在里面勾选Src把源码下载下来。\n2.进入D:\\Qt\\6.0.3\\Src\\qtbase\\src\\plugins\\sqldrivers目录下，打开sqldrivers.pro这个文件。\n3.在左侧文件树中打开mysql文件夹，选择mysql.pro打开。\n4.修改里面的内容：\n  注释掉QMAKE_USE += mysql这一句\n  增加下面三行代码(注意把D:/MySQL/改为你MySQL的安装路径)：\nLIBS +=-LD:/MySQL/lib -llibmysql INCLUDEPATH += D:/MySQL/include DEPENDPATH += D:/MySQL/include   5.点击Qt左下角的小锤子进行构建，不出意外的话就可以在D:\\Qt\\6.0.3\\Src\\qtbase\\src\\plugins这个路径下看到build开头的文件夹，在.\\plugins\\sqldrivers目录下就能看到编译好的dll了。\n6.最后将qsqlmysql.dll放入D:\\Qt\\6.0.3\\mingw81_64\\plugins\\sqldrivers\\里就行了。如果链接数据库时还报错，就把libmysql.dll复制到Qt的编译器的D:\\Qt\\6.0.3\\mingw81_64\\bin\\目录。\n","date":"2021-06-03T15:44:17+08:00","image":"https://example.com/p/qt%E6%9E%84%E5%BB%BAqsqlmysql.dll/89217963_hu5f736f3854c953c513cfaec8c3d31831_4303313_120x120_fill_box_smart1_2.png","permalink":"https://example.com/p/qt%E6%9E%84%E5%BB%BAqsqlmysql.dll/","title":"Qt构建qsqlmysql.dll"},{"content":"1202年了，是时候抛弃老旧的cmd窗口和臃肿的VM虚拟机了，来试试巨硬推出的WSL2+Windows Terminal(～￣▽￣)～。\n起因 在知乎上刷到了一篇回答，是关于Windows编程的体验的。在这篇文章中提到了WSL2和Windows Terminal，我一下就被那精美的界面吸引了（管他好不好用，好看就完事了）。正好现在在上操作系统这门课，需要使用Linux进行实验，这还说什么，直接开冲。\n 精美的界面 \nWSL2安装 安装其实很简单，按照微软的教程一步一步做就完事了。\n0.前置条件 想要用WSL2，首先你得是 Windows 10，而且还有版本号要求。\n 对于 x64 系统：版本 1903 或更高版本，采用 内部版本 18362 或更高版本。 对于 ARM64 系统：版本 2004 或更高版本，采用 内部版本 19041 或更高版本。  1. 开启WSL服务 在Powershell(管理员)中输入下面的命令：\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 2. 启用虚拟机服务 在Powershell(管理员)中输入下面的命令：\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 重新启动 计算机，以完成 WSL 安装并更新到 WSL 2。\n3. 下载 Linux 内核更新包 下载最新包并安装：\n 适用于 x64 计算机的 WSL2 Linux 内核更新包  4. 将 WSL 2 设置为默认版本 在Powershell中输入下面的命令：\nwsl --set-default-version 2 5.安装 Linux  打开 Microsoft Store，并选择你偏好的 Linux 分发版并点击获取进行安装。 等安装好后，打开并设置用户名和密码。  到此WSL2就安装完事了。\nWindows Terminal安装 1. 下载和安装   从Microsoft Store中下载\n  从Github上下载\n  2. 配置 为了让Windows Terminal看起来更好看一些，我们还要对其进行一些配置。\n 设置 \n打开Windows Terminal的设置选项，然后选打开JSON文件，把我配好的配置文件粘贴进去\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://aka.ms/terminal-profiles-schema\u0026#34;, // Add custom actions and keybindings to this array. // To unbind a key combination from your defaults.json, set the command to \u0026#34;unbound\u0026#34;. // To learn more about actions and keybindings, visit https://aka.ms/terminal-keybindings \u0026#34;actions\u0026#34;: [ // Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json. // These two lines additionally bind them to Ctrl+C and Ctrl+V. // To learn more about selection, visit https://aka.ms/terminal-selection { \u0026#34;command\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;copy\u0026#34;, \u0026#34;singleLine\u0026#34;: false }, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+c\u0026#34; }, { \u0026#34;command\u0026#34;: \u0026#34;paste\u0026#34;, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+v\u0026#34; }, // Press Ctrl+Shift+F to open the search box { \u0026#34;command\u0026#34;: \u0026#34;find\u0026#34;, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+shift+f\u0026#34; }, // Press Alt+Shift+D to open a new pane. // - \u0026#34;split\u0026#34;: \u0026#34;auto\u0026#34; makes this pane open in the direction that provides the most surface area. // - \u0026#34;splitMode\u0026#34;: \u0026#34;duplicate\u0026#34; makes the new pane use the focused pane\u0026#39;s profile. // To learn more about panes, visit https://aka.ms/terminal-panes { \u0026#34;command\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;splitPane\u0026#34;, \u0026#34;split\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;splitMode\u0026#34;: \u0026#34;duplicate\u0026#34; }, \u0026#34;keys\u0026#34;: \u0026#34;alt+shift+d\u0026#34; } ], \u0026#34;copyFormatting\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;copyOnSelect\u0026#34;: false, \u0026#34;defaultProfile\u0026#34;: \u0026#34;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\u0026#34;, \u0026#34;initialCols\u0026#34;: 120, \u0026#34;initialRows\u0026#34;: 30, \u0026#34;profiles\u0026#34;: { \u0026#34;defaults\u0026#34;: { \u0026#34;acrylicOpacity\u0026#34;: 0.75, \u0026#34;closeOnExit\u0026#34;: \u0026#34;graceful\u0026#34;, \u0026#34;colorScheme\u0026#34;: \u0026#34;Campbell\u0026#34;, \u0026#34;cursorColor\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, \u0026#34;cursorShape\u0026#34;: \u0026#34;bar\u0026#34;, \u0026#34;fontFace\u0026#34;: \u0026#34;Consolas\u0026#34;, \u0026#34;fontSize\u0026#34;: 13, \u0026#34;historySize\u0026#34;: 9001, \u0026#34;padding\u0026#34;: \u0026#34;0, 0, 0, 0\u0026#34;, \u0026#34;snapOnInput\u0026#34;: true, \u0026#34;startingDirectory\u0026#34;: \u0026#34;./\u0026#34;, \u0026#34;useAcrylic\u0026#34;: true }, \u0026#34;list\u0026#34;: [ { \u0026#34;commandline\u0026#34;: \u0026#34;powershell.exe -NoLogo\u0026#34;, \u0026#34;guid\u0026#34;: \u0026#34;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Windows PowerShell\u0026#34; }, { \u0026#34;commandline\u0026#34;: \u0026#34;cmd.exe\u0026#34;, \u0026#34;guid\u0026#34;: \u0026#34;{0caa0dad-35be-5f56-a8ff-afceeeaa6101}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Command Prompt\u0026#34; }, { \u0026#34;guid\u0026#34;: \u0026#34;{b453ae62-4e3d-5e58-b989-0a998ec441b8}\u0026#34;, \u0026#34;hidden\u0026#34;: true, \u0026#34;name\u0026#34;: \u0026#34;Azure Cloud Shell\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;Windows.Terminal.Azure\u0026#34; }, { \u0026#34;guid\u0026#34;: \u0026#34;{2c4de342-38b7-51cf-b940-2309a097f518}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Ubuntu\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;Windows.Terminal.Wsl\u0026#34;, \u0026#34;startingDirectory\u0026#34;: \u0026#34;//wsl$/Ubuntu/home/luobo\u0026#34; } ] } } 一般要修改这几项：\n fontFace - 字体，我的字体为Consolas，适合1080P的屏幕。高分辩率屏建议用monaco或者fira code fontSize - 字体大小，因人而异，因屏幕而异，自己根据视觉效果调整大小 acrylicOpacity - 背景透明度，同样因人而异，因屏幕而异，自己根据视觉效果调整大小 initialCols - 初始窗口宽度，同样因人而异，因屏幕而异，自己根据视觉效果调整大小 initialRows - 初始窗口高度，同样因人而异，因屏幕而异，自己根据视觉效果调整大小 startingDirectory - Ubuntu的默认打开路径，把其中的luobo换成你自己的用户名。  WSL+VSCode 毕竟都是微软家的软件，直接就能通过VSCode来远程编辑Linux里的文件。vim太难上手？我直接在Windows里编程(雾)。\n只要在项目目录里键入code .，就会自动跳到Windows里的VSCode里了。\n小结 WSL+Windows Terminal+VSCode，将三者配合起来，我觉得可以实现1+1+1\u0026gt;3的功能，毕竟，谁不喜欢颜值高的软件呢ヾ(≧▽≦*)o\n参考链接  微软官方WSL2教程 微软官方Windows Terminal教程 Windows Terminal 终端入门  ","date":"2021-04-08T13:14:20+08:00","image":"https://example.com/p/wsl2-wt%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93/43493473_hu0b461f4faf109c1e7e1e6db59436d03b_285140_120x120_fill_box_smart1_2.png","permalink":"https://example.com/p/wsl2-wt%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93/","title":"WSL2+WT配置小结"},{"content":"PyAipao简介 该项目可实现阳光体育一键跑步，同时可基于GitHub Actions来实现云跑步。\n仅需一次配置，即可轻松跑完一学期ヾ(≧▽≦*)o\n准备工作 1.一个github账号 2.抓包抓到的IMEICode 3.Server酱的SCKEY或企业微信（可选，用于微信推送跑步结果）  云跑步上手教程 1.点击fork按钮将该仓库复制到你的仓库  fork \n2.获取 IMEICode\n 打开抓包软件抓包, 再打开阳光体育 App 登录, 在所有的数据包中找后缀有 IMEICode=  的 URL 请求, 等号后面的字段即为七天有效的 IMEICode (若多次没抓到: 可来回切换几次飞行模式, 杀掉 App 后台重复尝试多次)  如果不需要推送，可以直接略过第3步\n3.1基于Server酱的推送\n 完成Server酱的注册和绑定 点我直达 在 SendKey这一页中找到SendKey并记录  SendKey   3.2基于企业微信应用消息的推送\n由于Server酱不捐助是无法查看消息内容的，所以为了白嫖我自己写了推送部分的代码，可以直接使用微信官方接口来推送。\n企业微信的配置方法可以在Server酱的消息通道里看到，这里就不赘述了。\n weisend \n和Server酱一样，我们也需要企业ID(CORPID)，应用ID(AGENTID)，应用Secret(SECRET)这三个值。\n4.配置Github Actions\n  打开仓库的secrets，在其中建立IMEICODE并将IMEICode填入  4.1 \n  （可选）使用Server酱推送，需要建立SCKEY并填入SendKey\n  （可选）使用企业微信应用消息推送，需要建立CORPID\u0026ndash;填入企业ID，AGENTID\u0026ndash;填入应用ID，SECRET\u0026ndash;填入应用Secret\n  打开Code-.github/workflows-autorun.yml，点击右上角的铅笔图标进行编辑，将时间改为你想让它每天按时跑的时间，默认为每天上午9点；同时修改推送方式，默认不推送。\n   4.2 \n注意：autorun.yml里的时间为UTC时间而不是北京时间 点我转换\n  启用Github Actions\n workflow \n   4.3 \n到这步已经配置完成了，它每天就会自己跑了。\n5.(可选)手动开始跑步\n 如果想手动开始跑步，点击Actions，按照图示步骤操作即可。  5.1   6.关闭自动跑步\n  在仓库Settings-Actions中选择Disable Actions\n 6.1 \n  参考链接  AutoAction AiPao  注意事项 License GPL v3.0\n本文仅供研究，使用者造成的任何后果由使用者自行承担，与作者无关。\n","date":"2021-03-11T10:25:00+08:00","image":"https://example.com/p/pyaipao/87856451_huf58260040af023debd102865c61ea42c_2928959_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/pyaipao/","title":"PyAipao"},{"content":"看到zsnmwy大佬的博客，和我使用的是同样的主题，但是人家却多了一些动画，瞬间就高级起来了。于是打开百度搜素一波，发现只要改一下CSS就可以实现了。\n准备工具   hugo的扩展版（extended）\n这里一定要下扩展版，因为我使用的主题都是利用scss来生成css的，如果用普通版是无法利用scss生成对应的css的。之前不知道下的是普通版，结果怎么改scss都没有效果，浪费了很多时间😥。\n  相关代码 1.头像转动 在themes/hugo-theme-stack/assets/scss/partials/sidebar.scss中增加以下代码：\n.site-logo { transition: all 1.75s ease-out; } .site-logo:hover { transform: rotate(360deg); } 2.文章头图缩放 在themes/hugo-theme-stack/assets/scss/partials/article.scss中增加以下代码：\n.article-image { overflow:hidden; } .article-image { img { transition:all .5s ease; } \u0026amp;:hover{ transform:scale(1.2); } 3.Archives页面缩放 在themes/hugo-theme-stack/assets/scss/partials/article.scss中增加以下代码：\narticle{ transition:.5s ease; } article { \u0026amp;:hover{ transform:scale(1.05,1.05); background:#f0f8ff; } } 4.菜单缩放 在themes/hugo-theme-stack/assets/scss/partials/menu.scss中增加以下代码：\noverflow-y: visible; //把auto改为visible，为了图标放大溢出时不显示滚动条 li { transition:.5s ease; } li{ \u0026amp;:hover{ transform:scale(1.1,1.1); } } 有了动画后，感觉整个博客都变得高级起来了ヾ(•ω•`)o\n在这感谢zsnmwy大佬，上面有些动画懒得自己写了，就直接从他的css中复制了ヾ(￣▽￣)\n","date":"2021-02-01T13:55:05+08:00","image":"https://example.com/p/%E7%BB%99blog%E5%A2%9E%E5%8A%A0%E5%8A%A8%E7%94%BB/86589864_hu78fbbc6652b920150235079836d94b1b_2463299_120x120_fill_box_smart1_2.png","permalink":"https://example.com/p/%E7%BB%99blog%E5%A2%9E%E5%8A%A0%E5%8A%A8%E7%94%BB/","title":"给Blog增加动画"},{"content":"最近刷了好几道关于STL的竞赛题，许多知识点还是不熟练，在继续学习之前，还是来好好整理一下一些常见的STL和容器吧。紫书上介绍的有以下几种：\n 线性：vector,list,string 关联：map,set 特殊：stack,queue,priority_queue 算法：sort,lower_bound,find  vector vector可以理解为可以自由变换长度的数组(不定长数组)，个人感觉使用频率还是很高的。vector是连续的，意味着可以使用[]或at()。\n声明： vector\u0026lt;int\u0026gt; a\n常用函数   push_back：在尾部添加一个数据\n  pop_back：删除尾部的一个数据\n  size：当前的大小（就是有多少元素）\n  erase：删除指针指向的数据项\n  clear：清空\n  empty：判断是否为空\n  deque deque可以看作是双向队列，是连续存储结构。vector有的功能它都有，还支持高效的首/尾端插入/删除操作。\n新增函数  push_front：在头部添加一个数据 pop_front：在头部删除一个数据  list list可以看作是双链表，是非连续存储结构。可在两端进行push、pop，同时在内部可以很方便的进行插入和删除操作。不过我没怎么用到这个容器。等我做到相关的题目再来补充一些信息吧。\nstring string就是字符串。相比char[]那可是方便不少，c++的cin/cout就只支持string类型而不支持char型数组。string还支持+、=、+=等运算符。\n常用函数   append：在字符串后添加（相当于+=）\n  substr(n,m)：返回string的子串，从n处开始，取m个。当m省略或超过了字符串的长度，则一直取到字符串结束。\n  查找相关函数：\n如果没有查到，返回string::npos。\n  find：从前往后查找子串或字符出现的位置。\n  rfind：从后往前查找子串或字符出现的位置。\n  find_first_of：从前往后查找何处出现另一个字符串中包含的字符。例如：\n  s1.find_first_of(\u0026ldquo;abc\u0026rdquo;); //查找s1中第一次出现\u0026quot;abc\u0026quot;中任一字符的位置\n  find_last_of：从后往前查找何处出现另一个字符串中包含的字符。\n  find_first_not_of：从前往后查找何处出现另一个字符串中没有包含的字符。\n  find_last_not_of：从后往前查找何处出现另一个字符串中没有包含的字符。\n  流处理 可以通过\u0026lt;sstream\u0026gt;，将string对象作为一个流。例如：\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;sstream\u0026gt;#include \u0026lt;string\u0026gt;using namespace std; int main(){ string line; while(getline(cin,line)){ stringstream ss(line); while(ss\u0026gt;\u0026gt;x){...} } } set set就是数学中的集合，每个元素只能出现一次，set中的元素已经从小到大排好了。\n常用函数  insert：插入一个元素 erase：删除，可以传入定位器，也可直接传入值 count：统计元素出现的个数，因为只有0/1个，所以一般用来判断元素是否存在 find：查找  对于自己定义的结构体，需要重载\u0026lt;运算符。\n常用算法 在\u0026lt;algorithm\u0026gt;中提供了关于set的两种算法（目前只知道两种）\n  set_union：取两个集合的并集，例如：\n#define ALL(x) x.begin(),x.end() #define INS(x) inserter(x,x.begin()) set_union(ALL(x1),ALL(x2),INS(x)); //将x1和x2的内容取并集后放入x中   set_intersection：取两个集合的交集，例如：\nset_intersection(ALL(x1),ALL(x2),INS(x)); //将x1和x2的内容取交集放入x中   map map是映射，支持[]运算符，还是非常实用的。\nmap的函数和set基本一致，这里就不重复写了。\nstack stack就是数据结构中的栈，数据是“后进先出”。\n基本函数  push：入栈 pop：出栈 top：取栈顶元素  要注意的是，使用pop()出栈并不会返回被删除的元素值，如果想要需要先top()一下\nqueue queue就是数据结构里的队列，数据符合“先进先出”的规则。\n基本函数   push：入队\n  pop：出队\n  front：取队首\n  priority_queue 优先队列，将按照优先级来排序，取队首的front()的函数将换为top()。该容器也定义在头文件\u0026lt;queue\u0026gt;里。\n对于自定义数据类型的队列，需要定义\u0026lt;运算。对于已经定义过的数据类型，我们可以通过定义一个结构体，在其中重载()运算符来看起来像一个函数，例如：\nstruct cmp { bool operator()(const int a, const int b) const { return abs(a) \u0026lt; abs(b); } }; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, cmp\u0026gt; p_queue; 这样就定义了一个绝对值大小优先的队列\n","date":"2021-01-31T20:39:29+08:00","image":"https://example.com/p/%E7%AB%9E%E8%B5%9B%E7%94%A8stl%E6%95%B4%E7%90%86/85526504_huffc36122ca7f2f624d334d6d5c5a83e7_1825704_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/%E7%AB%9E%E8%B5%9B%E7%94%A8stl%E6%95%B4%E7%90%86/","title":"竞赛用STL整理"},{"content":"考前整理的算法，也顺便放到博客上吧ヾ(•ω•`)o\n数据结构代码复习 3.单链表逆置 带头结点\nint Inverse_Link(LinkList *L) { LinkList *cur, *p; if (L-\u0026gt;next \u0026amp;\u0026amp; L-\u0026gt;next-\u0026gt;next) { p = L-\u0026gt;next-\u0026gt;next; L-\u0026gt;next-\u0026gt;next = NULL; while (p) { cur = L-\u0026gt;next; L-\u0026gt;next = p; p = p-\u0026gt;next; L-\u0026gt;next-\u0026gt;next = cur; } } return 0; } 5.双向链表 双链表定义：\ntypedef struct DuLinkList { int data; struct DuLinkList *prior; struct DuLinkList *next; } DuLinkList; 遍历：\nvoid Printlist_DuL(DuLinkList *L) { DuLinkList *s; s = L-\u0026gt;next; if (L-\u0026gt;next != NULL) { printf(\u0026#34;当前的双向链表值为：\u0026#34;); do { printf(\u0026#34;%d \u0026#34;, s-\u0026gt;data); s = s-\u0026gt;next; } while (s != NULL); } printf(\u0026#34;\\n\u0026#34;); } 交换：\nint ListSwap_DuL(DuLinkList *L, int i) { //在带头结点的双向链表中交换第i个，i+1个位置的元素  DuLinkList *p = L, *q; int j = 0; while (p \u0026amp;\u0026amp; j \u0026lt; i - 1) { p = p-\u0026gt;next; j += 1; } if (!p || j \u0026gt; i - 1) return -1; p = p-\u0026gt;next; q = p-\u0026gt;next; p-\u0026gt;prior-\u0026gt;next = q; //1 -\u0026gt;q p 2  q-\u0026gt;prior = p-\u0026gt;prior; //1\u0026lt;--\u0026gt;q p 2  p-\u0026gt;next = q-\u0026gt;next; //1\u0026lt;--\u0026gt;q p -\u0026gt;2  q-\u0026gt;next-\u0026gt;prior = p; //1\u0026lt;--\u0026gt;q p\u0026lt;--\u0026gt;2  q-\u0026gt;next = p; //1\u0026lt;--\u0026gt;q -\u0026gt;p\u0026lt;--\u0026gt;2  p-\u0026gt;prior = q; //1\u0026lt;--\u0026gt;q\u0026lt;--\u0026gt;p\u0026lt;--\u0026gt;2  return 0; } 6.链表回文 bool isPalindrome(struct ListNode *head) { Lstack *s; int e; struct ListNode *p = head; s = (Lstack *)malloc(sizeof(Lstack)); Initlist_Stack(s); while (p) { push(s, p-\u0026gt;val); p = p-\u0026gt;next; } p = head; while (p) { e = pop(s); if (p-\u0026gt;val != e) break; p = p-\u0026gt;next; } if (p) return false; else return true; } 7-1.链队列 定义：\ntypedef struct QNode //队列 { int data; struct QNode *next; } QNode; typedef struct LinkQueue //对列相关的指针 { QNode *front; //对头指针  QNode *rear; //队尾指针 } LinkQueue; 插入：\nint EnQueue(LinkQueue *q, int e) { //[入队]将元素e放入队尾，带头结点  QNode *p; p = (QNode *)malloc(sizeof(QNode)); p-\u0026gt;data = e; p-\u0026gt;next = NULL; q-\u0026gt;rear-\u0026gt;next = p; q-\u0026gt;rear = p; return 0; } 7-2.循环链表 插入和普通单链表没区别，这里就列举部分\ns = (LinkList *)malloc(sizeof(LinkList)); s-\u0026gt;data = e; s-\u0026gt;next = p-\u0026gt;next; p-\u0026gt;next = s; 8.求二叉树各种数的算法 （1）求高度 高度很简单，来个递归就完事了\nint BiTreeHeight(BiTNode *T) { //求二叉树的高度  int treeHeight = 0; if (T != NULL) { int leftHeight = BiTreeHeight(T-\u0026gt;lchild); int rightHeight = BiTreeHeight(T-\u0026gt;rchild); treeHeight = leftHeight \u0026gt;= rightHeight ? leftHeight + 1 : rightHeight + 1; } return treeHeight; } （2）求叶子数 叶子数也一样，递归永远滴神\nvoid BiTreeLeafCount(BiTNode *T, int *count) { //求二叉树叶子结点数  if (!T) return; if (T-\u0026gt;lchild == NULL \u0026amp;\u0026amp; T-\u0026gt;rchild == NULL) *count += 1; BiTreeLeafCount(T-\u0026gt;lchild, count); BiTreeLeafCount(T-\u0026gt;rchild, count); } （3）求结点数 这不就遍历嘛，直接看下面吧=￣ω￣=\n9.二叉树的中序遍历 递归：\nint InOrderTraverse(BiTNode *T) { //中序遍历二叉树T的递归算法  if (T == NULL) return 0; InOrderTraverse(T-\u0026gt;lchild); printf(\u0026#34;%c \u0026#34;, T-\u0026gt;data); InOrderTraverse(T-\u0026gt;rchild); } 非递归（重要）：\nint inorder(BiTNode *T) { //中序遍历二叉树T的非递归算法  BiTNode *s[MAXSIZE + 1]; int top = 0; while (T != NULL || top != 0) { while (T != NULL) { s[++top] = T; T = T-\u0026gt;lchild; } if (top != 0) { T = s[top--]; printf(\u0026#34;%c \u0026#34;, T-\u0026gt;data); T = T-\u0026gt;rchild; } } return 0; } 10.二叉排序树 int Search_BST(BSTree t, int key, BSTree f, BSTree *p) { //在指针t所指的二叉排序树上查找key，成功则p指向该元素数据结点并返回0  //否则p指向查找路径上最后一个结点并返回1，f指向T的双亲，初始值为NULL  if (!t) { *p = f; return 1; } else if (key == t-\u0026gt;data) { *p = t; return 0; } else if (key \u0026lt; t-\u0026gt;data) { return Search_BST(t-\u0026gt;lchild, key, t, p); } else return Search_BST(t-\u0026gt;rchild, key, t, p); } int Insert_BST(BSTree *t, int key) { //二叉排序树的插入，当不存在key时插入并返回0，否则返回1  BSTree p, s; p = NULL; if (Search_BST(*t, key, NULL, \u0026amp;p)) { s = (BSTree)malloc(sizeof(BSTNode)); s-\u0026gt;data = key; s-\u0026gt;lchild = s-\u0026gt;rchild = NULL; if (!p) *t = s; else if (key \u0026lt; p-\u0026gt;data) p-\u0026gt;lchild = s; else p-\u0026gt;rchild = s; return 0; } else return 1; } 14.图的遍历 （1）深度优先 入栈时打印结点信息\n递归：\nvoid DFS(ALGraph *G, int v, int visited[]) { ArcNode *p; int w, i; visited[v] = 1; printf(\u0026#34;%d \u0026#34;, v); p = G-\u0026gt;vertices[v].firstarc; while (p != NULL) { w = p-\u0026gt;adjvex; if (visited[w] == 0) DFS(G, w, visited); p = p-\u0026gt;nextarc; } } 非递归：\nvoid DFS1(ALGraph *G, int v) { ArcNode *p; int w, i; int visited[MAX_VERTEX_NUM]; ArcNode *s[MAX_VERTEX_NUM]; //顺序栈  int top = 0; for (i = 1; i \u0026lt;= G-\u0026gt;vexnum; i++) visited[i] = 0; //访问标志数组初始化  visited[v] = 1; printf(\u0026#34;%2d\u0026#34;, v); p = G-\u0026gt;vertices[v].firstarc; while (p != NULL || top != 0) { while (p != NULL) { w = p-\u0026gt;adjvex; if (visited[w] == 0) { printf(\u0026#34;%2d\u0026#34;, w); visited[w] = 1; s[++top] = p; p = G-\u0026gt;vertices[w].firstarc; } else p = p-\u0026gt;nextarc; } if (top != 0) { p = s[top--]; p = p-\u0026gt;nextarc; } } } （2）广度优先 出队列时打印结点信息\nvoid BFS(ALGraph *G, int v) { ArcNode *p; int w, i; int queue[MAX_VERTEX_NUM], front = 0, rear = 0; // 定义循环队列  int visited[MAX_VERTEX_NUM]; for (i = 1; i \u0026lt;= G-\u0026gt;vexnum; i++) visited[i] = 0; //访问标志数组初始化  printf(\u0026#34;%2d\u0026#34;, v); //输出被访问顶点的编号  visited[v] = 1; //置已访问标记  rear = (rear + 1) % MAX_VERTEX_NUM; queue[rear] = v; //v进队  while (front != rear) // 队列不空时循环  { front = (front + 1) % MAX_VERTEX_NUM; w = queue[front]; //出队并赋给w  p = G-\u0026gt;vertices[w].firstarc; //找w的第一个的邻接点  while (p != NULL) { if (visited[p-\u0026gt;adjvex] == 0) { printf(\u0026#34;%2d\u0026#34;, p-\u0026gt;adjvex); //访问之  visited[p-\u0026gt;adjvex] = 1; rear = (rear + 1) % MAX_VERTEX_NUM; //相邻顶点进队  queue[rear] = p-\u0026gt;adjvex; } p = p-\u0026gt;nextarc; //找下一个邻接顶点  } } } 15.双向冒泡 void BubbleSort1(int R[], int n) { //双向冒泡  int i, j, lastExchange, lastExchange1, i1, temp; i = n; //i 指示无序序列中最后一个记录的位置  i1 = 1; while (i \u0026gt; i1) { lastExchange = 1; //记录正序最后一次交换发生的位置  lastExchange1 = n; //记录逆序最后一次交换发生的位置  for (j = i1; j \u0026lt; i; j++) if (R[j] \u0026gt; R[j + 1]) { temp = R[j]; R[j] = R[j + 1]; R[j + 1] = temp; //逆序时交换  lastExchange = j; } for (j = lastExchange; j \u0026gt; i1; j--) if (R[j] \u0026lt; R[j - 1]) { temp = R[j]; R[j] = R[j - 1]; R[j - 1] = temp; //逆序时交换  lastExchange1 = j; } i = lastExchange; i1 = lastExchange1; } } ","date":"2021-01-10T15:06:20+08:00","image":"https://example.com/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/83667969_hu38d2b1a912e76eab4c1b90daa958e1cd_1812230_120x120_fill_box_smart1_2.png","permalink":"https://example.com/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/","title":"数据结构算法复习"},{"content":"生成随机数 在C语言中，生成随机数可以使用stdlib.h头文件里的rand()来生成，例如：\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;int main(){ int a = rand(); printf(\u0026#34;%d\\n\u0026#34;,a); return 0; } rand() 会随机生成一个位于 0 ~ RAND_MAX 之间的整数。\n但是这样生成的随机数每次开启程序都是一样的，则需要使用srand()来重新播种，一般常与\u0026lt;time.h\u0026gt;里的time()函数一起使用。\nsrand((unsigned)time(NULL)); 连续生成多个随机数 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;time.h\u0026gt;int main() { int a, i; srand((unsigned)time(NULL)); //使用for循环生成10个随机数  for (i = 0; i \u0026lt; 10; i++) { a = rand(); printf(\u0026#34;%d \u0026#34;, a); } return 0; } 生成指定范围的随机数 想要生成指定范围的随机数，只要进行%运算就好了\nint a = rand() % 10; //产生0~9的随机数 int a = rand() % 10 + 1; //产生1~10的随机数 连续生成不重复的随机数 这就是本文的重点了ヾ(•ω•`)o （其实就是为了记下这个算法才水了一篇文章）\nint *GetRandom(int m) { //根据给定的m生成随机不重复的数组a  int i, n, w, t; int *a; n = 2 * m; srand((unsigned int)time(0)); a = (int *)malloc(n * sizeof(int)); for (i = 0; i \u0026lt; n; i++) a[i] = i + 1; for (i = 1; i \u0026lt;= m; i++) { w = rand() % (n - i) + i; t = a[i]; a[i] = a[w]; a[w] = t; } return a; } ","date":"2020-12-22T19:36:53+08:00","image":"https://example.com/p/c%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/84444030_hu7ef2fd02297b262112d9bbc23507151d_2022394_120x120_fill_box_smart1_2.png","permalink":"https://example.com/p/c%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/","title":"C语言生成随机数"},{"content":"基本操作 建立版本库：git init\n查看结果：git status\n查看不同：git diff\n版本回退 查看提交日记：git log\n回退：git reset --hard HEAD^\nHEAD^表示上一个版本，HEAD^^表示前两个版本，HEAD~100表示前100个版本\n恢复：git reflog查看命令历史，确定回到未来的哪个版本\n撤销修改  直接丢弃工作区的修改时，用命令git checkout -- file 已经添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD \u0026lt;file\u0026gt;，第二步按1操作。  上传 git remote add origin 仓库链接 #将远程仓库和本地仓库绑定 git add . git commit -m \u0026quot;提交信息\u0026quot; git push -u origin 自己当前的分支名 #-u将本地库和远程库的分支关联，之后可以不加 下载 git clone 仓库链接 git clone到当前文件夹\ngit clone 仓库链接 . 分支管理 创建与合并分支 查看分支：git branch\n创建分支：git branch \u0026lt;name\u0026gt;\n切换分支：git checkout \u0026lt;name\u0026gt;或者git switch \u0026lt;name\u0026gt;\n创建+切换分支：git checkout -b \u0026lt;name\u0026gt;或者git switch -c \u0026lt;name\u0026gt;\n删除分支：git branch -d \u0026lt;name\u0026gt;\n合并某分支到当前分支：git merge \u0026lt;name\u0026gt;\n 当Git无法自动合并分支时，就必须首先解决冲突，自己手动修改冲突文件再合并即可。 查看分支合并图：git log --graph 使用非快速模式合并，有commit：git merge --no-ff -m \u0026quot;merge with no-ff\u0026quot; dev  Bug分支 需要紧急处理Bug时，可以使用git stash将现在的工作区暂存\n恢复原来的工作区\n 恢复但不删除stash内容：git stash apply 手动删除stash内容：git stash drop 恢复且删除stash内容：git stash pop  可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，如：\ngit stash apply stash@{0} 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick \u0026lt;commit\u0026gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。\n多人协作   查看远程库信息，使用git remote -v\n  从本地推送分支，使用git push origin branch-name\n  如果冲突，先git pull抓取远程的新提交，处理好后再push\n  在本地创建和远程分支对应的分支：git checkout -b branch-name origin/branch-name\n  建立本地分支和远程分支的关联：git branch --set-upstream branch-name origin/branch-name\n  将非直线的提交日记变为直线：git rebase\n  标签管理 创建标签   新建一个标签：git tag \u0026lt;name\u0026gt;,默认为HEAD，也可以指定一个commit id\n  指定标签信息：git tag -a \u0026lt;tagname\u0026gt; -m \u0026quot;blablabla...\u0026quot;\n  查看所有标签：git tag\n  标签管理  推送一个本地标签：git push origin \u0026lt;tagname\u0026gt; 推送全部未推送过的本地标签：git push origin --tags 删除一个本地标签：git tag -d \u0026lt;tagname\u0026gt; 删除一个远程标签：git push origin :refs/tags/\u0026lt;tagname\u0026gt;  ","date":"2020-12-16T13:16:45+08:00","image":"https://example.com/p/git/79008828_hu0acf08fa0a8e929040b98749b2927875_1528743_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/git/","title":"Git的常用命令"},{"content":"主题相关 FrontMatter 字段含义\ntitle: 标题 description: 描述 image: 显示的特色图片 comments: 显示 / 隐藏评论区(T/F) license: 文章协议 输入 false 可以隐藏 hidden: 隐藏文章（不在首页，归档等页面显示，但是可以直接通过链接访问） math: 是否加载 KaTeX 脚本 slug: 固定链接 draft: 是否为草稿 categories: 分类 tags: 标签 lastmod: 上次更新时间 MarkDown相关 # 我是一级标题 ## 我是二级标题 可对应1-6级标题 *斜体文本* **粗体文本** ***粗斜体文本*** 一行中用三个以上的星号*、减号-、底线_来建立一个分隔线 ~~删除线~~ \u0026lt;u\u0026gt;带下划线文本\u0026lt;/u\u0026gt; 创建脚注格式类似这样 [^JiaoZhu]。 [^JiaoZhu]: 脚注的内容 列表：*、+、-、1. \u0026gt; 区块 [链接文本](网址) 图片在前加! | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 ","date":"2020-12-15T18:02:14+08:00","image":"https://example.com/p/blog%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/80228475_hueadf3bffe35dbd99d1cbacd445bc351e_1641954_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/blog%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/","title":"Blog常用的命令"}]