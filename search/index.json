[{"content":"由于运营商默认提供的DNS有很多的污染，许多域名直接0.0.0.0或者127.0.0.1伺候，导致上网体验并不是很好，故想到自建加密DNS来抵御污染。\n一开始使用的是AdGuardHome，然而在我看到了CloudflareSpeedTest这个项目后，就萌生了ip重定向这个需求，为此我又套了一层mosdns（经典为醋包饺子）。既然上了mosdns，就干脆做配上分流吧，于是现在的这套方案就形成了。虽然我的这些需求一个mosdns就可以解决，但AdGuardHome的前端ui、更方便的广告过滤、数据统计这些功能是mosdns所没有的。\n方案设计 首先由AdGuardHome接受请求，判断是否为广告域名:\n是：直接拦截，结束流程 否：继续传入mosdns 判断是否为国内域名：\n是：向本地DNS查询 否：向远端DNS查询 判断是否为CloudFlare的IP：\n是：修改响应为优选的IP 否：不进行操作 系统搭建 搭建mosdns 如何安装和配置mosdns，官方文档已经写的非常详细了，直接看文档就好了。\n配置文件主要参考了pmkol/easymosdns\n这里主要分享一下我的配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 # Powered by luoboQAQ log: file: \u0026#34;./mosdns.log\u0026#34; level: error # 数据源设置 data_providers: - tag: CloudFlareIP file: \u0026#34;./rules/cloudflare.txt\u0026#34; auto_reload: true - tag: chinalist file: \u0026#34;./rules/geosite_cn.txt\u0026#34; auto_reload: true plugins: # 匹配PTR类型请求的插件 - tag: query_is_ptr type: query_matcher args: qtype: [12] # 匹配本地域名的插件 - tag: query_is_cn_domain type: query_matcher args: domain: - \u0026#34;provider:chinalist\u0026#34; # 转发至本地服务器的插件 # [local|alidns] - tag: forward_local type: fast_forward args: upstream: - addr: \u0026#34;udp://100.100.2.138\u0026#34; - tag: forward_alidns type: fast_forward args: upstream: - addr: \u0026#34;https://dns.alidns.com:443/dns-query\u0026#34; dial_addr: \u0026#34;223.5.5.5\u0026#34; # CloudFlare劫持的插件 - tag: response_is_cloudflare_ip type: response_matcher args: ip: - \u0026#34;provider:CloudFlareIP\u0026#34; - tag: hijack_cloudflare_ip type: blackhole args: ipv4: 104.16.111.240 # 转发至远端服务器的插件 - tag: forward_easymosdns type: fast_forward args: upstream: - addr: \u0026#34;https://doh.apad.pro/dns-query\u0026#34; bootstrap: \u0026#34;223.5.5.5\u0026#34; # 主要的运行逻辑插件 - tag: main_sequence type: sequence args: exec: # 分流 - if: \u0026#34;(query_is_cn_domain) || (query_is_ptr)\u0026#34; exec: - forward_alidns else_exec: - forward_easymosdns # CloudFlare劫持到优选IP - if: response_is_cloudflare_ip exec: - hijack_cloudflare_ip - _return servers: - exec: main_sequence timeout: 5 listeners: - addr: 127.0.0.1:5533 protocol: udp 其中，cloudflare.txt来自于上面的CloudflareSpeedTest项目，是包含ipv4和ipv6的CloudflareIP段。\ngeosite_cn.txt是国内域名的集合，来自Loyalsoldier/v2ray-rules-dat，将geosite.dat使用mosdns v2dat unpack-domain 解包得到。\n这里我没有启用mosdns的缓存，因为我在AdGuardHome里启用，就不重复缓存了。如果你是直接使用mosdns，那么就可以启用缓存。\n搭建AdGuardHome 这里我为了方便，就直接使用了docker，其实可以不用的说\n1 2 3 4 5 6 docker run --name adguardhome\\ --restart unless-stopped\\ -v /root/adguardhome/work:/opt/adguardhome/work\\ -v /root/adguardhome/conf:/opt/adguardhome/conf\\ --net=host\\ -d adguard/adguardhome 我比较懒，就直接让容器使用了host模式，这样就不用配置端口了。\n设置方面\n上游DNS服务器填入127.0.0.1:5533，即mosdns的端口。\n启用启用 EDNS 客户端子网，使DNS查询附上用户的ip，使解析的ip地址靠近本地位置。\n开启乐观缓存，设置覆盖最小TTL值为600，覆盖最大TTL值为3600，避免每次都要查询\n开启启用加密（HTTPS、DNS-over-HTTPS、DNS-over-TLS），启用DoH\n根据自己的喜好添加过滤规则\n我推荐启用CHN: anti-AD，这个列表还是很不错的\nNginx反代配置 这里为了避免DoH被滥用，我修改了默认的路径，同时将默认路径返回444（中断连接）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 server { listen 80; listen 443 ssl http2; server_name you.domain; if ($server_port !~ 443){ rewrite ^(/.*)$ https://$host$1 permanent; } ssl_certificate ./cert/xxx.pem; ssl_certificate_key ./cert/xxxx.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #表示使用的加密套件的类型。 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #表示使用的TLS协议的类型。 ssl_prefer_server_ciphers on; location /set/ { proxy_pass http://127.0.0.1:11451/; proxy_redirect / /set/; proxy_cookie_path / /set/; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } location /query { proxy_http_version 1.1; proxy_pass https://127.0.0.1:11450/dns-query; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } location / { return 444; } } 客户端配置 Windows 在Win10版本大于等于19628或者win11中，在 设置——网络和Internet中 就可以设置加密DNS，输入服务器ip地址后选择手动模板就可以输入DoH地址了。\n如果没有，可以用管理员模式运行powershell执行下面的命令\n1 Add-DnsClientDohServerAddress -ServerAddress \u0026#39;123.xx.xx.xx\u0026#39; -DohTemplate \u0026#39;https://your.domain/dns-query\u0026#39; -AllowFallbackToUdp $False -AutoUpgrade $True 随后直接设置就可以了。\nAndroid 安卓目前只支持DoT，如果使用DoH则需要使用第三方软件。\n后记 单独使用AdGuardHome的情况下，开启缓存平均处理时间是5ms；AdGuardHome+mosdns目前是11ms。\n折腾了两层解析，只是为了实现CloudFlare的IP优选，速度果然不出所料的慢了一点（当然也可能是缓存还没完全）。就当是学习了，正常使用留其一即可。_(:з)∠)_\n通过这次折腾，对DNS的认识更加深了一步，也水了一篇博客。\n","date":"2022-11-30T11:05:31+08:00","image":"https://lbqaq.top/p/mydns/100669875.webp","permalink":"https://lbqaq.top/p/mydns/","title":"自建DNS实现分流及广告过滤"},{"content":"前言 说到搞机，那肯定绕不开大名鼎鼎的Magisk。就我来说，root完后做的第一件事，就是安装各种各样的模块，但是，我却从来没有研究过Magisk的内容。同时，现在也有许多心怀不轨的人制作锁机模块骗人刷入。所以，了解Magisk模块的一些基本内容就显得比较重要了。\n认识Magisk模块 根据官方的文档，一个典型的Magisk模块的目录应该如下所示：1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 module.zip │ ├── META-INF │ └── com │ └── google │ └── android │ ├── update-binary \u0026lt;--- 从官方仓库上下载的module_installer.sh │ └── updater-script \u0026lt;--- 只有一行文字为 \u0026#34;#MAGISK\u0026#34; │ ├── module.prop \u0026lt;--- 模块的标识信息 ├── customize.sh \u0026lt;--- (可选)用于自定义模块安装过程 ├── ... ├── ... /* 模块的其余文件 */ │ 可以看出来，META-INF目录是由官方提供，并不需要我们进行修改。\nmodule.prop 这个文件是模块的标识信息，模块的基本信息就存放在这里，文件的格式如下。1\n1 2 3 4 5 6 7 id=\u0026lt;string\u0026gt; name=\u0026lt;string\u0026gt; version=\u0026lt;string\u0026gt; versionCode=\u0026lt;int\u0026gt; author=\u0026lt;string\u0026gt; description=\u0026lt;string\u0026gt; updateJson=\u0026lt;url\u0026gt; (optional) 各键值的作用说明如下：\n名称 说明 id 模块的唯一标识符，需符合该正则表达式^[a-zA-Z][a-zA-Z0-9._-]+$ name 模块名称 version 模块版本号 versionCode 模块版本标识，必须为整数，用于更新 author 作者信息 description 模块描述 updateJson 更新信息链接，现在Magisk移除了内部的更新功能，这个属性应该是无用了 system文件夹 Magisk的一个主要作用就是对系统文件进行注入或替换，只要将文件按顺序放入此目录中即可。例如我想修改hosts文件，只需要将修改好的hosts文件放入system/etc这个目录下，Magisk就会自动将其替换了。\n如果要替换/vendor、/product或/system_ext中的文件，只需将它们分别放在system/vendor、system/product和system/system_ext下。Magisk就会自动替换完成。\ncustomize.sh 这是自定义模块安装过程，如果只是简单的替换文件就不需要用到它。但是，很多时候我们并不是仅需替换文件，还需要执行一些脚本，这里就需要使用到它了。\n根据官方文档，这里支持以下的环境变量：\n变量名 作用 MAGISK_VER (string) 当前安装的Magisk的版本字符串（例如v20.0） MAGISK_VER_CODE (int) 当前安装的Magisk的版本代码（例如20000） BOOTMODE (bool) 如果模块正在Magisk应用程序中安装，则为true MODPATH (path) 安装模块文件的路径 TMPDIR (path) 可以临时存储文件的位置 ZIPFILE (path) 您的模块的安装zip ARCH (string) 设备的CPU架构，值可以是arm、arm 64、x86或x64 IS64BIT (bool) 如果$ARCH为arm 64或x64，则为true API (int) 设备的API级别（Android版本）（例如，Android 5.0为21） 以及以下的命令：\nui_print \u0026lt;msg\u0026gt;：在页面上显示信息 abort \u0026lt;msg\u0026gt;：将错误消息打印到控制台并终止安装 set_perm和set_perm_recursive：修改文件权限 实践 修改系统Hosts 我一开始想研究Magisk的契机，就是想要修改我手机的Hosts文件。一开始按百度的教程做，但没有效果，后来就尝试了一下Magisk模块，直接就成功了。\n有了前面知识的铺垫，想要实现这个功能就非常简单了，下面列出我们程序的目录树。\n1 2 3 4 5 6 7 8 9 10 11 ChangeHosts.zip ├── META-INF │ └── com │ └── google │ └── android │ └── update-binary │ └── updater-script ├── module.prop ├── system └── etc └── hosts 实际我们需要修改的部分只有module.prop和hosts，hosts是我们需要修改的文件，所以我们就只要关注module.prop。\n1 2 3 4 5 6 id=ChangeHosts name=ChangeHosts version=v1.0.0 versionCode=100 author=luoboQAQ description=修改hosts文件来屏蔽广告 如此看来，如果只要替换文件，基本没有任何难度。\n使用dnscrypt-proxy实现DoH 这部分我正在研究，等研究明白了就补上🕊️。\nMagisk官方开发指导\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-10-07T11:30:17+08:00","image":"https://lbqaq.top/p/%E7%AE%80%E6%98%93magisk%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%B6%E4%BD%9C/95936465.webp","permalink":"https://lbqaq.top/p/%E7%AE%80%E6%98%93magisk%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%B6%E4%BD%9C/","title":"简易Magisk模块的制作"},{"content":"之前在《如何优雅的看番》这篇文章中我提到了补帧的3款软件，在Windows系统上我使用的是dmitriRender这款软件，而其并没有提供Linux版本的程序。与之相反的是，SVP不但提供了Linux版本，而且还是免费的。\n由于官方文档是英文且有些地方没有表述清楚，这里我就将我安装和配置的方式记录下来供大家参考。\n安装 对于Arch用户非常简单，直接yay -S svp-bin即可完成安装。\n对于其他发行版，可以选择在官网上下载并安装。\n安装播放器，这里我推荐安装VLC，因为其安装简便，并且后面配置SVP也很容易。\n安装直接输入sudo pacman -S vlc即可\n如果需要GPU加速，还需要安装相应的插件sudo pacman -S ocl-icd。我之前就是没有安装，导致一直无法读取到我的显卡。\n安装好后就可以在SVP菜单——应用程序设置——GPU加速里看到你的显卡了\n配置 修改VLC插件目录权限，以便SVP写入插件。\n1 sudo chmod 777 /usr/lib/vlc/plugins/video_filter 在SVP的菜单里选择“工具”——“VLC的SVP插件”，将其选中\n检查/usr/lib/vlc/plugins/video_filter目录下的libsvpcontrol_plugin.so和libvapoursynth_plugin.so是否有可执行权限，我之前就是因为没有给执行权限，导致VLC一直不会调用SVP\n1 2 chmod +x /usr/lib/vlc/plugins/video_filter/libsvpcontrol_plugin.so chmod +x /usr/lib/vlc/plugins/video_filter/libvapoursynth_plugin.so 官网表示需要开启“反交错”才会启用，但实测好像不开启也可以运行。\n如果VLC偏好设置——显示设置——全部——控制界面有SVP control interface\n以及滤镜里有Vapoursynth filter即表明安装成功了。\n小结 官网上的安装文档写了很长，但实际上对于VLC使用SVP并不复杂，复杂的是MPV使用SVP。本来打算配几张图的，但实际写下来也没有发现需要图片辅助说明的，那就算了，相信聪明的你一定能看懂 _(:з)∠)_\n","date":"2022-08-23T09:58:00+08:00","image":"https://lbqaq.top/p/svp4inlinux/100213137.webp","permalink":"https://lbqaq.top/p/svp4inlinux/","title":"在Linux下安装SVP4"},{"content":"随着答辩的结束，智慧物流这个项目就算是彻底结束了。不出意外的话，这应该是我大学生涯的参加的最后一个比赛了。看了看git的记录，提交的代码超过了1k行，同时也花了不少的时间在上面。做了这么多东西，不留下点什么总觉得不好，想来想去，还是把比赛做的东西做个小结吧，也算是纪念我这不算丰富的比赛时光吧（雾）\n这里非常感谢我们队长，比赛里许多关键的问题是他解决的，他的动手能力和善于提出创新性想法的能力，都是值得我去学习的。也感谢另一位队友，在赛前紧张的准备时间里独自一人分担了制作PPT的工作，并且能做出如此精美的PPT。（大佬带带我 _(:з)∠)_ ）\n感想也就写这么多吧，下面主要介绍我们比赛时所做的一些工作和创新。\n程序的大体思路和流程 根据赛题要求，程序要实现下面几个功能：\n导航至邮件分拣台 运用视觉算法识别邮件 机械臂定位抓取邮件 机器人运送邮件投入正确的邮箱 所以程序大致的步骤就是：建图-\u0026gt;导航至分拣台-\u0026gt;识别-\u0026gt;抓取-\u0026gt;导航至投递点-\u0026gt;投递-\u0026gt;导航至分拣台-\u0026gt;\u0026hellip;\u0026hellip;\n这里我就按上面的要求一部分一部分的讲了。\n建图 建图算法是Gmapping算法，这是一种基于2D激光雷达通过使用RBPF粒子滤波方法所完成的二维栅格地图构建SLAM算法，它也是移动机器人中适用最多的算法。它对激光雷达频率要求相对较低，稳定性较高，且能够结合里程计、陀螺仪等进行定位与地图构建，构建小场景地图时速度快、计算量小，缺点就是非常依赖里程计，所以无法适应不平坦的地面，无法使用回环检测，在大场景、粒子多的情况下，特别消耗资源。\n当然我们并没有去仔细研究这个算法，建图的话按照官方提供的教程来一步步做就好了。不得不吐槽的是我们的小车一开始后轮是偏高的，导致雷达会打到地面，预选赛建图的时候一直建不好，最终只能靠侧边的雷达才把图建好，当时以为车就是这样的，直到正赛时才知道是车的问题。所以这种硬件问题一定要及时和厂商联系，不然全是泪啊😭。\n导航 导航这里不是我们写，而是使用了官方提供的导航包。根据培训文档，这里主要采用了AMCL自适应蒙特卡罗算法，它是机器人在二维移动过程中的一种概率定位系统，通过它实现了自适应（或 kld 采样）的蒙特卡罗定位方法。由于采用粒子滤波器来跟踪已经知道的地图中机器人位姿，故对于大范围的局部定位问题工作良好。路径规划则是最短路径规划算法，例如采用Floyd算法、Dijkstra算法、Bellman-Ford算法等。\n导航这里其实是有大坑的，我们最终比赛时就栽在这里了。我们发现小车运行时，激光雷达经常会发生错位，导致导航发生偏移。这种情况基本是出现在小车转向时，我们怀疑是轮子打滑，也调紧了后轮的弹簧，但也没有用。我们当时认为这就是小车本身的局限性，同时在小车运行时也会自动调整至正确位置，我们就没有特别重视这个问题。结果在正式比赛时导航就出现偏移，导致好几个包裹都错位抓取了，虽然最终都全部抓取上了，但浪费了很多时间，非常的可惜。所以有时间的话，一定要看看官方提供的导航定位算法，或者联系厂家看看雷达有无问题，不然程序没问题，却因为硬件问题而出错还是很难受的。( ‘-ωก̀ )\n图像识别 图像识别这里我们是调用是百度的PaddleOCR模块，由于ROS里的Python是2版本的，我们采用的也是PaddleOCR里的develop分支而非最新版本。\n我们一开始是打算自己训练PaddleOCR模型的，然而我尝试了一晚上，不是很清楚模型训练的方法，好不容易运行了一个公开的训练集，发现训练时间要一天多，同时还需要自己做训练集。考虑到时间的问题，最终还是选择采用官方的模型。当然，最主要的原因还是分布式图像识别提升了性能，这部分我在下面会提到，这里就先按下不表。\n机械臂抓取及投递 根据机械臂的官方文档，这里涉及的坐标系主要是两种，一种是关节坐标系，一直是笛卡尔坐标系。关节坐标系比较难以理解，我们还是采用比较直观的笛卡尔坐标系。\n同样，机械臂的抓取也有3种不同模式：MOVJ、MOVL、JUMP。MOVJ模式相较于MOVL模式，速度快；MOVJ模式相较于JUMP模式，稳定性高，不易越界。1\n综上，我们的机械臂控制都采用的是笛卡尔坐标系里的MOVEJ模式，这样能保证机械臂抓取时不会出现超出抓取范围的异常。\n控制机械臂基本就只要用到下面这几个话题，还是比较容易的：\nDobotServer/SetPTPCmd：移动机械臂到指定坐标 DobotServer/SetEndEffectorSuctionCup：机械臂气泵控制 DobotServer/ClearAllAlarmsState：清除机械臂警报 投递就没什么好说的了，根据文字识别的结果进行投递，只要能抓取到，基本上不会出现投递错位的情况。这里会出现的问题主要还是导航不准，容易偏或者撞。解决办法只能是不停的测试找准坐标以及将导航目的位置远离投递点。\n一些创新点 键盘操控程序 在我们的程序中，主要是通过开启两个线程来实现程序的暂停和恢复，如果使用input函数进行键盘输入的接收，则会阻塞线程，同时在输入完成后还需要按下回车，不是很合适。官方是提供了一个键盘控制程序的样例，然而这个程序有个我认为很大的BUG，会导致程序的输出偏移。\n作为一个对代码美观有洁癖的人，这怎么能忍，于是我开始了百度，下面是我找到的可以在Windows和Linux两种环境下实现类似C语言getchar()函数的代码。2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def getChar(): # figure out which function to use once, and store it in _func if\u0026#34;_func\u0026#34; not in getChar.__dict__: try: # for Windows-based systems import msvcrt # If successful, we are on Windows getChar._func=msvcrt.getch except ImportError: # for POSIX-based systems (with termios \u0026amp; tty support) import tty, sys, termios # raises ImportError if unsupported def _ttyRead(): fd = sys.stdin.fileno() oldSettings = termios.tcgetattr(fd) try: tty.setcbreak(fd) answer = sys.stdin.read(1) finally: termios.tcsetattr(fd, termios.TCSADRAIN, oldSettings) return answer getChar._func=_ttyRead return getChar._func() answer = getChar() 这里和官方提供的程序主要不同就在是tty.setcbreak(fd)，但我不知道原理，不过既然能用，就算了😇。\n上面的代码还包括在Windows环境下的情况，我们不需要如此复杂，稍作修改将其整合进我们的程序，就构成了一个多线程程序的模板。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #!/usr/bin/env python # coding=utf-8 import rospy import threading import sys import termios import tty def main(): \u0026#39;\u0026#39;\u0026#39;程序主要逻辑入口\u0026#39;\u0026#39;\u0026#39; pass def getKey(): \u0026#39;\u0026#39;\u0026#39;获取输入的字符\u0026#39;\u0026#39;\u0026#39; fd = sys.stdin.fileno() oldSettings = termios.tcgetattr(fd) try: tty.setcbreak(fd) key = sys.stdin.read(1) finally: termios.tcsetattr(fd, termios.TCSADRAIN, oldSettings) return key def initKeyListener(): \u0026#39;\u0026#39;\u0026#39;输入监听程序\u0026#39;\u0026#39;\u0026#39; while(1): key = getKey() if key == \u0026#39;k\u0026#39;: rospy.loginfo(\u0026#34;退出程序\u0026#34;) os._exit(0) elif key == \u0026#39;a\u0026#39;: rospy.loginfo(\u0026#34;恢复导航\u0026#34;) elif key == \u0026#39;s\u0026#39;: rospy.loginfo(\u0026#39;取消导航\u0026#39;) elif key == \u0026#39;q\u0026#39;: rospy.loginfo(\u0026#39;开始执行程序\u0026#39;) if __name__ == \u0026#34;__main__\u0026#34;: # 给本程序初始化一个节点名称 rospy.init_node(\u0026#39;match_topic\u0026#39;) # 开一个线程处理键盘监听 key_thread = threading.Thread(target=initKeyListener) key_thread.start() # 开一个线程处理任务 main_thread = threading.Thread(target=main) main_thread.start() 摄像头分辨率提升及去畸变 由于ROS默认从摄像头中获取的图像是640*480，且去畸变也是根据这个分辨率进行设置的，这会导致文字识别很容易识别不出文字。我们将小车上的摄像头接入电脑，发现是720P的，既然你能清晰，那为什么不用呢？于是，我们修改了相关的lanuch文件，将摄像头的分辨率提升到了720P，并使用我们自己打印的标定板进行标定。\n下面介绍一下修改的方法\n在moveit_ws/src/moveit/probot_vision/launch目录下，我们可以看到usb_cam_in_hand.launch文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;launch\u0026gt; \u0026lt;node name=\u0026#34;usb_cam\u0026#34; pkg=\u0026#34;usb_cam\u0026#34; type=\u0026#34;usb_cam_node\u0026#34; output=\u0026#34;screen\u0026#34; \u0026gt; \u0026lt;param name=\u0026#34;video_device\u0026#34; value=\u0026#34;/dev/video0\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;image_width\u0026#34; value=\u0026#34;1280\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;image_height\u0026#34; value=\u0026#34;720\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;pixel_format\u0026#34; value=\u0026#34;yuyv\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;camera_frame_id\u0026#34; value=\u0026#34;cameral_base\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;io_method\u0026#34; value=\u0026#34;mmap\u0026#34;/\u0026gt; \u0026lt;param name=\u0026#34;camera_info_url\u0026#34; type=\u0026#34;string\u0026#34; value=\u0026#34;file://$(find probot_vision)/ost-720p.yaml\u0026#34; /\u0026gt; \u0026lt;!--rosparam file=\u0026#34;$(find probot_vision)/ost_4_new.yaml\u0026#34; command=\u0026#34;load\u0026#34; /--\u0026gt; \u0026lt;/node\u0026gt; \u0026lt;/launch\u0026gt; 对其的image_width和image_height进行修改，改为1280和720即可实现摄像头画质提升至720P。\n对于手动标定，我们需要准备标定板，可以自己打印也可以上淘宝购买，就是像下面这样的黑白方格。\n然后在小车上启动标定程序（为什么不在自己电脑上启动呢，因为小车上已经帮你做好硬件端口绑定了，在自己电脑上还要再来一次）\n1 2 3 4 # 启动摄像头 roslaunch usb_cam usb_cam-test.launch # 启动标定程序 rosrun camera_calibration cameracalibrator.py --size 8x6 --square 0.024 image:=/usb_cam/image_raw camera:=/usb_cam 这里要注意修改size参数，改成你标定板的黑白格中间交点的个数。 square参数这里则是你标定板上方格的边长，单位是米。\n启动完成以后就可以看到标定界面了，通过调整标定板的上下左右以及角度，让右边的进度条全变绿就算标定完成了。点击计算按钮得到数据，将保存的yml文件路径替换上面的camera_info_url。\n仅仅是这样还不算是完成，我们还需要修改去畸变程序里的参数，将moveit_ws/src/moveit/probot_vision/src/image_correct.cpp里的相关参数按照yml文件的参数进行修改。（这里有疑似是自动读取的代码，但被注释了，我们也没测试能不能用）修改好后就可以执行编译了，我们在moveit_ws目录下执行catkin_make --pkg probot_vision，等待编译完成后这项工作就算完成了。\n后退距离判断 由于小车的后面是没有雷达的，为了避免碰撞，我们编写了基于摄像头的后退距离判断。当小车到达分拣台前时，调用摄像头进行拍照，对其进行蓝色区域的识别，得到分拣台在图像中的像素位置，再利用公式进行转化，得到小车当前距离分拣台的距离，最后使用check话题控制小车后退至距离分拣台5cm左右的位置，既避免了碰撞，又最大化了抓取范围。\n由消息驱动程序逻辑 在一开始，我们的程序是在函数里调用小车导航，并阻塞直到导航成功再继续执行。这样的程序有个问题，就是当小车出现错误时，无法立即停下小车并保存当前程序执行的进度。于是，我们便将程序修改为基于ROS消息来驱动。这样的好处是程序只有收到成功或者失败的消息后才会执行对应的逻辑，便于失败后状态的恢复。\n想要实现相关的功能，首先是导航不能采用原来基于动作的模式了，而是改成基于消息的模式。我们在程序运行的一开始注册相关的话题发布者。\n1 2 3 4 5 6 7 8 9 10 11 12 13 def initPublisher(): # 微调发布器 global checkPub # 暂停导航发布器 global pauseNav # 目标点发布器 global goalPub goalPub = rospy.Publisher( \u0026#39;move_base/goal\u0026#39;, MoveBaseActionGoal, queue_size=1) # 目标点里面的goal_id的id与上一次的id不能相同 checkPub = rospy.Publisher(\u0026#39;check\u0026#39;, String, queue_size=1) pauseNav = rospy.Publisher( \u0026#39;move_base/cancel\u0026#39;, GoalID, queue_size=1) 同时，我们也需要注册相关话题的监听者以及对应的回调函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def initListener(): # 订阅导航结果话题数据 rospy.Subscriber(\u0026#39;move_base/result\u0026#39;, MoveBaseActionResult, navCallback) # 订阅（微调）走固定距离结果话题数据 rospy.Subscriber(\u0026#39;check_server/result\u0026#39;, check_msgActionResult, checkCallback) rospy.loginfo(\u0026#34;初始化订阅话题成功\u0026#34;) def checkCallback(data): \u0026#39;\u0026#39;\u0026#39;位置微移回调\u0026#39;\u0026#39;\u0026#39; if data.result.issuccess: rospy.loginfo(\u0026#34;位置微调完成\u0026#34;) pass def navCallback(data): \u0026#39;\u0026#39;\u0026#39;导航消息回调\u0026#39;\u0026#39;\u0026#39; PROVINCES = {\u0026#34;四川\u0026#34;, \u0026#34;安徽\u0026#34;, \u0026#34;湖南\u0026#34;, \u0026#34;广东\u0026#34;, \u0026#34;浙江\u0026#34;, \u0026#34;江苏\u0026#34;, \u0026#34;福建\u0026#34;, \u0026#34;河南\u0026#34;} if data.status.status == 3: rospy.loginfo(\u0026#34;导航到达指定地点\u0026#34;) goal_name = data.status.goal_id.id.split(\u0026#39;_\u0026#39;)[0] if goal_name[:9] == \u0026#34;分拣台\u0026#34;: # 到达分拣台前 pass elif goal_name[:6] in PROVINCES: # 到达投递点 pass else: rospy.logwarn(\u0026#34;未知的节点:{}\u0026#34;.format(data.status.goal_id.id)) elif data.status.status == 4: rospy.logwarn(\u0026#34;导航失败,当前id为:{}\u0026#34;.format(data.status.goal_id.id)) else: rospy.logwarn(\u0026#34;导航被取消:{}\u0026#34;.format(data.status.status)) 在导航消息回调中，我们使用goal_id.id来进行目标地点的传递，其构造模式为targetName +'_' + str(time.time())[-9:-3]。这样既有目标地点信息，也避免了id重复。这里一个汉字占3位，所以看到上面的[:6]的写法也就代表前2个字。\n分布式部署图像识别 对于图像识别，我们一开始是放在小车上进行的，结果发现在小车上识别速度并不是很快，平均每张图片需要5~6秒的时间才能完成。\n检查小车的CPU发现，这性能还是不要指望其来跑图像识别算法了，还是采用在自己的电脑上跑图像识别，将结果返回给小车吧。\n想要实现这样的功能，就需要在电脑里装好ROS环境，我们是直接使用虚拟机，里面已经配置好相关的环境了。\n在~/.bashrc里增加export ROS_MASTER_URI=http://192.168.31.200:11311，让虚拟机使用小车作为服务端。之后就是编写程序注册服务，供主程序调用了，为了方便调用，我们自己编写了相应的数据结构。\n我们注册了Province.msg，存放识别到的快递盒上所需的数据。name代表省份名称，x和y分别是相对偏移量。\n1 2 3 string name float32 x float32 y 然后注册了ProvinceList.srv，作为我们服务的消息。\n1 2 --- Province[] provinces 由于使用了自定义消息类型，要注意修改CMakeLists.txt，将相应的文件添加进去，并注意引入message_generation，否则不会生成供Python调用的消息类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 cmake_minimum_required(VERSION 3.0.2) project(imgocr) ## Compile as C++11, supported in ROS Kinetic and newer # add_compile_options(-std=c++11) ## Find catkin macros and libraries ## if COMPONENTS list like find_package(catkin REQUIRED COMPONENTS xyz) ## is used, also find other catkin packages find_package(catkin REQUIRED COMPONENTS rospy std_msgs sensor_msgs message_generation ) ## System dependencies are found with CMake\u0026#39;s conventions # find_package(Boost REQUIRED COMPONENTS system) ## Uncomment this if the package has a setup.py. This macro ensures ## modules and global scripts declared therein get installed ## See http://ros.org/doc/api/catkin/html/user_guide/setup_dot_py.html # catkin_python_setup() ## Generate messages in the \u0026#39;msg\u0026#39; folder add_message_files( FILES Province.msg ) ## Generate services in the \u0026#39;srv\u0026#39; folder add_service_files( FILES ProvinceList.srv ) ## Generate added messages and services with any dependencies listed here generate_messages( DEPENDENCIES std_msgs sensor_msgs ) catkin_package( CATKIN_DEPENDS rospy std_msgs message_runtime ) include_directories( # include ${catkin_INCLUDE_DIRS} ) 同样，在package.xml里也要添加message_generation等依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;package format=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;name\u0026gt;imgocr\u0026lt;/name\u0026gt; \u0026lt;version\u0026gt;0.0.0\u0026lt;/version\u0026gt; \u0026lt;description\u0026gt;The imgocr package\u0026lt;/description\u0026gt; \u0026lt;maintainer email=\u0026#34;eaibot@todo.todo\u0026#34;\u0026gt;eaibot\u0026lt;/maintainer\u0026gt; \u0026lt;license\u0026gt;TODO\u0026lt;/license\u0026gt; \u0026lt;buildtool_depend\u0026gt;catkin\u0026lt;/buildtool_depend\u0026gt; \u0026lt;build_depend\u0026gt;rospy\u0026lt;/build_depend\u0026gt; \u0026lt;build_depend\u0026gt;std_msgs\u0026lt;/build_depend\u0026gt; \u0026lt;build_depend\u0026gt;message_generation\u0026lt;/build_depend\u0026gt; \u0026lt;build_export_depend\u0026gt;rospy\u0026lt;/build_export_depend\u0026gt; \u0026lt;build_export_depend\u0026gt;std_msgs\u0026lt;/build_export_depend\u0026gt; \u0026lt;exec_depend\u0026gt;rospy\u0026lt;/exec_depend\u0026gt; \u0026lt;exec_depend\u0026gt;std_msgs\u0026lt;/exec_depend\u0026gt; \u0026lt;exec_depend\u0026gt;message_runtime\u0026lt;/exec_depend\u0026gt; \u0026lt;export\u0026gt; \u0026lt;/export\u0026gt; \u0026lt;/package\u0026gt; 这样，就可以完成一个文字识别节点了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #!/usr/bin/env python # encoding: utf-8 from imp import reload import sys import rospy import cv2 from imgocr.srv import ProvinceList, ProvinceListResponse from imgocr.msg import Province from sensor_msgs.msg import CompressedImage from cv_bridge import CvBridge, CvBridgeError import time # 支持中文 reload(sys) sys.setdefaultencoding(\u0026#34;utf8\u0026#34;) def getImage(): \u0026#39;\u0026#39;\u0026#39;获取摄像头的图片\u0026#39;\u0026#39;\u0026#39; data = rospy.wait_for_message( \u0026#39;/usb_cam/image_correct/compressed\u0026#39;, CompressedImage, timeout=15.0) try: cv_image = CvBridge().compressed_imgmsg_to_cv2(data, \u0026#34;bgr8\u0026#34;) except CvBridgeError as e: rospy.logerr(e) cv_image = cv2.rotate(cv_image, cv2.ROTATE_180) cv_image = cv2.flip(cv_image, 1) return cv_image def doReq(req): rospy.loginfo(\u0026#34;开始执行文字识别\u0026#34;) start_time = time.time() img = getImage() pass rospy.loginfo(\u0026#34;识别用时：{}\u0026#34;.format(time.time()-start_time)) resp = ProvinceListResponse() for pro in ans: a = Province() a.name = pro[\u0026#34;province\u0026#34;] a.x = pro[\u0026#34;x\u0026#34;] a.y = pro[\u0026#34;y\u0026#34;] resp.provinces.append(a) return resp def main(): rospy.init_node(\u0026#34;imgocr\u0026#34;) server = rospy.Service(\u0026#34;imgocr/getProvince\u0026#34;, ProvinceList, doReq) rospy.loginfo(\u0026#34;节点初始化完成\u0026#34;) rospy.spin() if __name__ == \u0026#34;__main__\u0026#34;: main() 这里我们一开始获取摄像头的图片是采用/usb_cam/image_correct这个话题，但这个话题得到的图片是未压缩的，使用rostopic bw /usb_cam/image_correct可以看出大小差不多是好几M，这就会导致获取图像的时长远超文字识别时长，甚至是无法获取到图片。我们根据探索，发现/usb_cam/image_correct/compressed话题提供的是压缩后的图片，使用后获取图像的时长大大减小。\n使用分布式图像识别后，识别时长基本控制在2S内。\n由于我们是使用虚拟机，无法调用真机的显卡，如果有机会的话，可以尝试在真机上装相应的环境，使用GPU来进行图像识别，速度应该会更进一步。\n机械臂异常自动检测和清除 在上面一小节中，我们获取到省份的坐标就可以送至机械臂进行抓取了。但是，机械臂的抓取范围是有限的，一旦超出抓取范围机械臂就会停止执行直至执行清除警报。一种思路是我们首先是在一个固定的定去识别邮件，首先记录这个点的高度，然后我们需要降到桌面去吸取邮件，这是第二个高度，我们只需要测定这两个高度Z的前提下，Y的移动范围就可以了。1\n这种思路确实可行，但如果后期更换了机械臂高度，又要手动测量，十分麻烦。于是，我想了另一个思路，通过查询API文档，我找到了警报检测的API，那就好说了。在执行可能越界的指令后接上异常检测，如果异常就自动清除，这样就能自动化的判断了。\n话不多说，直接上代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #!/usr/bin/env python # coding=utf-8 import rospy from dobot.srv import GetAlarmsState, ClearAllAlarmsState def getAlarmsState(): \u0026#39;\u0026#39;\u0026#39; 查询机械臂报警状态，并自动进行清除 return 是否存在报警 \u0026#39;\u0026#39;\u0026#39; rospy.wait_for_service(\u0026#39;DobotServer/GetAlarmsState\u0026#39;) rospy.wait_for_service(\u0026#39;DobotServer/ClearAllAlarmsState\u0026#39;) try: client = rospy.ServiceProxy( \u0026#39;DobotServer/GetAlarmsState\u0026#39;, GetAlarmsState) client2 = rospy.ServiceProxy( \u0026#39;DobotServer/ClearAllAlarmsState\u0026#39;, ClearAllAlarmsState) a = client() isError = False if a.alarmsState != \u0026#34;\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\u0026#34;: rospy.loginfo(\u0026#34;检测到警报，自动进行清除\u0026#34;) client2() isError = True return isError except rospy.ServiceException as e: rospy.logerr(\u0026#34;查询机械臂报警状态失败: %s\u0026#34; % e) ROS日志输出级别控制 在上面我提到过，我对代码美观有洁癖，那程序输出也自然不能放过。这个项目里所有的输出我都使用rospy.log来输出，这就带来一个问题，有些输出我将其设为DEBUG级别，而ROS默认的日志级别为INFO，导致这些信息根本看不到。每次想看时手动将代码换为INFO再换回去，虽然可行，但不优雅。于是我研究了一下ROS的日志方面的文档，发现是有方法来实现日志输出级别的控制的。\n在终端运行rqt_logger_level，之后选择你的程序节点中的rosout，在后面修改就可以修改ROS日志输出的级别了。\n时间有限，我就找到了这一个可行的方法，其余方法我测试后并没生效，如果有更好的方法欢迎在评论区留言。\n一些小工具 在写程序时，为了避免重复工作，还是做了一些小工具，本着“不要重复造轮子”的精神，在此一并开源了，希望能帮助到有需要的同学。\n随机快递箱顺序生成 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #!/usr/bin/env python # coding=utf-8 import random provinces = [] for i in range(3): provinces.append(\u0026#39;四川\u0026#39;) for i in range(2): provinces.append(\u0026#39;安徽\u0026#39;) for i in range(2): provinces.append(\u0026#39;湖南\u0026#39;) for i in range(3): provinces.append(\u0026#39;广东\u0026#39;) for i in range(3): provinces.append(\u0026#39;浙江\u0026#39;) for i in range(2): provinces.append(\u0026#39;江苏\u0026#39;) for i in range(3): provinces.append(\u0026#39;福建\u0026#39;) for i in range(2): provinces.append(\u0026#39;河南\u0026#39;) random.shuffle(provinces) for pro in provinces: print(pro) EAI资源点坐标格式转yaml格式 将官方QTEAIBotDemoPub(VER2)这个程序创建的导航目标点转成yaml格式，方便人修改及程序调用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/usr/bin/env python # coding=utf-8 loacate = input(\u0026#34;file loacate:\u0026#34;) file = open(loacate, \u0026#34;r\u0026#34;) file_data = file.readlines() for row in file_data: tmp_list = row.split(\u0026#39;,\u0026#39;) print(tmp_list[0]+\u0026#34;:\u0026#34;) positions = tmp_list[2].split(\u0026#39;#\u0026#39;) print(\u0026#34; x: \u0026#34;+positions[0]) print(\u0026#34; y: \u0026#34;+positions[1]) orientations = tmp_list[3].split(\u0026#39;#\u0026#39;) print(\u0026#34; z: \u0026#34;+orientations[2]) print(\u0026#34; w: \u0026#34;+orientations[3]) 小结 这个项目到此也就完全结束了，回头看来，这个项目也是涉及了许多知识，诸如图像识别、自主定位等等，不过时间有限，基本都没怎么了解其中原理，只是调用了相关的接口，如果以后有空，可以继续研究研究😇。\n第五天：了解越疆dobot机械臂，使用python，编写通过ros服务控制机械臂运动程序_瓜洲大大的博客-CSDN博客_dobot机械臂\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n关于输入：Python从用户读取单个字符 | 码农家园\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-08-21T21:20:00+08:00","image":"https://lbqaq.top/p/roslogistic/97096454.webp","permalink":"https://lbqaq.top/p/roslogistic/","title":"我的智慧物流之旅"},{"content":"前言 阿里云最近发短信给我，提示我之前免费申请的SSL证书要到期了。借此机会，正好将acme.sh配置到服务器上，一劳永逸的解决证书问题。相较于在阿里云上申请证书，使用acme.sh的优势在于可以申请泛域名证书及可以自动续期。\n下面我就记录一下我使用的步骤吧。我这里采用的是使用阿里云的API自动进行DNS方式的申请，不同的服务商命令有稍许不同，可以参考官方文档。\n步骤 在阿里云控制台申请api https://ram.console.aliyun.com/users\n在阿里云的角色控制里赋予刚刚申请的用户控制DNS的权限AliyunDNSFullAccess https://ram.console.aliyun.com/permissions\n安装acme.sh\n1 curl https://get.acme.sh | sh -s email=my@example.com 配置API环境\n1 2 export Ali_Key=\u0026#34;xxxx\u0026#34; export Ali_Secret=\u0026#34;xxxxx\u0026#34; 这里是配置API环境，填入刚刚申请的密钥。这步只需要做一次，acme.sh会将其保存下来。\n生成证书，这里填入刚刚申请API得到的密钥\n1 acme.sh --issue --dns dns_ali -d lbqaq.top -d \u0026#34;*.lbqaq.top\u0026#34; 通过上面命令，可以申请到包含lbqaq.top和*.lbqaq.top这两个DNS记录的证书。这里如果有*，是需要加双引号的，我之前没加就报错了。\n复制证书到nginx目录\n1 2 3 4 acme.sh --install-cert -d lbqaq.top \\ --key-file /usr/local/nginx/conf/cert/lbqaq.top.key \\ --fullchain-file /usr/local/nginx/conf/cert/lbqaq.top.pem \\ --reloadcmd \u0026#34;nginx -s reload\u0026#34; 这里key-file对应的是Nginx配置里的ssl_certificate_key，fullchain-file对应的是ssl_certificate\n接下来修改Nginx配置文件即可\n附上我的模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #如果不是https就跳转至https if ($server_port !~ 443){ rewrite ^(/.*)$ https://$host$1 permanent; } ssl_certificate ./cert/lbqaq.top.pem; ssl_certificate_key ./cert/lbqaq.top.key; ssl_session_timeout 5m; #表示使用的加密套件的类型。 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #表示使用的TLS协议的类型。 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; add_header Strict-Transport-Security \u0026#34;max-age=31536000\u0026#34;; 常用命令 在附上一些我用到的一些acme.sh相关的命令。才不是水字数呢\nacme.sh --list查看已申请的证书 acme.sh --remove -d example.com删除指定的证书 ","date":"2022-07-21T19:05:52+08:00","image":"https://lbqaq.top/p/%E4%B8%80%E6%AD%A5%E5%88%B0%E4%BD%8D%E8%87%AA%E5%8A%A8%E7%94%B3%E8%AF%B7ssl%E8%AF%81%E4%B9%A6/99528942.webp","permalink":"https://lbqaq.top/p/%E4%B8%80%E6%AD%A5%E5%88%B0%E4%BD%8D%E8%87%AA%E5%8A%A8%E7%94%B3%E8%AF%B7ssl%E8%AF%81%E4%B9%A6/","title":"一步到位，自动申请SSL证书"},{"content":"云计算的三个特点 资源池化\n大部分云计算资源，都是池化了的资源。什么叫池化？池化就是物理资源的基础上，通过软件平台，封装成虚拟的计算资源，也就是我们常说的虚拟化。\n弹性伸缩\n云计算的计算资源，可以按需付费。你想要用多少，就租多少，想什么时候要就什么时候要，配置是支持自定义的。\n安全可靠\n而云计算，从物理角度来说，所有的计算资源都汇集在大型互联网数据中心（IDC），那里有严格的安保、抗震的建筑、安全的供电，有非常全面的容灾设计和应急方案，能够更好地保护计算资源，不会轻易地中断服务。\n从软件上来说，云计算服务提供商有更专业的技术团队，更成熟的技术储备，能够更好地保护计算资源不被入侵或破坏。\n云计算服务 应该不考，为了完备性还是放进来吧\nInfrastructure as a Service (IaaS)：基础设施即服务 Platform as a Service (PaaS) ：平台即服务 Software as a Service (SaaS) ：软件即服务 云计算类型 公有云 公有云通常指第三方提供商用户能够使使用的云，公有云一般可通过 Internet 使用，可能是免费或成本低廉的。公有云的最大意义是能够以低廉的价格，提供有吸引力的服务给最终用户，创造新的业务价值，公有云作为一个支撑平台，还能够整合上游的服务（如增值业务，广告）提供者和下游最终用户，打造新的价值链和生态系统。它使客户能够访问和共享基本的计算机基础设施，其中包括硬件、存储和带宽等资源。\n公有云是为大众建的，所有入驻用户都称租户，不仅同时有很多租户，而且一个租户离开，其资源可以马上释放给下一个租户。\n优点：\n成本低 方便 易扩展 缺点：\n安全顾虑 性能超卖问题 管理要复杂 私有云 是为一个客户单独使用而构建的，因而提供对数据、安全性和服务质量的最有效控制。该公司拥有基础设施，并可以控制在此基础设施上部署应用程序的方式。私有云可部署在企业数据中心的防火墙内(本地私有云)，也可以将它们部署在一个安全的主机托管场所（托管私有云）。\n优点：\n安全 自主可控 缺点：\n成本高 远程访问困难 社区云 社区云的核心特征是云端资源只给两个或者两个以上的特定单位组织内的员工使用，除此之外的人和机构都无权租赁和使用云端计算资源。与私有云类似，社区云的云端也有两种部署方法，即本地部署和托管部署。\n混合云 是两个或两个以上不同类型的云（私有云、社区云、公共云）服务的结合，这种结合可以是计算的、存储的，也可以两者兼而有之。\n优点：\n操作灵活 弹性 成本效益。混合云模式具有成本效益，因为企业可以根据需要决定使用成本更昂贵的云计算资源。 缺点：\n安全性不强 费用高。 公有云+私有云管理费用高昂 兼容性问题 RDD的创建 使用makeRDD即可，例如val rdd = sc.makeRDD(List(1, 2, 3, 4)) 。在使用makeRDD时我们也可以指定分区数量，如val rdd: RDD[Int] = sc.makeRDD(List(1, 2, 3, 4), 3)，这里我们就创建了3个分区。\n当然，除了从程序中创建，我们也可以从文件中读取数据，使用sc.textFile(\u0026quot;input\u0026quot;)函数来按行读取文件里的数据。如val lineRDD: RDD[String] = sc.textFile(\u0026quot;E:\\\\datas\u0026quot;)\nValue类型转换算子 map def map[U: ClassTag](f: T =\u0026gt; U ): RDD[U]\n将处理的数据逐条进行映射转换，这里的转换可以是类型的转换，也可以是值的转换。\n1 2 3 4 5 6 7 8 9 10 val rdd = sc.makeRDD(List(1, 2, 3, 4)) def mapFunction(num: Int): Int = {num * 2} //转换函数 val mapRDD1: RDD[Int] = rdd.map(mapFunction) val mapRDD2 = rdd.map((num: Int) =\u0026gt; {num * 2}) //匿名函数 val mapRDD3 = rdd.map((num: Int) =\u0026gt; num * 2) //函数的代码逻辑只有一行的时候，{}可省略 val mapRDD4 = rdd.map((num) =\u0026gt; num * 2) //参数类型可以推断出来，参数类型可以省略 val mapRDD5 = rdd.map(num =\u0026gt; num * 2) //参数列表中的参数只有一个，()可以省略 val mapRDD6 = rdd.map(_ * 2) //参数在逻辑中只出现一次，且顺序出现，参数可用_代替 注意要认识最后的简写形式。\nmapPartiotions def mapPartitions[U: ClassTag]( f: Iterator[T] =\u0026gt; Iterator[U],preservesPartitioning: Boolean = false): RDD[U]\n以分区为单位进行数据转换操作，但是会将整个分区的数据加载到内存进行引用，由于存在对象的引用，因此处理完的数据不会被释放掉。\n1 2 3 4 5 6 7 8 val lineRdd = sc.makeRDD(List(1, 2, 3, 4),2) val rdd2: RDD[Int] = lineRdd.mapPartitions( iter =\u0026gt; { println(\u0026#34;+++++++++++++++\u0026#34;) iter.map(_ * 2) } ) rdd2.collect().foreach(println) 结果：\n1 2 3 4 5 6 +++++++++++++++ +++++++++++++++ 2 4 6 8 上面代码的意思是将每个数据乘以2，并在每次计算时输出+++++，从输出两条+++++可知，mapPartiotions算子确实是按分区进行操作。\nmap 和 mapPartitions 的区别？\nMap 算子是分区内一个数据一个数据的执行，类似于串行操作。而 mapPartitions 算子是以分区为单位进行批处理操作。 Map 算子主要目的将数据源中的数据进行转换和改变。但是不会减少或增多数据。MapPartitions 算子需要传入一个迭代器，返回一个迭代器，没有要求的元素的个数保持不变， 所以可以增加或减少数据。 Map 算子因为类似于串行操作，所以性能比较低，而是 mapPartitions 算子类似于批处理，所以性能较高。但是mapPartitions 算子会长时间占用内存，那么这样会导致内存可能不够用，出现内存溢出的错误。 mapPartitionWithIndex def mapPartitionsWithIndex[U: ClassTag]( f: (Int, Iterator[T]) =\u0026gt; Iterator[U] ,preservesPartitioning: Boolean = false): RDD[U]\n将待处理的数据以分区为单位发送到计算节点进行处理，这里的处理是指可以进行任意的处理，哪怕是过滤数据，在处理时同时可以获取当前分区索引。\n1 2 3 4 5 6 7 8 9 10 11 val lineRdd = sc.makeRDD(List(1, 2, 3, 4), 2) val rdd2: RDD[Int] = lineRdd.mapPartitionsWithIndex( (index, iter) =\u0026gt; { if (index == 1) { iter } else { Nil.iterator //Nil是空List } } ) rdd2.collect().foreach(println) 结果：\n1 2 3 4 在上面的程序中，我们对第0个分区进行抛弃，对第1个分区进行保留。如所示，程序仅输出了第1分区里的内容。\nflatMap def flatMap[U: ClassTag](f: T =\u0026gt; TraversableOnce[U]): RDD[U]\n将处理的数据进行扁平化后再进行映射处理，所以算子也称之为扁平映射\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 val lineRdd: RDD[Int] = sc.makeRDD(List(1, 2, 3, 4, 5), 2) val groupRDD: RDD[(Int, Iterable[Int])] = lineRdd.groupBy(_ % 2) groupRDD.foreach(println) val rdd1: RDD[Int] = groupRDD.flatMap( _._2) println(\u0026#34;Iterable[Int]的flatMap：\u0026#34; + rdd1.collect().mkString(\u0026#34;,\u0026#34;)) val data2: RDD[List[Int]] = groupRDD.map(_._2.toList) val rdd2: RDD[Int] = data2.flatMap(t =\u0026gt; t) println(\u0026#34;List[Int]的flatMap：\u0026#34; + rdd2.collect().mkString(\u0026#34;,\u0026#34;)) val lineRdd2 = sc.makeRDD(List(List(1, 2), 3, List(4,5)),2) val rdd22: RDD[Any] = lineRdd2.flatMap { case list: List[_] =\u0026gt; list case num: Int =\u0026gt; List(num) } rdd22.collect().foreach(println) 结果：\n1 2 3 4 5 6 7 8 9 (0,CompactBuffer(2, 4)) (1,CompactBuffer(1, 3, 5)) Iterable[Int]的flatMap：2,4,1,3,5 List[Int]的flatMap：2,4,1,3,5 1 2 3 4 5 在第一段程序中，我们看出RDD[List]和RDD[iterable]都可以被flaMap算子进行扁平化。在第二段程序中，我们将将 List(List(1,2),3,List(4,5))进行扁平化操作。\n重新分区与数据筛选 coalesce def coalesce(numPartitions: Int, shuffle: Boolean = false, partitionCoalescer: Option[PartitionCoalescer] = Option.empty) (implicit ord: Ordering[T] = null): RDD[T]\n根据数据量缩减分区，用于大数据集过滤后，提高小数据集的执行效率。\n当 spark 程序中，存在过多的小任务的时候，可以通过 coalesce 方法，收缩合并分区，减少分区的个数，减小任务调度成本。\ncoalesce方法默认情况下不会将分区的数据打乱重新组合，只是将多个分区合并为1一个分区。\n1 2 3 4 5 val rdd = sc.makeRDD(List(1, 2, 3, 4, 5,6),3) val rdd2: RDD[Int] = rdd.coalesce(2) //1:1 2 //2:3 4 5 6 上面代码的含义是将3个分区缩减成2个，可见成功执行，一个分区里有2个数，而另一个分区里有4个数。\nrepartition def repartition(numPartitions: Int)(implicit ord: Ordering[T] = null): RDD[T]\n该操作内部其实执行的是 coalesce 操作，参数 shuffle 的默认值为 true。无论是将分区数多的RDD 转换为分区数少的RDD，还是将分区数少的 RDD 转换为分区数多的RDD，repartition 操作都可以完成，因为无论如何都会经 shuffle 过程。\n1 2 3 4 5 val rdd = sc.makeRDD(List(1, 2, 3, 4, 5,6),3) val rdd2: RDD[Int] = rdd.repartition(2) //1:1 4 5 //2:2 3 6 由于参数 shuffle 的值为 true，将分区的数据打乱重新组合以保证不会出现数据倾斜\ndistinct def distinct()(implicit ord: Ordering[T] = null): RDD[T]\n将数据集中重复的数据去重\n1 2 3 4 5 val rdd = sc.makeRDD(List(1, 2, 3, 4, 1, 2, 3, 4)) val disRDD = rdd.distinct() disRDD.collect().foreach(println) //4 1 3 2 filter def filter(f: T =\u0026gt; Boolean): RDD[T]\n将数据根据指定的规则进行筛选过滤，符合规则的数据保留，不符合规则的数据丢弃。当数据进行筛选过滤后，分区不变，但是分区内的数据可能不均衡\n1 2 3 4 5 val lineRdd = sc.makeRDD(List(1,2,3,4),2) val filterRDD: RDD[Int] = lineRdd.filter((num =\u0026gt; num % 2 == 0)) filterRDD.collect().foreach(println) //2 4 在上面的程序中，我们过滤掉所有的奇数，仅仅保留偶数\ngroupBy 将数据根据指定的规则进行分组, 分区默认不变，但是数据会被打乱重新组合，我们将这样的操作称之为shuffle。极限情况下，数据可能被分在同一个分区中。\n1 2 3 4 5 6 7 8 9 10 val lineRdd = sc.makeRDD(List(1, 2, 3, 4), 2) def groupFunction(num: Int): Int = { num % 2 } //val groupRDD: RDD[(Int, Iterable[Int])] = lineRdd.groupBy(_ % 2) val groupRDD: RDD[(Int, Iterable[Int])] = lineRdd.groupBy(groupFunction) groupRDD.collect().foreach(println) 结果：\n1 2 (0,CompactBuffer(2, 4)) (1,CompactBuffer(1, 3)) 在上面的代码中，按奇偶数进行分组\nsortBy def sortBy[K] ( f: (T) =\u0026gt; K, ascending: Boolean = true, numPartitions: Int = this.partitions.length) (implicit ord: Ordering[K], ctag: ClassTag[K]): RDD[T]\n该操作用于排序数据。在排序之前，可以将数据通过 f 函数进行处理，之后按照 f 函数处理的结果进行排序，默认为升序排列。排序后新产生的 RDD 的分区数与原RDD 的分区数一致。中间存在 shuffle 的过程\n1 2 3 4 5 6 7 val rdd = sc.makeRDD(List((\u0026#34;11\u0026#34;, 2), (\u0026#34;1\u0026#34;, 1), (\u0026#34;2\u0026#34;, 3)), 2) val sortRDD: RDD[(String, Int)] = rdd.sortBy(t =\u0026gt; t._1) sortRDD.collect().foreach(println) //(1,1) //(11,2) //(2,3) 上面是字符串排序，按字典序。下面转换成数字，注意两者区别\n1 2 3 4 5 6 7 val rdd = sc.makeRDD(List((\u0026#34;11\u0026#34;, 2), (\u0026#34;1\u0026#34;, 1), (\u0026#34;2\u0026#34;, 3)), 2) val sortRDD: RDD[(String, Int)] = rdd.sortBy(t =\u0026gt; t._1.toInt) sortRDD.collect().foreach(println) //(1,1) //(2,3) //(11,2) 集合类型算子操作 intersection def intersection(other: RDD[T]): RDD[T]\n对源RDD 和参数RDD 求交集后返回一个新的RDD\n1 2 3 4 5 6 val rdd1 = sc.makeRDD(List(1, 2, 3, 4, 5,6),3) val rdd2 = sc.makeRDD(List(1, 2, 3),1) val rdd3 = rdd1.intersection(rdd2) rdd3.collect().foreach(println) //3 1 2 union def union(other: RDD[T]): RDD[T]\n对源RDD 和参数RDD 求并集后返回一个新的RDD\n1 2 3 4 5 6 val rdd1 = sc.makeRDD(List(1, 2, 3)) val rdd2 = sc.makeRDD(List(4, 5, 6)) val rdd3 = rdd1.union(rdd2) rdd3.collect().foreach(println) //1 2 3 4 5 6 subtract def subtract(other: RDD[T]): RDD[T]\n以一个 RDD 元素为主，去除两个 RDD 中重复元素，将其他元素保留下来。求差集\n1 2 3 4 5 6 val rdd1 = sc.makeRDD(List(1, 2, 3, 4, 5, 6)) val rdd2 = sc.makeRDD(List(4, 5, 6)) val rdd3 = rdd1.subtract(rdd2) rdd3.collect().foreach(println) //1 2 3 zip def zip[U: ClassTag](other: RDD[U]): RDD[(T, U)]\n将两个 RDD 中的元素，以键值对的形式进行合并。其中，键值对中的Key 为第 1 个 RDD中的元素，Value 为第 2 个 RDD 中的相同位置的元素。\n1 2 3 4 5 val rdd1 = sc.makeRDD(List(1, 2, 3, 4), 2) val rdd2 = sc.makeRDD(List(3, 4, 5, 6), 2) val zipRDD: RDD[(Int, Int)] = rdd1.zip(rdd2) println(zipRDD.collect().mkString(\u0026#34;,\u0026#34;)) //(1,3),(2,4),(3,5),(4,6) 如果两个RDD 数据类型不一致 ，对于交集，并集，差集，两个RDD的数据类型必须相同。对于拉链操作，两个RDD的数据类型可以不同。 如果两个RDD的分区中数据量不一致，对于交集，并集，差集，两个RDD的分区中数据量不需要相同；对于拉链操作分区中数据量必须相同。 Key-Value类型算子 reduceByKey def reduceByKey(func: (V, V) =\u0026gt; V): RDD[(K, V)]\n可以将数据按照相同的Key 对Value 进行聚合，聚合操作是两两进行聚合的。reduceByKey中如果key的数据只有一个，是不会参与运算的。\n1 2 3 4 5 val rdd: RDD[(String)] = sc.makeRDD(List(\u0026#34;Hello Scala\u0026#34;, \u0026#34;Hello Spark\u0026#34;, \u0026#34;Hello Spark\u0026#34;, \u0026#34;Hello 123\u0026#34;),2) val wordRDD: RDD[String] = rdd.flatMap(_.split(\u0026#34; \u0026#34;)) val wordOneRDD: RDD[(String, Int)] = wordRDD.map((_, 1)) val result: RDD[(String, Int)] = wordOneRDD.reduceByKey(_ + _) result.collect().foreach(println) 结果：\n1 2 3 4 (Hello,4) (123,1) (Scala,1) (Spark,2) 在上面的代码中，根据参数_+_，即表示将两个value进行相加。\ngroupByKey def groupByKey(): RDD[(K, Iterable[V])]\n将数据源的数据根据 key， 对 value 进行分组，将数据源中相同key的数据分在一个组中，行成一个对偶元祖，元组中的第一个元素就是key，元组中的第二个元素就行相同key的value的集合。\n1 2 3 4 5 6 val rdd = sc.makeRDD(List((\u0026#34;a\u0026#34;, 1), (\u0026#34;a\u0026#34;, 1), (\u0026#34;a\u0026#34;, 1), (\u0026#34;b\u0026#34;, 1), (\u0026#34;b\u0026#34;, 1), (\u0026#34;b\u0026#34;, 1), (\u0026#34;b\u0026#34;, 1), (\u0026#34;a\u0026#34;, 1)), 2) val groupRDD: RDD[(String, Iterable[Int])] = rdd.groupByKey() groupRDD.collect().foreach(println) //(b,CompactBuffer(1, 1, 1, 1)) //(a,CompactBuffer(1, 1, 1, 1)) aggregateByKey def aggregateByKey[U: ClassTag](zeroValue: U)(seqOp: (U, V) =\u0026gt; U, combOp: (U, U) =\u0026gt; U): RDD[(K, U)]\n将数据根据不同的规则进行分区内计算和分区间计算。\naggregateByKey存在函数柯里化，有两个参数列表。\n第一个参数列表，需要传递一个参数，表示初始值。主要用于当碰见第一个key的时候，和value进行分区内计算。\n第二个参数列表需要传递两个参数\n参数2.1：分区内的计算规则 参数2.2：分区间的计算规则 1 2 3 4 5 6 7 8 9 10 11 val rdd = sc.makeRDD(List((\u0026#34;a\u0026#34;, 1), (\u0026#34;a\u0026#34;, 2), (\u0026#34;b\u0026#34;, 3), (\u0026#34;b\u0026#34;, 4), (\u0026#34;b\u0026#34;, 5), (\u0026#34;a\u0026#34;, 6)), 2) //同分区获取最大值，不同分区相加求和 val rdd2: RDD[(String, Int)] = rdd.aggregateByKey(0)( (x, y) =\u0026gt; math.max(x, y), (x, y) =\u0026gt; x + y ) rdd2.collect().foreach(println) //(b,8) //(a,8) foldByKey def foldByKey(zeroValue: V)(func: (V, V) =\u0026gt; V): RDD[(K, V)]\n当分区内计算规则和分区间计算规则相同时，aggregateByKey 就可以简化为foldByKey\n1 2 3 4 5 6 7 8 val rdd = sc.makeRDD(List((\u0026#34;a\u0026#34;, 1), (\u0026#34;a\u0026#34;, 2), (\u0026#34;b\u0026#34;, 3), (\u0026#34;b\u0026#34;, 4), (\u0026#34;b\u0026#34;, 5), (\u0026#34;a\u0026#34;, 6)), 2) //同分区相加求和，不同分区相加求和 val rdd2: RDD[(String, Int)] = rdd.foldByKey(0)(_ + _) rdd2.collect().foreach(println) //(b,12) //(a,9) combineByKey def combineByKey[C]( createCombiner: V =\u0026gt; C, mergeValue: (C, V) =\u0026gt; C, mergeCombiners: (C, C) =\u0026gt; C): RDD[(K, C)]\n对key-value 型 rdd 进行聚集操作的聚集函数（aggregation function）。类似于aggregate()，combineByKey()允许用户返回值的类型与输入不一致。\ncombineByKey方法需要三个参数\n第一个参数：表示将相同key的第一个数据进行结构的转换，实现操作 第二个参数：表示分区内的计算规则 第三个参数：表示分区间的计算规则 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 val rdd = sc.makeRDD(List((\u0026#34;a\u0026#34;, 1), (\u0026#34;a\u0026#34;, 2), (\u0026#34;b\u0026#34;, 3), (\u0026#34;b\u0026#34;, 4), (\u0026#34;b\u0026#34;, 5), (\u0026#34;a\u0026#34;, 6)), 2) val rdd2: RDD[(String, (Int, Int))] = rdd.combineByKey( (t) =\u0026gt; (t, 1), (t: (Int, Int), v) =\u0026gt; { (t._1 + v, t._2 + 1) }, (t1: (Int, Int), t2: (Int, Int)) =\u0026gt; { (t1._1 + t2._1, t1._2 + t2._2) } ) val rdd3: RDD[(String, Int)] = rdd2.map { case (str, (t1, t2)) =\u0026gt; { (str, t1 / t2) } } rdd3.collect().foreach(println) //(b,4) //(a,3) 在上面的例子中，首先将相同key的格式转为(t,1)，分区内计算对于第一个数据进行相加，第二个数据+1，分区间将第一和第二个数据对应相加。\njoin def join[W](other: RDD[(K, W)]): RDD[(K, (V, W))]\n在类型为(K,V)和(K,W)的RDD 上调用，返回一个相同 key 对应的所有元素连接在一起的(K,(V,W))的RDD\n两个RDD中的元素对进行笛卡尔乘积性质的匹配，但只会打印出匹配成功的。\n1 2 3 4 5 6 7 8 val rdd1 = sc.makeRDD(List((\u0026#34;a\u0026#34;, 1), (\u0026#34;b\u0026#34;, 2), (\u0026#34;c\u0026#34;, 3)), 2) val rdd2 = sc.makeRDD(List((\u0026#34;b\u0026#34;, 5), (\u0026#34;a\u0026#34;, 4), (\u0026#34;c\u0026#34;, 6)), 2) var joinRDD: RDD[(String, (Int, Int))] = rdd1.join(rdd2) joinRDD.collect().foreach(println) //(b,(2,5)) //(a,(1,4)) //(c,(3,6)) 在上面的例子里，成功将a,b,c后面的值合在一起了\n如果两个数据源中有多个相同的key，那么数据源a中的key会与数据源b中相同的key多次匹配成功，因此会数据量会几何性质增长\n1 2 3 4 5 6 7 val rdd1 = sc.makeRDD(List((\u0026#34;a\u0026#34;,1), (\u0026#34;b\u0026#34;, 2),(\u0026#34;c\u0026#34;, 3)),2) val rdd2 = sc.makeRDD(List((\u0026#34;b\u0026#34;, 5), (\u0026#34;d\u0026#34;,4), (\u0026#34;b\u0026#34;, 6)),2) var joinRDD: RDD[(String, (Int, Int))] = rdd1.join(rdd2) joinRDD.collect().foreach(println) //(b,(2,5)) //(b,(2,6)) leftOuterJoin def leftOuterJoin[W](other: RDD[(K, W)]): RDD[(K, (V, Option[W]))]\n类似于 SQL 语句的左外连接，根据左边第一个元素将两个RDD连接起来，和join算子类似，但这个可以支持key不匹配的情况。\n1 2 3 4 5 6 7 8 9 val rdd1 = sc.makeRDD(List((\u0026#34;a\u0026#34;, 1), (\u0026#34;b\u0026#34;, 2), (\u0026#34;c\u0026#34;, 3)), 2) val rdd2 = sc.makeRDD(List((\u0026#34;a\u0026#34;, 5), (\u0026#34;b\u0026#34;, 4)), 2) val leftJoinRDD: RDD[(String, (Int, Option[Int]))] = rdd1.leftOuterJoin(rdd2) leftJoinRDD.collect().foreach(println) //(b,(2,Some(4))) //(a,(1,Some(5))) //(c,(3,None)) 1 2 3 4 5 6 7 8 9 10 11 val rdd1 = sc.makeRDD(List((\u0026#34;a\u0026#34;, 1), (\u0026#34;b\u0026#34;, 2), (\u0026#34;c\u0026#34;, 3)), 2) val rdd2 = sc.makeRDD(List((\u0026#34;a\u0026#34;, 5), (\u0026#34;b\u0026#34;, 4), (\u0026#34;b\u0026#34;, 5), (\u0026#34;b\u0026#34;, 6)), 2) val leftJoinRDD: RDD[(String, (Int, Option[Int]))] = rdd1.leftOuterJoin(rdd2) leftJoinRDD.collect().foreach(println) //(b,(2,Some(4))) //(b,(2,Some(5))) //(b,(2,Some(6))) //(a,(1,Some(5))) //(c,(3,None)) rightOuterJoin 类似于左外连接，两者区别在于左连接是以左边的RDD为主，右连接以右边的RDD为主。\n1 2 3 4 5 6 7 8 9 val rdd1 = sc.makeRDD(List((\u0026#34;a\u0026#34;,1), (\u0026#34;b\u0026#34;, 2)),2) val rdd2 = sc.makeRDD(List((\u0026#34;a\u0026#34;, 5), (\u0026#34;b\u0026#34;,4),(\u0026#34;c\u0026#34;, 3)),2) val rightJoinRDD: RDD[(String, (Option[Int], Int))] = rdd1.rightOuterJoin(rdd2) rightJoinRDD.collect().foreach(println) //(b,(Some(2),4)) //(a,(Some(1),5)) //(c,(None,3)) 行动算子 reduce def reduce(f: (T, T) =\u0026gt; T): T\n聚集RDD 中的所有元素，先聚合分区内数据，再聚合分区间数据\n1 2 3 4 5 val rdd: RDD[Int] = sc.makeRDD(List(1,2,3,4)) // 聚合数据 val reduceResult: Int = rdd.reduce(_+_) println(reduceResult) //10 在上面的例子中，10=1+2+3+4\ncollect def collect(): Array[T]\n在驱动程序中，方法会将不同分区的数据按照分区顺序采集到Driver端内存中，形成数组。\n1 2 3 4 5 val rdd: RDD[Int] = sc.makeRDD(List(1, 2, 3, 4), 2) //收集数据到Driver rdd.collect().foreach(println) //1 2 3 4 first def first(): T\n返回RDD 中的第一个元素\n1 2 3 4 val rdd: RDD[Int] = sc.makeRDD(List(1,2,3,4)) val firstResult: Int = rdd.first() println(firstResult) //1 take def take(num: Int): Array[T]\n返回一个由RDD 的前 n 个元素组成的数组\n1 2 3 4 5 val rdd: RDD[Int] = sc.makeRDD(List(1, 2, 3, 4)) val takeResult: Array[Int] = rdd.take(2) println(takeResult.mkString(\u0026#34;,\u0026#34;)) //1,2 takeOrdered def takeOrdered(num: Int)(implicit ord: Ordering[T]): Array[T]\n返回该 RDD 排序后的前 n 个元素组成的数组\n1 2 3 4 val rdd: RDD[Int] = sc.makeRDD(List(1, 3, 2, 4)) val result: Array[Int] = rdd.takeOrdered(2) result.foreach(println) //1 2 aggregate def aggregate[U: ClassTag](zeroValue: U)(seqOp: (U, T) =\u0026gt; U, combOp: (U, U) =\u0026gt; U): U\n分区的数据通过初始值和分区内的数据进行聚合，然后再和初始值进行分区间的数据聚合；即，初始值不仅参与分区内计算，同时也参与分区间计算。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 val rdd: RDD[Int] = sc.makeRDD(List(1, 2, 3, 4), 8) /* * 组内： * 初值10,分区1(1)，组内结果11 * 初值10,分区2(2)，组内结果12 * 初值10,分区3(3)，组内结果13 * 初值10,分区4(4)，组内结果14 * 初值10,分区5(0)，组内结果10 * 初值10,分区6(0)，组内结果10 * 初值10,分区7(0)，组内结果10 * 初值10,分区8(0)，组内结果10 * * 组间： * 初值10,分区(11,12,13,14,10,10,10,10)，结果100 */ val result: Int = rdd.aggregate(10)(_ + _, _ + _) println(result) //100 fold def fold(zeroValue: T)(op: (T, T) =\u0026gt; T): T\n折叠操作，aggregate的简化版操作\n1 2 3 4 val rdd: RDD[Int] = sc.makeRDD(List(1, 2, 3, 4)) val foldResult: Int = rdd.fold(0)(_ + _) println(foldResult) //10 countByKey def countByKey(): Map[K, Long]\n统计每种 key 的个数\n1 2 3 4 5 val rdd: RDD[(Int, String)] = sc.makeRDD(List((1, \u0026#34;a\u0026#34;), (1, \u0026#34;a\u0026#34;), (1, \u0026#34;a\u0026#34;), (2, \u0026#34;b\u0026#34;), (3, \u0026#34;c\u0026#34;), (3, \u0026#34;c\u0026#34;))) // 统计每种 key 的个数 val result: collection.Map[Int, Long] = rdd.countByKey() println(result) //Map(1 -\u0026gt; 3, 2 -\u0026gt; 1, 3 -\u0026gt; 2) RDD 依赖关系 窄依赖 窄依赖表示每一个父(上游)RDD 的 Partition 最多被子（下游）RDD 的一个 Partition 使用， 窄依赖我们形象的比喻为独生子女。\n宽依赖 宽依赖表示同一个父（上游）RDD 的 Partition 被多个子（下游）RDD 的 Partition 依赖，会引起 Shuffle，总结：宽依赖我们形象的比喻为多生。\nWordCount 典中典程序，必考\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import org.apache.spark.rdd.RDD import org.apache.spark.{SparkConf, SparkContext} object WordCount { def main(args: Array[String]): Unit = { val sparkConf = new SparkConf().setMaster(\u0026#34;local\u0026#34;).setAppName(\u0026#34;WordCount\u0026#34;); val sc = new SparkContext(sparkConf) val rdd: RDD[String] = sc.textFile(\u0026#34;spark-core/src/main/resources/words\u0026#34;) val wordRDD: RDD[String] = rdd.flatMap(_.split(\u0026#34; \u0026#34;)) val wordOneRDD: RDD[(String, Int)] = wordRDD.map((_, 1)) val result: RDD[(String, Int)] = wordOneRDD.reduceByKey(_ + _) result.collect().foreach(println) //关闭连接 sc.stop(); } } 有向无环图 DAG(Directed Acyclic Graph)叫做有向无环图，原始的RDD通过一系列的转换就形成了DAG。\nstage的划分 一个Job会被拆分为多组Task，每组任务被称为一个stage。stage表示不同的调度阶段，一个spark job会对应产生很多个stage。\n根据RDD之间依赖关系的不同将DAG划分成不同的Stage(调度阶段)\n对于窄依赖，partition的转换处理在一个Stage中完成计算 对于宽依赖，由于有Shuffle的存在，只能在parent RDD处理完成后，才能开始接下来的计算 划分stage的依据就是宽依赖\n首先根据rdd的算子操作顺序生成DAG有向无环图，接下里从最后一个rdd往前推，创建一个新的stage，把该rdd加入到该stage中，它是最后一个stage。 在往前推的过程中运行遇到了窄依赖就把该rdd加入到本stage中，如果遇到了宽依赖，就从宽依赖切开，那么最后一个stage也就结束了。 重新创建一个新的stage，按照第二个步骤继续往前推，一直到最开始的rdd，整个划分stage也就结束了 划分完stage之后，每一个stage中有很多可以并行运行的task，后期把每一个stage中的task封装在一个taskSet集合中，最后把一个一个的taskSet集合提交到worker节点上的executor进程中运行。\nrdd与rdd之间存在依赖关系，stage与stage之前也存在依赖关系，前面stage中的task先运行，运行完成了再运行后面stage中的task，也就是说后面stage中的task输入数据是前面stage中task的输出结果数据。\n缓存和检查点区别 必考，也是非常重要\nCache 缓存只是将数据临时保存起来。Cache 缓存的数据通常存储在内存，可靠性低。不切断血缘依赖，只会在血缘关系中添加新的依赖，一旦出现问题，可以重头读取数据。 persisit：将数据临时存储在磁盘文件中进行数据重用，涉及到磁盘IO，性能较低，但是数据安全。如果作业执行完毕，临时保存的数据文件就会丢失。 CheckPoint：将数据长久地保存在磁盘文件中进行数据重用，涉及到磁盘IO，性能较低，但是数据安全。为了包装数据安全，所以一般情况下，会独立执行作业，就是把当前需要持久化的RDD重新创建并保存。为了能够提高效率，通常和cache联合使用。 Checkpoint 检查点会切断血缘依赖，重新建立新的血缘关系。 cache 机制是每计算出一个要 cache 的 partition 就直接将其 cache 到内存了。但 checkpoint 没有使用这种第一次计算得到就存储的方法，而是等到 job 结束后另外启动专门的 job 去完成 checkpoint 。 也就是说需要 checkpoint 的 RDD 会被计算两次。因此，在使用checkpoint() 的时候，建议加上 rdd.cache()， 这样第二次运行的 job 就不用再去计算该 rdd 了，直接读取 cache 写磁盘。建议对checkpoint()的RDD 使用Cache 缓存，这样 checkpoint 的 job 只需从 Cache 缓存中读取数据即可，否则需要再从头计算一次RDD。Checkpoint 检查点切断血缘依赖。 combineByKey和aggregateByKey的异同 相同点 都有三个参数 第二个和第三个参数都是分区内操作和分区间操作 都属于聚合操作，使数据量减少 都是转换算子，不触发程序执行 不同点 对于第一个参数，aggregateByKey是设置初始值，combineByKey是进行转换 combineByKey组内计算和组间计算数据格式不一样； aggregateByKey组内计算和组间计算数据格式一样 aggregate和aggregateByKey的异同 相同点 都是具有分区内操作和分区间操作 都是聚合类型的算子 不同点 aggregateByKey的初始值不会参与分区间计算；对key进行操作，需要键值对 aggregate的初始值会参与分区间计算，会触发程序运行，进行读数据 求平均值 典中典程序，这也是必考\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import org.apache.spark.rdd.RDD import org.apache.spark.{SparkConf, SparkContext} object exam { def main(args: Array[String]): Unit = { val sparkConf = new SparkConf().setMaster(\u0026#34;local\u0026#34;).setAppName(\u0026#34;exam\u0026#34;); val sc = new SparkContext(sparkConf) val lineRdd: RDD[(String, Int)] = sc.makeRDD(List((\u0026#34;Spark\u0026#34;, 5), (\u0026#34;Hadoop\u0026#34;, 3), (\u0026#34;Scala\u0026#34;, 4), (\u0026#34;Spark\u0026#34;, 3), (\u0026#34;Hadoop\u0026#34;, 1))) val rdd1: RDD[(String, (Int, Int))] = lineRdd.map(t =\u0026gt; (t._1, (t._2, 1))) val rdd2: RDD[(String, (Int, Int))] = rdd1.reduceByKey((t, k) =\u0026gt; ((t._1 + k._1), (t._2 + k._2))) val rdd3: RDD[(String, Int)] = rdd2.map( t =\u0026gt; (t._1, t._2._1 / t._2._2) ) rdd3.collect().foreach(println) sc.stop() } } 算子补充 glom def glom(): RDD[Array[T]]\n将同一个分区的数据直接转换为一个相同类型的内存数组进行处理，分区不变\n1 2 3 4 5 val lineRdd = sc.makeRDD(List(1, 2, 3, 4),2) val glomRDD: RDD[Array[Int]] = lineRdd.glom() glomRDD.collect().foreach(data =\u0026gt; println(data.mkString(\u0026#34;,\u0026#34;))) //1,2 //3,4 sample def sample( withReplacement: Boolean, fraction: Double, seed: Long = Utils.random.nextLong): RDD[T]\n根据指定的规则从数据集中抽取数据\n第1个参数withReplacement表示：抽取后是否将数据返回，true（放回），false（丢弃） 第2个参数fraction表示： 当第一参数为true，第二个参数表示：抽取不放回的概率；基准值的概念（每个数有一个0~1随机值，用随即值与基准值进行比较）； 当第一个参数为false，第二个参数表示，可能抽取的次数。 第3个参数seed表示：抽取数据时，随机算法的种子；如果不传第三个参数，那么使用的当前系统时间 1 2 3 4 5 6 7 8 9 10 11 12 13 val dataRDD = sparkContext.makeRDD(List( 1,2,3,4),1) // 抽取数据不放回（伯努利算法） // 伯努利算法：又叫 0、1 分布。例如扔硬币，要么正面，要么反面。 // 具体实现：根据种子和随机算法算出一个数和第二个参数设置几率比较，小于第二个参数要，大于不要 // 第一个参数：抽取的数据是否放回，false：不放回 // 第二个参数：抽取的几率，范围在[0,1]之间,0：全不取；1：全取； // 第三个参数：随机数种子 val dataRDD1 = dataRDD.sample(false, 0.5) // 抽取数据放回（泊松算法） // 第一个参数：抽取的数据是否放回，true：放回；false：不放回 // 第二个参数：重复数据的几率，范围大于等于 0.表示每一个元素被期望抽取到的次数 // 第三个参数：随机数种子 val dataRDD2 = dataRDD.sample(true, 2) partitionBy def partitionBy(partitioner: Partitioner): RDD[(K, V)]\n将数据按照指定的Partitioner规则 重新进行重新分区。Spark 默认的分区器是HashPartitioner\n太冷门了，应该不考，就不放代码了\ncogroup def cogroup[W](other: RDD[(K, W)]): RDD[(K, (Iterable[V], Iterable[W]))]\n在类型为(K,V)和(K,W)的RDD 上调用，返回一个(K,(Iterable,Iterable))类型的 RDD\n1 2 3 4 5 6 7 8 9 10 val rdd1 = sc.makeRDD(List((\u0026#34;a\u0026#34;,1), (\u0026#34;b\u0026#34;, 2), (\u0026#34;x\u0026#34;, 44)),2) val rdd2 = sc.makeRDD(List((\u0026#34;a\u0026#34;, 5), (\u0026#34;b\u0026#34;,4),(\u0026#34;c\u0026#34;, 3), (\u0026#34;c\u0026#34;, 99)),2) val cgRDD: RDD[(String, (Iterable[Int], Iterable[Int]))] = rdd1.cogroup(rdd2) cgRDD.collect().foreach(println) //(x,(CompactBuffer(44),CompactBuffer())) //(b,(CompactBuffer(2),CompactBuffer(4))) //(a,(CompactBuffer(1),CompactBuffer(5))) //(c,(CompactBuffer(),CompactBuffer(3, 99))) 下面都是行动算子\ncount def count(): Long\n返回RDD 中元素的个数\nsaveAsTextFile def saveAsTextFile(path: String): Unit\n保存成 Text 文件\n1 rdd.saveAsTextFile(\u0026#34;output\u0026#34;) ","date":"2022-06-08T09:33:43+08:00","image":"https://lbqaq.top/p/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/97475626.webp","permalink":"https://lbqaq.top/p/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"云计算学习笔记"},{"content":"卷积神经网络(CNN) CNN的基本架构 一个典型的卷积网络是由卷积层、 汇聚层、 全连接层交叉堆叠而成。\n一个卷积块为连续 𝑀 个卷积层和 𝑏 个汇聚层（ 𝑀 通常设置为2 ∼ 5，𝑏为0或1）。 一个卷积网络中可以堆叠𝑁 个连续的卷积块， 然后在后面接着 𝐾 个全连接层（ 𝑁 的取值区间比较大， 比如 1 ∼ 100 或者更大；𝐾 一般为0 ∼ 2）。\n上面这张图里的汇聚层也就是下面图中的池化层\n输入层。在上图中就是最左边的船的图像，计算机理解为输入若干个矩阵。 卷积层(Convolution Layer)。卷积层的激活函数使用的是ReLU，$ReLU(x) = max(0,x)$。 池化层(Pooling layer)。池化层没有激活函数。 卷积层+池化层的组合可以在隐藏层出现很多次，上图中出现两次。这里卷积层+池化层可随意组合，如卷积层+卷积层，或者卷积层+卷积层+池化层。不过我们一般都是若干卷积层+池化层的组合。\n全连接层(Fully Connected Layer, 简称FC)，输出层使用了Softmax激活函数来做图像识别的分 为了统一起见，我们下面对于Pooling layer的中文翻译都为汇聚层。\n卷积 对于一维卷积，我们假设滤波器长度为$K$， 它和一个信号序列$x_1,x_2,\u0026hellip;$的卷积为：\n$$ y_t=\\sum_{k=1}^{K}w_kx_{t-k+1} $$\n为了简单起见， 这里假设卷积的输出$y_t$ 的下标$t$从$k$开始\n信号序列$x$和滤波器$w$（也叫卷积核）的卷积定义为：\n$$ y=w*x $$\n其中$*$表示卷积运算。\n对于二维矩阵，给定图像$X(M\\times N)$，滤波器$W(U \\times V)$我们定义：\n$$ y_{ij}=\\sum_{u=1}^{U}\\sum_{v=1}^{V} w_{uv}x_{i-u+1,j-v+1} $$\n光看公式还是比较抽象的，还是要举个例子：\n图中的输入是一个二维的3x4的矩阵，而卷积核是一个2x2的矩阵。这里我们假设卷积是一次移动一个像素来卷积的，那么首先我们对输入的左上角2x2局部和卷积核卷积，即各个位置的元素相乘再相加，得到的输出矩阵S的$S_{00}$的元素，值为$aw+bx+ey+fz$。接着我们将输入的局部向右平移一个像素，现在是(b,c,f,g)四个元素构成的矩阵和卷积核来卷积，这样我们得到了输出矩阵S的$S_{01}$的元素，同样的方法，我们可以得到输出矩阵S的$S_{02}，S_{10}，S_{11}， S_{12}$的元素。\n最终我们得到卷积输出的矩阵为一个2x3的矩阵S。\n如果这个例子还是不直观，可以看下面这个动图：\n可是，考试时可不仅仅会考二维的矩阵，还会考三维矩阵。\n在介绍三维矩阵之前，我们先引入两个概念：\n步长(Stride)：指卷积核在滑动时的时间间隔。说人话就是矩阵每次右移的长度，比如下面要说的例子中步长为2就右移2个像素。 零填充(Zero Padding)：是在输入向量两端进行补零。比如下面要说的例子pad=1，就在矩阵周围填一圈0 在斯坦福大学的cs231n的课程上，有一个动态的例子，我们就看这个例子。\nConvolution demo\n可以看出来，对于三维的矩阵，我们是将其拆成3个二维的矩阵，然后对应的将输入$X$和卷积核$W$进行卷积运算。\n汇聚层 其作用是进行特征选择，降低特征数量， 从而减少参数数量。说人话就是输入张量的各个子矩阵进行压缩。假如是2x2的汇聚，那么就将子矩阵的每2x2个元素变成一个元素，如果是3x3的汇聚，那么就将子矩阵的每3x3个元素变成一个元素，这样输入矩阵的维度就变小了。\n要想将输入子矩阵的每nxn个元素变成一个元素，那么需要一个汇聚标准。常见的汇聚标准有2个，MAX或者是MEAN。即取对应区域的最大值或者平均值作为汇聚后的元素值。\n下面这个例子采用取最大值的汇聚方法。同时采用的是2x2的汇聚。步幅为2。\n首先对红色2x2区域进行汇聚，由于此2x2区域的最大值为6。那么对应的汇聚输出位置的值为6，由于步幅为2，此时移动到绿色的位置去进行汇聚，输出的最大值为8。同样的方法，可以得到黄色区域和蓝色区域的输出值。最终，我们的输入4x4的矩阵在汇聚后变成了2x2的矩阵，进行了压缩。\n例题 有了上面这些内容的铺垫，我们就会惊喜的发现，下面这道题可以轻松的完成了\n循环神经网络(RNN) 在前面讲到的DNN和CNN中，训练样本的输入和输出是比较的确定的。但是有一类问题DNN和CNN不好解决，就是训练样本输入是连续的序列,且序列的长短不一，比如基于时间的序列：一段段连续的语音，一段段连续的手写文字。这些序列比较长，且长度不一，比较难直接的拆分成一个个独立的样本来通过DNN/CNN进行训练。\n这时就需要RNN了。RNN是一类具有短期记忆能力的神经网络，RNN的模型如下：\n单一神经元的RNN 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class SingleLayerRNN(nn.Module): def __init__(self, inputSize, hiddenSize): super(SingleLayerRNN, self).__init__() # inputSize x hiddenSize : 4 x 1 self.Wx = torch.randn(inputSize, hiddenSize) # hiddenSize x hiddenSize : 1 x 1 self.Wy = torch.randn(hiddenSize, hiddenSize) self.b = torch.zeros(1, hiddenSize) # 1 xhiddenSize : 1 x 4 def forward(self, X0, X1): # batchSize x hiddenSize : 1 x 4 self.Y0 = torch.tanh(torch.mm(X0, self.Wx) + self.b) # batchSize x hiddenSize : 1 X 4 self.Y1 = torch.tanh(torch.mm(X1, self.Wx) + self.b + torch.mm(self.Y0, self.Wy)) return self.Y0, self.Y1 INPUT_SIZE = 4 HIDDEN_SIZE = 1 # t=0 =\u0026gt; batchSize x inputSize : 4 x 4 X0_batch = torch.tensor([[0, 1, 2, 0], [3, 4, 5, 0], [6, 7, 8, 0], [9, 0, 1, 0]], dtype=torch.float) # t=1 =\u0026gt; batchSize x inputSize : 4 x 4 X1_batch = torch.tensor([[9, 8, 7, 0], [0, 0, 0, 0], [6, 5, 4, 0], [3, 2, 1, 0]], dtype=torch.float) model = SingleLayerRNN(INPUT_SIZE, HIDDEN_SIZE) Y0_batch, Y1_batch = model(X0_batch, X1_batch) print(Y0_batch) print(Y1_batch) 使用RNN进行MNIST训练 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 import torch import torch.nn as nn import torchvision import torchvision.transforms as transforms import matplotlib.pyplot as plt import numpy as np import torch.optim as optim import os os.environ[\u0026#34;KMP_DUPLICATE_LIB_OK\u0026#34;]=\u0026#34;TRUE\u0026#34; BATCH_SIZE = 64 DOWNLOAD_DATASET = False # list all transformations transform = transforms.Compose([ transforms.Resize((28, 28)), transforms.ToTensor(), ]) # download and load training dataset trainDataset = torchvision.datasets.MNIST(root=\u0026#39;./MNIST/\u0026#39;, train=True, download=DOWNLOAD_DATASET, transform=transform) trainLoader = torch.utils.data.DataLoader(trainDataset, batch_size=BATCH_SIZE, shuffle=True) # download and load testing dataset testDataset = torchvision.datasets.MNIST(root=\u0026#39;./MNIST/\u0026#39;, train=False, download=DOWNLOAD_DATASET, transform=transform) testLoader = torch.utils.data.DataLoader(testDataset, batch_size=BATCH_SIZE, shuffle=False) # functions to show an image def imshow(img): # img = img / 2 + 0.5 # unnormalize npimg = img.numpy() plt.imshow(np.transpose(npimg, (1, 2, 0))) # get some random training images dataIter = iter(trainLoader) images, labels = dataIter.next() # show images imshow(torchvision.utils.make_grid(images)) # parameters INPUT_SIZE = 28 HIDDEN_SIZE = 150 OUTPUT_SIZE = 10 TIME_STEP = 28 MAX_EPOCH = 10 class ImageRNN(nn.Module): def __init__(self, batchSize, timeStep, inputSize, hiddenSize, outputSize): super(ImageRNN, self).__init__() self.hiddenSize = hiddenSize self.batchSize = batchSize self.timeStep = timeStep self.inputSize = inputSize self.outputSize = outputSize self.RNN = nn.RNN(self.inputSize, self.hiddenSize) self.fc = nn.Linear(self.hiddenSize, self.outputSize) def initializeHidden(self, ): # (num_layers, batch_size, hidden_size) return torch.zeros(1, self.batchSize, self.hiddenSize) def forward(self, X): # transforms X to dimensions: timeStep x batchSize x inputSize X = X.permute(1, 0, 2) self.batchSize = X.size(1) self.hidden = self.initializeHidden() # rnnOutput =\u0026gt; timeStep, batchSize, hiddenSize (hidden states for each time step) # self.hidden =\u0026gt; 1, batchSize, hiddenSize (final state from each rnnOutput) rnnOutput, self.hidden = self.RNN(X, self.hidden) out = self.fc(self.hidden) return out.view(-1, self.outputSize) # batchSize x outputSize dataIter = iter(trainLoader) images, labels = dataIter.next() model = ImageRNN(BATCH_SIZE, TIME_STEP, INPUT_SIZE, HIDDEN_SIZE, OUTPUT_SIZE) ypred = model(images.view(-1, 28, 28)) print(ypred[0:10]) # Device device = torch.device(\u0026#34;cuda:0\u0026#34; if torch.cuda.is_available() else \u0026#34;cpu\u0026#34;) # Model instance model = ImageRNN(BATCH_SIZE, TIME_STEP, INPUT_SIZE, HIDDEN_SIZE, OUTPUT_SIZE) criterion = nn.CrossEntropyLoss() optimizer = optim.Adam(model.parameters(), lr=0.001) def computeAccuracy(output, target): \u0026#39;\u0026#39;\u0026#39; Obtain accuracy for training round \u0026#39;\u0026#39;\u0026#39; corrects = (torch.max(output, 1)[1].view(target.size()).data == target.data).sum() accuracy = 100.0 * corrects / torch.numel(target) return accuracy.item() for epoch in range(MAX_EPOCH): # loop over the dataset multiple times trainLoss = 0.0 trainAccuracy = 0.0 model.train() # TRAINING ROUND for i, data in enumerate(trainLoader): # reset hidden states model.hidden = model.initializeHidden() # get the inputs inputs, labels = data inputs = inputs.view(-1, 28, 28) # forward ypred = model(inputs) loss = criterion(ypred, labels) # backward + optimize optimizer.zero_grad() loss.backward() optimizer.step() trainLoss += loss.detach().item() trainAccuracy += computeAccuracy(ypred, labels) model.eval() print(\u0026#39;Epoch: {:2d} | Loss: {:8.4f} | Train Accuracy: {:5.2f}\u0026#39;.format(epoch, trainLoss / i, trainAccuracy / i)) model.eval() testAccuracy = 0.0 for i, (images, labels) in enumerate(testLoader, 0): images = images.to(device) labels = labels.to(device) outputs = model(images.view(-1, 28, 28)) testAccuracy += computeAccuracy(outputs, labels) print(\u0026#39;Test Accuracy: {:6.2f}\u0026#39;.format(testAccuracy / len(testLoader))) 参考资料 卷积神经网络(CNN)模型结构 - 刘建平Pinard - 博客园 神经网络与深度学习 ","date":"2022-05-20T13:18:58+08:00","image":"https://lbqaq.top/p/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/98259515.webp","permalink":"https://lbqaq.top/p/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"特征工程学习笔记"},{"content":"线性回归 线性回归遇到的问题一般是这样的。我们有m个样本，每个样本对应于n维特征和一个结果输出，如下：\n$$ (x_1^{(0)}, x_2^{(0)}, \u0026hellip;x_n^{(0)}, y_0), (x_1^{(1)}, x_2^{(1)}, \u0026hellip;x_n^{(1)},y_1), \u0026hellip; (x_1^{(m)}, x_2^{(m)}, \u0026hellip;x_n^{(m)}, y_m) $$\n我们的问题是，对于一个新的$(x_1^{(x)}, x_2^{(x)}, \u0026hellip;x_n^{(x)})$, 他所对应的$y_x$是多少呢？ 如果这个问题里面的y是连续的，则是一个回归问题，否则是一个分类问题。\n对于n维特征的样本数据，如果我们决定使用线性回归，那么对应的模型是这样的：\n$h_\\theta(x_1, x_2, \u0026hellip;x_n) = \\theta_0 + \\theta_{1}x_1 + \u0026hellip; + \\theta_{n}x_{n}$, 其中$\\theta_i$ (i = 0,1,2\u0026hellip; n)为模型参数，$x_i$ (i = 0,1,2\u0026hellip; n)为每个样本的n个特征值。这个表示可以简化，我们增加一个特征$x_0 = 1$，这样$h_\\theta(x_0, x_1, \u0026hellip;x_n) = \\sum\\limits_{i=0}^{n}\\theta_{i}x_{i}$。\n💡 均方误差(MSE)\n$$ MSE=\\frac{1}{n}\\sum_{i=1}^{m}w_i(y_i-\\widehat{y_i})^2 $$\n其中$y_i$是真实数据，$\\widehat{y_i}$是拟合的数据，$w_i\u0026gt;0$\n得到了模型，我们需要求出需要的损失函数，一般线性回归我们用 均方误差(MSE) 作为损失函数。损失函数的代数法表示如下：\n$$ J(\\theta_0, \\theta_1\u0026hellip;, \\theta_n) = \\sum\\limits_{i=1}^{m}(h_\\theta(x_0^{(i)}, x_1^{(i)}, \u0026hellip;x_n^{(i)}) - y_i)^2 $$\n由于矩阵形式不好理解，这里就不列出了。\n如何求损失函数最小化时候的$\\mathbf{\\theta}$参数，这时就需要使用梯度下降法了。\n梯度下降法 梯度 在微积分里面，对多元函数的参数求∂偏导数，把求得的各个参数的偏导数以向量的形式写出来，就是梯度。那么这个梯度向量求出来有什么意义呢？他的意义从几何意义上讲，就是函数变化增加最快的地方。\n梯度下降的直观解释 首先来看看梯度下降的一个直观的解释。比如我们在一座大山上的某处位置，由于我们不知道怎么下山，于是决定走一步算一步，也就是在每走到一个位置的时候，求解当前位置的梯度，沿着梯度的负方向，也就是当前最陡峭的位置向下走一步，然后继续求解当前位置梯度，向这一步所在位置沿着最陡峭最易下山的位置走一步。这样一步步的走下去，一直走到觉得我们已经到了山脚。当然这样走下去，有可能我们不能走到山脚，而是到了某一个局部的山峰低处。\n从上面的解释可以看出，梯度下降不一定能够找到全局的最优解，有可能是一个局部最优解。当然，如果损失函数是凸函数，梯度下降法得到的解就一定是全局最优解。\n梯度下降法的代数方式描述 在上面的内容中，我们知道了线性回归的函数为：\n$$ h_\\theta(x_0, x_1, \u0026hellip;x_n) = \\sum\\limits_{i=0}^{n}\\theta_{i}x_{i} $$\n损失函数为：\n$$ J(\\theta_0, \\theta_1\u0026hellip;, \\theta_n) = \\sum\\limits_{i=1}^{m}(h_\\theta(x_0^{(i)}, x_1^{(i)}, \u0026hellip;x_n^{(i)}) - y_i)^2 $$\n算法相关参数初始化：主要是初始化$\\theta_0, \\theta_1\u0026hellip;, \\theta_n$ ,算法终止距离$\\varepsilon$ 以及步长$\\alpha$ 。在没有任何先验知识的时候，我喜欢将所有的$\\theta$ 初始化为0， 将步长初始化为1，在调优的时候再优化。\n算法过程：\n确定当前位置的损失函数的梯度，对于$\\theta_i$ ,其梯度表达式如下：\n$$ \\frac{\\partial}{\\partial\\theta_i}J(\\theta_0, \\theta_1\u0026hellip;, \\theta_n)= \\frac{1}{m}\\sum\\limits_{j=0}^{m}(h_\\theta(x_0^{(j)}, x_1^{(j)}, \u0026hellip;x_n^{(j)}) - y_j)x_i^{(j)} $$\n用步长乘以损失函数的梯度，得到当前位置下降的距离，即 $\\alpha\\frac{\\partial}{\\partial\\theta_i}J(\\theta_0, \\theta_1\u0026hellip;, \\theta_n)$ 对应于前面登山例子中的某一步。\n确定是否所有的 $\\theta_i$ ,梯度下降的距离都小于 $\\varepsilon$ ，如果小于 $\\varepsilon$ 则算法终止，当前所有的 $\\theta_i$ (i=0,1,\u0026hellip;n)即为最终结果。否则进入步骤4.\n更新所有的$\\theta$ ，对于 $\\theta_i$ ，其更新表达式如下。更新完毕后继续转入步骤1.\n$$ \\theta_i = \\theta_i - \\alpha\\frac{\\partial}{\\partial\\theta_i}J(\\theta_0, \\theta_1\u0026hellip;, \\theta_n) = \\theta_i - \\alpha (h_\\theta(x_0^{(j)}, x_1^{(j)}, \u0026hellip;x_n^{(j)}) - y_j)x_i^{(j)} $$\n从这个例子可以看出当前点的梯度方向是由所有的样本决定的，加 $\\frac{1}{m}$ 是为了好理解。由于步长也为常数，他们的乘机也为常数，所以这里 $\\alpha\\frac{1}{m}$ 可以用一个常数表示。\n在下面第4节会详细讲到的梯度下降法的变种，他们主要的区别就是对样本的采用方法不同。这里我们采用的是用所有样本。\n随机梯度下降法(SGD) 随机梯度下降法，其实和批量梯度下降法原理类似，区别在与求梯度时没有用所有的m个样本的数据，而是仅仅选取一个样本j来求梯度。对应的更新公式是\n$$ \\theta_i = \\theta_i - \\alpha (h_\\theta(x_0^{(j)}, x_1^{(j)}, \u0026hellip;x_n^{(j)}) - y_j)x_i^{(j)} $$\n随机梯度下降法，和批量梯度下降法是两个极端，一个采用所有数据来梯度下降，一个用一个样本来梯度下降。自然各自的优缺点都非常突出。对于训练速度来说，随机梯度下降法由于每次仅仅采用一个样本来迭代，训练速度很快，而批量梯度下降法在样本量很大的时候，训练速度不能让人满意。对于准确度来说，随机梯度下降法用于仅仅用一个样本决定梯度方向，导致解很有可能不是最优。对于收敛速度来说，由于随机梯度下降法一次迭代一个样本，导致迭代方向变化很大，不能很快的收敛到局部最优解。\n编程实现 网上找的代码，没验证，看个思路就行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function [ theta,J_history ] = StochasticGD( X, y, theta, alpha, num_iter ) m = length(y); J_history = zeros(20, 1); temp = 0; n = 0; for iter = 1:num_iter temp = temp + 1; index = randi(m); theta = theta -alpha * (X(index, :) * theta - y(index)) * X(index, :)\u0026#39;; if temp\u0026gt;=100 temp = 0; n = n + 1; J_history(n) = ComputeCost(X, y, theta); end end end 小批量梯度下降法(Mini-Batch SGD) 也就是对于m个样本，我们采用x个样子来迭代，1\u0026lt;x\u0026lt;m。一般可以取x=10，当然根据样本的数据，可以调整这个x的值。\n岭回归 助教妹说就是不考 反转了，居然要考\n在原先的线性回归的代价函数上加入了一个L2正则项，就是岭回归\n$$ J(\\theta_0, \\theta_1\u0026hellip;, \\theta_n) = \\sum\\limits_{i=1}^{m}(h_\\theta(x_0^{(i)}, x_1^{(i)}, \u0026hellip;x_n^{(i)}) - y_i)^2+\\lambda \\sum_{i=1}^m\\theta_i^2 $$\n非线性形式 助教妹说就是不考\n参考链接 梯度下降（Gradient Descent）小结 - 刘建平Pinard - 博客园 线性回归原理小结 - 刘建平Pinard - 博客园 ","date":"2022-05-20T12:50:16+08:00","image":"https://lbqaq.top/p/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/95446530.webp","permalink":"https://lbqaq.top/p/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"回归分析学习笔记"},{"content":"主成分分析(PCA) 基本思想 PCA顾名思义，就是找出数据里最主要的方面，用数据里最主要的方面来代替原始数据。具体的，假如我们的数据集是n维的，共有m个数据$(x^{(1)},x^{(2)},\u0026hellip;,x^{(m)})$。我们希望将这m个数据的维度从n维降到n\u0026rsquo;维，希望这m个n\u0026rsquo;维的数据集尽可能的代表原始数据集。\n通过计算数据矩阵的协方差矩阵，然后得到协方差矩阵的特征值特征向量，选择特征值最大(即方差最大)的k个特征所对应的特征向量组成的矩阵。这样就可以将数据矩阵转换到新的空间当中，实现数据特征的降维。\n由于得到协方差矩阵的特征值特征向量有两种方法：特征值分解协方差矩阵、奇异值分解协方差矩阵，所以PCA算法有两种实现方法：基于特征值分解协方差矩阵实现PCA算法、基于SVD分解协方差矩阵实现PCA算法。\n特征值分解(EVD) 特征值和特征向量的定义如下：\n$$ Ax=\\lambda x $$\n其中A是一个$n \\times n$的实对称矩阵，$x$是一个$n$维向量，则我们说$\\lambda$是矩阵A的一个特征值，而$x$是矩阵A的特征值$\\lambda$所对应的特征向量。\n求出特征值和特征向量有什么好处呢？ 就是我们可以将矩阵A特征分解。如果我们求出了矩阵A的$n$个特征值$\\lambda_1 \\leq \\lambda_2 \\leq \u0026hellip; \\leq \\lambda_n$,以及这$n$个特征值所对应的特征向量${q_1,q_2,\u0026hellip;q_n}$，如果这$n$个特征向量线性无关，那么矩阵A就可以用下式的特征分解表示：$A=Q\\Sigma Q^{-1}$ 。\n其中，Q是这个矩阵A的特征向量组成的矩阵，Σ是一个对角矩阵，每一个对角线元素就是一个特征值，里面的特征值是由大到小排列的，这些特征值所对应的特征向量就是描述这个矩阵变化方向（从主要的变化到次要的变化排列）。也就是说矩阵A的信息可以由其特征值和特征向量表示。\n注意到要进行特征分解，矩阵A必须为方阵。那么如果A不是方阵，即行和列不相同时，我们还可以对矩阵进行分解吗？答案是可以，此时我们的SVD登场了。\n奇异值分解(SVD) SVD也是对矩阵进行分解，但是和特征分解不同，SVD并不要求要分解的矩阵为方阵。假设我们的矩阵A是一个$m \\times n$的矩阵，那么我们定义矩阵A的SVD为：\n$$ A = U\\Sigma V^T $$\n其中U是一个$m \\times m$的矩阵，$\\Sigma$是一个$m \\times n$的矩阵，除了主对角线上的元素以外全为0，主对角线上的每个元素都称为奇异值，V是一个$n \\times n$的矩阵。\n计算方法：\n我们将A的转置和A做矩阵乘法，那么会得到$n \\times n$的一个方阵$A^TA$。对其进行特征值分解，得到n个特征值和对应的n个特征向量$v$了。将$A^TA$的所有特征向量张成一个$n \\times n$的矩阵V，就是我们SVD公式里面的V矩阵了。 对$AA^T$进行特征值分解，得到m个特征值和对应的m个特征向量$u$了。将$AA^T$的所有特征向量张成一个$m \\times m$的矩阵U，就是我们SVD公式里面的U矩阵了。一般我们将U中的每个特征向量叫做A的左奇异向量。 由于奇异值矩阵$\\Sigma$除了对角线上是奇异值其他位置都是0，那我们只需要求出每个奇异值$\\sigma$就可以了。求解奇异值可以用$\\sigma_i = Av_i / u_i$或$\\sigma_i = \\sqrt{\\lambda_i}$ 算法过程 输入：n维样本集$D=(x^{(1)}, x^{(2)},\u0026hellip;,x^{(m)})$，要降维到的维数n'.\n输出：降维后的样本集$D'$\n对所有的样本进行中心化： $x^{(i)} = x^{(i)} - \\frac{1}{m}\\sum\\limits_{j=1}^{m} x^{(j)}$ 计算样本的协方差矩阵$XX^T$ 对矩阵$XX^T$进行特征值分解 取出最大的n\u0026rsquo;个特征值对应的特征向量$(w_1,w_2,\u0026hellip;,w_{n\u0026rsquo;})$, 将所有的特征向量标准化后，组成特征向量矩阵W。 对样本集中的每一个样本$x^{(i)}$,转化为新的样本$z^{(i)}=W^Tx^{(i)}$ 得到输出样本集$D\u0026rsquo; =(z^{(1)}, z^{(2)},\u0026hellip;,z^{(m)})$ 上面是采用EVD，如果采用SVD，在第二第三步时就用SVD进行解决。\n编程实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 load fisheriris; X = meas; %% 中心化 meanX = ones(size(X,1), 1) * mean(X); centredX = X - meanX; % 直接调用cov直接计算协方差矩阵即可 C = cov(centredX); %% 特征值分解 [W, Lambda] = eig(C); % 提取特征值 ev = (diag(Lambda))\u0026#39;; % eig计算出的特征值是升序的，这里手动倒序（W同理） ev = ev(:, end:-1:1); W = W(:, end:-1:1); % 提取前两个主成分的特征向量 Wr = W(:, 1:2); % 新坐标空间的数据点 Tr = centredX * Wr; %% 作图 figure(1); scatter(Tr(:,1), Tr(:,2), 130, categorical(species), \u0026#39;.\u0026#39;); colormap(winter); xlabel(\u0026#39;Principal Component 1\u0026#39;); ylabel(\u0026#39;Principal Component 2\u0026#39;); %% SVD分解 % 可以检验，W和V完全相同（向量的正负号不影响） [U, Sigma, V] = svd(X); % 提取前两个主成分的特征向量 Vr = V(:, 1:2); % 新坐标空间的数据点 Tr = X * Vr; %% 作图 figure(2); scatter(Tr(:,1), Tr(:,2), 130, categorical(species), \u0026#39;.\u0026#39;); colormap(winter); xlabel(\u0026#39;Principal Component 1\u0026#39;); ylabel(\u0026#39;Principal Component 2\u0026#39;); MATLAB三维数据绘图 三维线 使用plot3()函数即可绘制三维线,输入应为三个向量\n1 2 3 4 5 6 7 8 turns = 40*pi; t = linspace(0,turns,4000); x = cos(t).*(turns-t)./turns; y = sin(t).*(turns-t)./turns; z = t./turns; plot3(x,y,z); grid on; axis square; 三维图形绘制及等高线 我们可以通过使用mesh()命令绘制三维面，使用contour()命令可以绘制三维图形的等高线。 与之前的命令一样，我们也可以通过向其传递不同的参数来改变图形的细节。\n1 2 3 4 5 6 7 8 9 10 x = -3.5:0.2:3.5; y = -3.5:0.2:3.5; [X,Y] = meshgrid(x,y); Z = 10.*X.*exp(-X.^2-Y.^2); grid on; axis square; subplot(1,2,1); mesh(X,Y,Z); subplot(1,2,2); contour(X,Y,Z,\u0026#39;ShowText\u0026#39;, \u0026#39;on\u0026#39;, \u0026#39;LevelStep\u0026#39;, 1); 三维图形绘制及等高线\n参考资料 主成分分析（PCA）原理详解 - 知乎 奇异值分解(SVD)原理与在降维中的应用 - 刘建平Pinard - 博客园 ","date":"2022-05-17T22:45:18+08:00","image":"https://lbqaq.top/p/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0/94861285.webp","permalink":"https://lbqaq.top/p/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0/","title":"数据可视化笔记"},{"content":"分类算法的作用 分类是在一群已经知道类别标号的样本中，训练一种分类器，让其能够对某种未知的样本进行分类。分类算法属于一种有监督的学习。分类算法的分类过程就是建立一种分类模型来描述预定的数据集或概念集，通过分析由属性描述的数据库元组来构造模型。分类的目的就是使用分类对新的数据集进行划分，其主要涉及分类规则的准确性、过拟合、矛盾划分的取舍等。\n有监督学习和无监督学习的区别 有监督学习是指数据集的正确输出已知情况下的一类学习算法。因为输入和输出已知，意味着输入和输出之间有一个关系，监督学习算法就是要发现和总结这种“关系”。 无监督学习是指对无标签数据的一类学习算法。因为没有标签信息，意味着需要从数据集中发现和总结模式或者结构。 简单来说，是否有监督（supervised），就看输入数据是否有标签（label） 交叉验证 基本思想 交叉验证的基本思想是把在某种意义下将原始数据(dataset)进行分组，一部分做为训练集(train set)，另一部分做为验证集(validation set or test set)，首先用训练集对分类器进行训练，再利用验证集来测试训练得到的模型(model)，以此来做为评价分类器的性能指标。用交叉验证的目的是为了得到可靠稳定的模型。\nK折交叉验证(K-fold cross-validation) K折交叉验证就是进行多次train_test_split划分；每次划分时，在不同的数据集上进行训练、测试评估，从而得出一个评价结果；如果是10折交叉验证，意思就是在原始数据集上，进行10次划分，每次划分进行一次训练、评估，最后得到10次划分后的评估结果，一般在这几次评估结果上取平均得到最后的评分。其中，k一般取5或10。\nK折交叉验证的步骤：\n将原始数据集划分为相等的K部分（“折”） 将第1部分作为测试集，其余作为训练集 训练模型，计算模型在测试集上的准确率 每次用不同的部分作为测试集，重复步骤2和3 K次 将平均准确率作为最终的模型准确率 💡 要会给定数据集进行K折交叉验证 要会计算模型准确率（每次的准确率、最终的准确率）\n支持向量机(SVM) 基本思想 SVM学习的基本思想是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。对于线性可分的数据集来说，这样的超平面有无穷多个（即感知机），但是几何间隔最大的分离超平面却是唯一的。\n用我自己的理解，就是找一条线将两个数据集分开，要保证这条线到两边的数据集距离最大。那么，如何才能保证距离最大呢，这就是下面要讨论的难点了。\n支持向量 在支持向量机中，距离超平面最近的且满足一定条件的几个训练样本点被称为支持向量。\n在上图中，处于虚线上的点（即红色的点）我们就将其定义为支持向量。那么，如何得到支持向量到超平面的距离呢？我们引入几何间隔的概念：\n$$ \\gamma = \\frac{y(w^Tx + b)}{||w||_2} = \\frac{\\gamma^{\u0026rsquo;}}{||w||_2} $$\n一般我们都取函数间隔$\\gamma^{\u0026rsquo;}$为1，这样我们就可以得到支持向量到超平面的距离为$\\frac{1}{||w||_2}$，两个支持向量之间的距离为$\\frac{2}{||w||_2}$\nSVM模型目标函数 SVM的模型是让所有点到超平面的距离大于一定的距离，也就是所有的分类点要在各自类别的支持向量两边。用数学式子表示为：\n$$ max \\;\\; \\frac{1}{||w||_2} \\;\\; s.t \\;\\; y_i(w^Tx_i + b) \\geq 1 (i =1,2,\u0026hellip;m) $$\n其中，$||w||_2$为向量$w$的L2范数，即：\n$$ ||w||_2=\\sqrt{w_1^2+w_2^2} $$\n为了去除根号方便计算，我们将原式转化为：\n$$ min \\;\\; \\frac{1}{2}||w||_2^2 \\;\\; s.t \\;\\; y_i(w^Tx_i + b) \\geq 1 (i =1,2,\u0026hellip;m) $$\n由于目标函数$\\frac{1}{2}||w||_2^2$是凸函数，同时约束条件不等式是仿射的，根据凸优化理论，我们可以通过拉格朗日函数将我们的优化目标转化为无约束的优化函数。于是根据拉格朗日乘子法，我们得到：\n$$ L(w,b,\\alpha) = \\frac{1}{2}||w||_2^2 - \\sum \\limits _{i=1}^{m} \\alpha_i [y_i(w^Tx_i + b) - 1] \\; 满足\\alpha_i \\geq 0 $$\n其中$\\alpha_i$为拉格朗日乘子。\nKKT条件 我们对上面的式子求偏导，可以得到\n$$ \\frac{\\partial L }{\\partial w}=0,\\frac{\\partial L }{\\partial b}=0 $$\n解得\n$$ \\boldsymbol{w}=\\sum_{i=1}^N{\\alpha_iy_i\\boldsymbol{x}_{\\boldsymbol{i}}} $$\n$$ \\sum_{i=1}^N{\\alpha_iy_i}=0 $$\n解方程可得\n$$ \\begin{cases} \\alpha_i\\geq 0 \\\\ y_i(\\overrightarrow{w_i}\\cdot \\overrightarrow{x_i}+b)-1\\geq 0 \\\\ \\alpha_i(y_i(\\overrightarrow{w_i}\\cdot\\overrightarrow{x_i}+b)-1)=0 \\end{cases} $$\n上面的式子即为KKT条件\nSVM对偶性 现在我们令\n$$ \\theta \\left( \\boldsymbol{w} \\right) =\\underset{\\alpha _{_i}\\ge 0}{\\max}\\ L\\left( \\boldsymbol{w,}b,\\boldsymbol{\\alpha } \\right) $$\n当样本点不满足约束条件时，即在可行解区域外$y_i\\left(\\boldsymbol{w}\\cdot \\boldsymbol{x}_{\\boldsymbol{i}}+b\\right)\u0026lt;1$。此时，将$\\alpha_i$设置为无穷大，则$\\theta \\left( \\boldsymbol{w} \\right)$也为无穷大。\n当样本点不满足约束条件时，即在可行解区域内$y_i\\left(\\boldsymbol{w}\\cdot \\boldsymbol{x}_{\\boldsymbol{i}}+b\\right)\\ge1$。此时，$\\theta \\left( \\boldsymbol{w} \\right)$为原函数本身。\n于是，将两种情况合并起来就可以得到我们新的目标函数：\n$$ \\theta \\left( \\boldsymbol{w} \\right) =\\begin{cases} \\frac{1}{2}\\lVert \\boldsymbol{w} \\rVert ^2\\ ,\\boldsymbol{x}\\in \\text{可行区域}\\\\ +\\infty \\ \\ \\ \\ \\ ,\\boldsymbol{x}\\in \\text{不可行区域}\\\\ \\end{cases} $$\n于是原约束问题就等价于：\n$$ \\underset{\\boldsymbol{w,}b}{\\min}\\ \\theta \\left( \\boldsymbol{w} \\right) =\\underset{\\boldsymbol{w,}b}{\\min}\\underset{\\alpha _i\\ge 0}{\\max}\\ L\\left( \\boldsymbol{w,}b,\\boldsymbol{\\alpha } \\right) $$\n由上小节，我们可以知道该函数满足拉格朗日函数对偶性：\n优化问题是凸优化问题 满足KKT条件 于是，我们可以将其最小和最大的位置交换一下，这样就变成了：\n$$ \\underset{\\alpha _i\\ge 0}{\\max}\\underset{\\boldsymbol{w,}b}{\\min}\\ L\\left( \\boldsymbol{w,}b,\\boldsymbol{\\alpha } \\right) $$\n从上式中，我们可以先求优化函数对于$w$和$b$的极小值。接着再求拉格朗日乘子$\\alpha$的极大值。\n通过在上节中由偏导推出的两个式子，我们得到了$w$和$\\alpha$的关系，就可以带入优化函数$L(w,b,\\alpha)$消去$w$了\n此时原式为\n我们对目标式子加一个负号，将求解极大转换为求解极小\nSVM核（Kernel）方法 基本概念 在上节我们推导出的式子中，我们可以看到上式低维特征仅仅以内积$x_i \\bullet x_j$ 的形式出现，如果我们定义一个低维特征空间到高维特征空间的映射$T$，将所有特征映射到一个更高的维度，让数据线性可分，我们就可以求出分离超平面和分类决策函数了。\n但是，将数据从低维映射到高维，将会大大增加计算的复杂度，如果遇到无穷维的情况，就根本无从计算了。这时，就需要引入核函数了。\n我们定义果存在函数$K(x,z)$，对于任意$x, z$ ，都有：\n$$ K(x, z) = T(x) \\bullet T(z) $$\n那么我们就称$K(x, z)$为核函数。\n通过核函数，就避免了在刚才我们提到了在高维维度空间计算内积的恐怖计算量。也就是说，我们可以好好享受在高维特征空间线性可分的红利，却避免了高维特征空间恐怖的内积计算量。\n下面我们来看看常见的核函数, 选择这几个核函数介绍是因为scikit-learn中默认可选的就是下面几个核函数。\n线性核函数（Linear Kernel） 其实就是线性可分SVM，表达式为：\n$$ K(x, z) = x \\bullet z $$\n也就是说，线性可分SVM我们可以和线性不可分SVM归为一类，区别仅仅在于线性可分SVM用的是线性核函数。\n多项式核函数（Polynomial Kernel） 多项式核函数是线性不可分SVM常用的核函数之一，表达式为：\n$$ K(x, z) = （\\gamma x \\bullet z + r)^d $$\n其中，$\\gamma, r,d$都需要自己调参定义。\n高斯核函数（Gaussian Kernel） 在SVM中也称为径向基核函数（Radial Basis Function,RBF），它是非线性分类SVM最主流的核函数。libsvm默认的核函数就是它。表达式为：\n$$ K(x, z) = exp(-\\gamma||x-z||^2) $$\n其中，$\\gamma$大于0，需要自己调参定义。\n💡 高斯核函数很重要，一定要记住\nSigmoid核函数 也是线性不可分SVM常用的核函数之一，表达式为：\n$$ K(x, z) = tanh（\\gamma x \\bullet z + r) $$\n其中，$\\gamma, r$都需要自己调参定义。\nSVM软间隔 有时候本来数据的确是可分的，也就是说可以用 线性分类SVM的学习方法来求解，但是却因为混入了异常点，导致不能线性可分，比如下图\n这种情况下，SVM引入了软间隔最大化的方法来解决。\nSVM对训练集里面的每个样本$(x_i,y_i)$引入了一个松弛变量$\\xi_i \\geq 0$,使函数间隔加上松弛变量大于等于1，也就是说：\n$$ y_i(w\\bullet x_i +b) \\geq 1- \\xi_i $$\n对比硬间隔最大化，可以看到我们对样本到超平面的函数距离的要求放松了，之前是一定要大于等于1，现在只需要加上一个大于等于0的松弛变量能大于等于1就可以了。当然，松弛变量不能白加，这是有成本的，每一个松弛变量$\\xi_i$, 对应了一个代价$\\xi_i$，这个就得到了我们的软间隔最大化的SVM学习条件如下：\n$$ min\\;\\; \\frac{1}{2}||w||_2^2 +C\\sum\\limits{i=1}^{m}\\xi_i $$\n$$ s.t. \\;\\; y_i(w^Tx_i + b) \\geq 1 - \\xi_i \\;\\;(i =1,2,\u0026hellip;m) $$\n$$ \\xi_i \\geq 0 \\;\\;(i =1,2,\u0026hellip;m) $$\n这里，$C\u0026gt;0$为惩罚参数，可以理解为我们一般回归和分类问题正则化时候的参数。$C$越大，对误分类的惩罚越大，$C$越小，对误分类的惩罚越小。\n也就是说，我们希望$\\frac{1}{2}||w||_2^2$尽量小，误分类的点尽可能的少。C是协调两者关系的正则化惩罚系数。在实际应用中，需要调参来选择。\nSVM编程实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 %% 生成测试数据 classCount= 2; p= 100; bound =[0 10]; data =[... [2,2]+ randn(p,2),-1*ones(p,1);... [6,6]+ randn(p,2),+1*ones(p,1);... ]; X= data(:,1:end-1); Y = data(:,end); %% 显示生成的测试数据 figure(1) clf; gscatter(X(:,1), X(:,2), Y, \u0026#39;rb\u0026#39;, \u0026#39;X+\u0026#39;); legend({\u0026#39;分类-1\u0026#39;, \u0026#39;分类+1\u0026#39;}); title(\u0026#34;原始数据散点图\u0026#34;); xlim(bound); ylim(bound); %% 拆分训练集和测试集 trainIndex = (mod(1:size(X,1),3)==1); testIndex = ~trainIndex; Xtrain=X(trainIndex,:); Ytrain=Y(trainIndex,:); Xtest=X(testIndex,:); Ytest=Y(testIndex,:); %% 将拆分的结果展示 figure(2) clf; hold on; gscatter(Xtrain(:,1),Xtrain(:,2),Ytrain,\u0026#39;rb\u0026#39;,\u0026#39;X+\u0026#39;); scatter(Xtest(:,1),Xtest(:,2),\u0026#39;k.\u0026#39;); hold off; legend({\u0026#39;分类-1\u0026#39;,\u0026#39;分类+1\u0026#39;,\u0026#39;测试数据\u0026#39;}); title(\u0026#34;划分测试数据后的散点图\u0026#34;); xlim(bound); ylim(bound); %% 使用SVM进行训练 svm=fitcsvm(Xtrain,Ytrain); %% 展示SVM训练的结果 figure(3) clf; gscatter(Xtrain(:,1), Xtrain(:, 2), Ytrain, \u0026#39;rb\u0026#39;, \u0026#39;X+\u0026#39;); hold on; gscatter(svm.SupportVectors(:,1), svm.SupportVectors(:,2),svm.SupportVectorLabels,\u0026#39;rb\u0026#39;,\u0026#39;oo\u0026#39;,13); xg = bound; yg = [-svm.Bias/svm.Beta(2) -svm.Beta(1)/svm.Beta(2) * bound(2)-svm.Bias/svm.Beta(2)]; plot(xg, yg, \u0026#39;g\u0026#39;, \u0026#39;Linewidth\u0026#39;, 2); delta = -svm.Beta(1)/svm.Beta(2)*svm.SupportVectors(1,1)-svm.SupportVectors(1,2)-svm.Bias/svm.Beta(2); plot(xg, yg-delta, \u0026#39;--g\u0026#39;, \u0026#39;LineWidth\u0026#39;, 2); plot(xg, yg+delta, \u0026#39;--g\u0026#39;, \u0026#39;LineWidth\u0026#39;, 2); hold off; xlim(bound); ylim(bound); legend({\u0026#39;分类-1\u0026#39;, \u0026#39;分类+1\u0026#39;, \u0026#39;支持向量-1\u0026#39;, \u0026#39;支持向量+1\u0026#39;, \u0026#39;超平面\u0026#39;, \u0026#39;超平面-1\u0026#39;, \u0026#39;超平面+1\u0026#39;}); title(\u0026#34;SVM训练后的散点图\u0026#34;); %% 使用训练好的模型进行预测 Ypred = predict(svm, Xtest); %% 绘制预测后的结果 figure(4) clf; gscatter(Xtest(:,1), Xtest(:, 2), Ypred, \u0026#39;rb\u0026#39;, \u0026#39;X+\u0026#39;); hold on; g = gscatter(svm.SupportVectors(:,1), svm.SupportVectors(:,2), svm.SupportVectorLabels, \u0026#39;rb\u0026#39;,\u0026#39;oo\u0026#39;,13); plot(xg, yg, \u0026#39;g\u0026#39;, \u0026#39;Linewidth\u0026#39;, 2); plot(xg, yg-delta, \u0026#39;--g\u0026#39;, \u0026#39;Linewidth\u0026#39;, 2); plot(xg, yg+delta, \u0026#39;--g\u0026#39;, \u0026#39;Linewidth\u0026#39;, 2); hold off; xlim(bound); ylim(bound); legend({\u0026#39;分类-1\u0026#39;, \u0026#39;分类+1\u0026#39;, \u0026#39;支持向量-1\u0026#39;, \u0026#39;支持向量+1\u0026#39;, \u0026#39;超平面\u0026#39;, \u0026#39;超平面-1\u0026#39;, \u0026#39;超平面+1\u0026#39;}); title(\u0026#34;SVM预测后的散点图\u0026#34;); %% 计算误差 fprintf(\u0026#39;正确率为：%.2f%%\\n\u0026#39;,(sum(Ypred==Ytest)/numel(Ytest)).*100); SVM实现多分类 SVM算法最初是为二值分类问题设计的，当处理多类问题时，就需要构造合适的多类分类器。\n目前，构造SVM多类分类器的方法主要有两类：\n（1）直接法，直接在目标函数上进行修改，将多个分类面的参数求解合并到一个最优化问题中，通过求解该最优化问题“一次性”实现多类分类。这种方法看似简单，但其计算复杂度比较高，实现起来比较困难，只适合用于小型问题中；\n（2）间接法，主要是通过组合多个二分类器来实现多分类器的构造，常见的方法有one-against-one和one-against-all两种。\n一对多法（OVR） 训练时依次把某个类别的样本归为一类,其他剩余的样本归为另一类，这样k个类别的样本就构造出了k个SVM。分类时将未知样本分类为具有最大分类函数值的那类。\n假如我有四类要划分（也就是4个Label），他们是A、B、C、D。\n于是我在抽取训练集的时候，分别抽取\nA所对应的向量作为正集，B，C，D所对应的向量作为负集； B所对应的向量作为正集，A，C，D所对应的向量作为负集； C所对应的向量作为正集，A，B，D所对应的向量作为负集； D所对应的向量作为正集，A，B，C所对应的向量作为负集； 使用这四个训练集分别进行训练，然后的得到四个训练结果文件。在测试的时候，把对应的测试向量分别利用这四个训练结果文件进行测试。最后每个测试都有一个结果f1(x),f2(x),f3(x),f4(x)。\n于是最终的结果便是这四个值中最大的一个作为分类结果。\n一对一法（OVO） 一般都是用一对多法，这里就不展开了，知道有这个东西就行。\n参考资料 支持向量机（SVM）——原理篇 - 知乎 支持向量机原理(一) 线性支持向量机 - 刘建平Pinard - 博客园 等同系列文章 【数之道25】机器学习必经之路-SVM支持向量机的数学精华_哔哩哔哩_bilibili 等同系列视频 ","date":"2022-05-10T14:00:16+08:00","image":"https://lbqaq.top/p/%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/86368113.webp","permalink":"https://lbqaq.top/p/%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"分类算法学习笔记"},{"content":"Kmeans 算法步骤 从样本中选择 K 个点作为初始质心（完全随机） 计算每个样本到各个质心的距离，将样本划分到距离最近的质心所对应的簇中 计算每个簇内所有样本的均值，并使用该均值更新簇的质心 重复步骤 2 与 3 ，直到达到以下条件之一： 质心的位置变化小于指定的阈值（默认为 0.0001） 达到最大迭代次数 欧氏距离 衡量的是多维空间中两个点之间的绝对距离\n在二维和三维空间中的欧氏距离就是两点之间的实际距离\n计算方法：对应坐标值相减的平方和再开方\n$$ dist(X,Y)=\\sqrt{\\sum_{i=1}^{n}(x_i-y_i)^2} $$\n对于二维来说，就是\n$$ dist(X,Y)=\\sqrt{(x_1-y_1)^2+(x_2-y_2)^2} $$\n注意理解输入？输出？类别中心？迭代过程中做什么？\n编程实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 %% 生成测试数据 clear p=100; % 每簇的样本数 sigma = [0.1 0;0 0.1]; % 协方差矩阵 R = chol(sigma); % 生成测试数据集 data=[... [0 0] + randn(p,2)*R,1*ones(p,1);... [0 2] + randn(p,2)*R,2*ones(p,1);... [2 0] + randn(p,2)*R,3*ones(p,1);... [2 2] + randn(p,2)*R,4*ones(p,1);... ]; %% 绘制样本散点图 figure(1) scatter(data(:,1),data(:,2),\u0026#39;r.\u0026#39;) title(\u0026#34;无样式样本散点图\u0026#34;) X=data(:,1:end-1); g=data(:,end); n=size(X,1); %% K-means实现 k=4; % 指定分成的簇数 %从n个数据样本中不重复地随机选择k个样本作为质 centerIndex = randperm(n, k); C = X(centerIndex, :); result = struct(\u0026#39;y\u0026#39;,[],\u0026#39;C\u0026#39;,[],\u0026#39;objectives\u0026#39;,[]); iter = 0; maxIter = 10; % 指定最大迭代的次数 while (iter \u0026lt; maxIter) iter = iter + 1; % 求出每个样本到中心点的距离，按照距离自身最近的中心点进行聚类 D = pdist2(X, C); [d, ypred] = min(D, [], 2); % 保存结果 result(iter).y = ypred; result(iter).C = C; result(iter).objectives = sum(d.*d); % 当距离没变时结束迭代 if(iter \u0026gt; 1 \u0026amp;\u0026amp; result(iter).objectives == result(iter-1).objectives) break; end % 依据上次聚类结果，求出新的中心点 for cid = 1: size(C,1) C(cid, :) = mean (X(ypred == cid, :)); end end %% 绘制结果散点图 figure(2); for t = 1: numel(result) figure(2); clf % 绘制聚类结果 gscatter(X(:,1), X(:,2), result(t).y,\u0026#39;rgbm\u0026#39;); hold on; Ct = result(t).C; % 绘制聚类中心 h=gscatter(Ct(:,1), Ct(:,2), (1: size(Ct,1)), \u0026#39;kkkk\u0026#39;, \u0026#39;x+od\u0026#39;, 10); title(\u0026#34;第\u0026#34;+t+\u0026#34;次迭代后散点图\u0026#34;) set(h,\u0026#39;LineWidth\u0026#39;, 2.0); waitforbuttonpress; %pause(1); end %% 计算误差 % 输出混淆矩阵 confusionmat(g,ypred) 缺点 容易受初始质心的影响；算法聚类时，容易产生空簇；算法可能收敛到局部最小值。\n解决办法：重新执行K-means算法，重新分配质心\n谱聚类(Spectral Clustering) 算法思想 把所有的数据看做空间中的点，这些点之间可以用边连接起来。距离较远的两个点之间的边权重值较低，而距离较近的两个点之间的边权重值较高，通过对所有数据点组成的图进行切图，让切图后不同的子图间边权重和尽可能的低，而子图内的边权重和尽可能的高，从而达到聚类的目的。\n度矩阵D 对于一个图$G$，我们一般用点的集合$V$和边的集合$E$来描述。即为$G(V,E)$。其中$V$即为我们数据集里面所有的点$(v_1, v_2,\u0026hellip;v_n)$。对于$V$中的任意两个点，可以有边连接，也可以没有边连接。我们定义权重$w_{ij}$为点$v_i$和点$v_j$之间的权重。由于我们是无向图，所以$w_{ij} = w_{ji}$。\n对于有边连接的两个点$v_i$和$v_j$，$w_{ij} \u0026gt; 0$,对于没有边连接的两个点$v_i$和$v_j$，$w_{ij} = 0$。对于图中的任意一个点$v_i$，它的度$d_i$定义为和它相连的所有边的权重之和，即\n$$ d_i = \\sum\\limits_{j=1}^{n}w_{ij} $$\n利用每个点度的定义，我们可以得到一个nxn的度矩阵$D$,它是一个对角矩阵，只有主对角线有值，对应第i行的第i个点的度数，定义如下：\n$$ \\mathbf{D} = \\left( \\begin{array}{ccc} d_1 \u0026amp; \\ldots \u0026amp; \\ldots \\\\ \\ldots \u0026amp; d_2 \u0026amp; \\ldots \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \\\\ \\ldots \u0026amp; \\ldots \u0026amp; d_n \\end{array} \\right) $$\n利用所有点之间的权重值，我们可以得到图的邻接矩阵$W$，它也是一个nxn的矩阵，第i行的第j个值对应我们的权重$w_{ij}$。\n除此之外，对于点集$V$的的一个子集$A \\subset V$，我们定义：\n$$ |A|: = 子集A中点的个数 $$\n$$ vol(A): = \\sum\\limits_{i \\in A}d_i $$\n相似矩阵 构建邻接矩阵$W$的方法有三类：\n$\\epsilon$-邻近法\n它设置了一个距离阈值$\\epsilon$，然后用欧式距离$s_{ij}$度量任意两点$x_i$和$x_j$的距离。 然后根据$s_{ij}$和$\\epsilon$的大小关系，来定义邻接矩阵$W$。距离小于$\\epsilon$为$\\epsilon$，距离大于$\\epsilon$为0\nK邻近法\n利用KNN算法遍历所有的样本点，取每个样本最近的k个点作为近邻，只有和样本距离最近的k个点之间的$w_{ij} \u0026gt; 0$。但是这种方法会造成重构之后的邻接矩阵W非对称。\n全连接法（最常用）\n相比前两种方法，第三种方法所有的点之间的权重值都大于0，因此称之为全连接法。可以选择不同的核函数来定义边权重，常用的有多项式核函数，高斯核函数和Sigmoid核函数，最常用的是高斯核函数RBF。\n$$ w_{ij}=s_{ij}=exp(-\\frac{||x_i-x_j||_2^2}{2\\sigma^2}) $$\n💡 exp(x)表示$e^x$\n拉普拉斯矩阵 拉普拉斯矩阵$L= D-W$\n$D$即为度矩阵，它是一个对角矩阵。$W$为邻接矩阵。\n无向图切图 对于无向图$G$的切图，我们的目标是将图$G(V,E)$切成相互没有连接的k个子图，每个子图点的集合为：$A_1,A_2,..A_k$，它们满足$A_i \\cap A_j = \\emptyset$,且$A_1 \\cup A_2 \\cup \u0026hellip; \\cup A_k = V$.\n对于任意两个子图点的集合$A, B \\subset V$, $A \\cap B = \\emptyset$, 我们定义A和B之间的切图权重为：\n$$ W(A, B) = \\sum\\limits_{i \\in A, j \\in B}w_{ij} $$\n最小化切图\n$$ \\min cut(A,B)=\\sum\\limits_{i \\in A, j \\in B}w_{ij} $$\nRatioCut切图\n$$ RatioCut(A,B)=cut(A,B)(\\frac{1}{|A|}+\\frac{1}{|B|}) $$\nNcut切图\n$$ Ncut(A,B)=cut(A,B)(\\frac{1}{vol(A)}+\\frac{1}{vol(B)}) $$\n算法流程 最常用的相似矩阵的生成方式是基于高斯核距离的全连接方式，最常用的切图方式是Ncut。而到最后常用的聚类方法为K-Means。\n输入：样本集D=$(x_1,x_2,\u0026hellip;,x_n)$，相似矩阵的生成方式, 降维后的维度$k_1$, 聚类方法，聚类后的维度$k_2$\n输出： 簇划分$C(c_1,c_2,\u0026hellip;c_{k_2})$.\n根据输入的相似矩阵的生成方式构建样本的相似矩阵S 根据相似矩阵S构建邻接矩阵W，构建度矩阵D 计算出拉普拉斯矩阵L 构建标准化后的拉普拉斯矩阵$D^{-1/2}LD^{-1/2}$ 计算$D^{-1/2}LD^{-1/2}$最小的$k_1$个特征值所各自对应的特征向量$f$ 将各自对应的特征向量$f$组成的矩阵按行标准化，最终组成$n \\times k_1$维的特征矩阵F 对F中的每一行作为一个$k_1$维的样本，共n个样本，用输入的聚类方法进行聚类，聚类维数为$k_2$ 得到簇划分$C(c_1,c_2,\u0026hellip;c_{k_2})$ 编程实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 rng(\u0026#39;default\u0026#39;) %% 生成测试数据 p= 200; theta = linspace(0,2*pi,p)\u0026#39;; data =[... 2*[cos(theta) sin(theta)]+ rand(p,1),1*ones(p,1); 4*[cos(theta) sin(theta)]+ rand(p,1),2*ones(p,1); ]; X = data(:,1:end-1); y = data(:,end); gscatter(X(:,1),X(:,2),y,\u0026#39;rg\u0026#39;); %% 距离矩阵 Q = pdist2(X, X); imagesc(Q); colorbar; %% 构造图的相似度矩阵A sigma = 0.1; A = exp(-Q.*Q / (2*sigma*sigma)); imagesc(A); colorbar; %% 构造图的拉普拉斯矩阵L D = diag(sum(A,2)); L = D - A; imagesc(L); colorbar; %% 对拉普拉斯矩阵进行特征值分解 [V,S] = eig(L); s = diag(S); plot(s); %% 取最小的k个特征值对应的特征向量 k = 2; Vr = V(:,1:k); Vr([1:2, end-1:end],:) %% 对映射后的特征矩阵Vr进行kmeans聚类 idx = kmeans(Vr,k); gscatter(X(:,1),X(:,2),idx,\u0026#39;rg\u0026#39;); title([\u0026#39;谱聚类 \\sigma = \u0026#39;,num2str(sigma)]) 简化考试专用代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 % 数据为X,y %% 距离矩阵 Q = pdist2(X, X); %% 构造图的相似度矩阵A sigma = 0.1; A = exp(-Q.*Q / (2*sigma*sigma)); %% 构造图的拉普拉斯矩阵L D = diag(sum(A,2)); L = D - A; %% 对拉普拉斯矩阵进行特征值分解 [V,S] = eig(L); %% 取最小的k个特征值对应的特征向量 k = 2; Vr = V(:,1:k); %% 对映射后的特征矩阵Vr进行kmeans聚类 idx = kmeans(Vr,k); gscatter(X(:,1),X(:,2),idx,\u0026#39;rg\u0026#39;); title([\u0026#39;谱聚类 \\sigma = \u0026#39;,num2str(sigma)]) 参考文档 K-Means(K均值聚类算法) - 知乎 谱聚类（spectral clustering）原理总结 - 刘建平Pinard - 博客园 ","date":"2022-05-10T08:23:41+08:00","image":"https://lbqaq.top/p/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/97701948.webp","permalink":"https://lbqaq.top/p/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"聚类算法学习笔记"},{"content":"打了两次力扣的周赛，都败在了第三题上，而且都是二分查找的题目。这下不能忍了，必须来总结一波。\n第一次二分查找 二分查找是用来在一个有序数组中查找某一元素的算法。它的工作原理如下：\n它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需到右侧查找；如果中间元素大于所查找的值同理，只需到左侧查找。\n使用二分查找就能将原先$\\Omicron(n)$时间复杂度的线性查找降低为$\\Omicron(\\log(n))$。但是一定要注意，二分查找一定要在有序的数组上进行。\n下面放上模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int binary_search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0, right = nums.size() - 1; int ret = -1; // 未搜索到数据返回-1下标 int mid; while (left \u0026lt;= right) { mid = left + ((right - left) \u0026gt;\u0026gt; 1); // 直接平均可能会溢出，所以用这个算法 if (nums[mid] \u0026lt; target) left = mid + 1; else if (nums[mid] \u0026gt; target) right = mid - 1; else { // 最后检测相等是因为多数搜索情况不是大于就是小于 ret = mid; break; } } return ret; // 单一出口 } 在上面的代码中，我们每次搜索的是[left,right]这个闭区间，所以在while中要使用\u0026lt;=。\n但是，这样的算法还是存在一些缺陷。比如对于条件nums = [1,2,2,2,3],target=2，使用上面的算法返回的下标是2。虽然答案是正确的，但我们想要得到target的左侧边界或右侧边界就不能使用上面的算法了。虽然可以先查出结果再向左或右线性搜索，但这样时间复杂度就被提高了。\n寻找左侧边界的二分查找 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int left_bound(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { if (nums.size() == 0) return -1; int left = 0; int right = nums.size(); // 注意 while (left \u0026lt; right) { // 注意 int mid = (left + right) / 2; if (nums[mid] == target) { right = mid; } else if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid; // 注意 } } // target 比所有数都大 if (left == nums.size()) return -1; // 未查到目标值 return nums[left] == target ? left : -1; } 在这里我们搜索的区间变成了左闭右开[left,right)，所以在while中使用\u0026lt;。\n由于搜索区间变为[left,right)，所以当 nums[mid]被检测之后，下一步的搜索区间应该去掉 mid分割成两个区间，即 [left, mid)或 [mid + 1, right)。在代码中体现为left = mid + 1;和right = mid;\n那么，这个模板为什么能找到左边界呢？关键在于nums[mid] == target这种情况的处理：\nright = mid;\n我们找到 target 时没有立即返回，而是缩小「搜索区间」的上界 right，在区间 [left, mid)中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。\n寻找右侧边界的二分查找 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int right_bound(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { if (nums.size() == 0) return -1; int left = 0, right = nums.size(); while (left \u0026lt; right) { int mid = (left + right) / 2; if (nums[mid] == target) { left = mid + 1; // 注意 } else if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid; } } if (left == 0) return -1; return nums[left - 1] == target ? (left - 1) : -1; // 注意要-1 } 由于我们对 left的更新必须是 left = mid + 1，这就导致了 while 循环结束时，nums[left]一定不等于 target了，而 nums[left-1]可能是 targe。所以我们在返回结果时要进行-1操作。\n第二次二分查找 虽说上面的模板已经够好了，但是有些题目并不是只考一个二分，如果照着敲一遍模板还是比较费时的。这是就不得不祭出\u0026lt;algorithm\u0026gt;里的两个内置函数了：\nlower_bound 返回指向范围 [first, last) 中首个不小于（即大于或等于） value 的元素的迭代器，或若找不到这种元素则返回 last 。\n仔细考虑一下，就会发现这就是上面提到的寻找左侧边界的二分查找，一下就把原来那么长的代码变成了一行，太香了。（但是上面的模板还是要掌握，有些题目是无法调库）\n使用举例：\n1 2 3 4 5 6 int main() { vector\u0026lt;int\u0026gt; nums = {1, 1, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6}; auto lower = lower_bound(nums.begin(), nums.end(), 3); cout \u0026lt;\u0026lt; lower - nums.begin() \u0026lt;\u0026lt; endl; //3 return 0; } 一个小细节，lower_bound返回的是迭代器，所以lower的真实类型是vector\u0026lt;int\u0026gt;::iterator，太长了所以我们用的时候还是使用auto让编译器来补全QuQ。\nupper_bound 返回指向范围 [first, last) 中首个大于 value 的元素的迭代器，或若找不到这种元素则返回 last 。\n其实就是上面寻找右侧边界的二分查找，只不过我们进行了-1操作而该函数没有而已。\n使用举例：\n1 2 3 4 5 6 int main() { vector\u0026lt;int\u0026gt; nums = {1, 1, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6}; auto upper = upper_bound(nums.begin(), nums.end(), 3); cout \u0026lt;\u0026lt; upper - nums.begin() \u0026lt;\u0026lt; endl; //7 return 0; } 终极二分查找 上面的都是对一个数组进行二分查找，我们也可以把思路放开一点，对答案进行二分查找。我们都知道暴力法就是枚举答案然后检验枚举的值是否正确，当答案满足单调性时，我们就可以将枚举换为二分，这样能大大降低时间复杂度。\n放两道例题，就是引言里我说的周赛题\n2187. 完成旅途的最少时间 - 力扣（LeetCode） 5219. 每个小孩最多能分到多少糖果 - 力扣（LeetCode） 参考资料 二分 - OI Wiki 二分查找细节详解，顺便赋诗一首 - 二分查找 - 力扣（LeetCode） ","date":"2022-04-04T22:54:54+08:00","image":"https://lbqaq.top/p/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%98%AF%E4%B8%AA%E5%95%A5%E5%95%8A/89247070.webp","permalink":"https://lbqaq.top/p/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%98%AF%E4%B8%AA%E5%95%A5%E5%95%8A/","title":"二分查找是个啥啊"},{"content":"进制转换 在数学中，不止只有我们常见的10进制，最近刷了几道关于进制转换的题目，在这里做个总结和记录吧。\n基本概念 首先我们要先了解进制的基本概念，这里我直接从LeetCode官方这里引用了。\n任何一种进位计数制都有一个基数，基数为 X 的进位计数制称为 X 进制，表示每一个数位上的数运算时都是逢 X 进一。\n对于一个 X 进制的数，其具体数值由其中的每个数码和数码所在的数位决定。整数部分从右往左的第 m 个数位表示的权重是 $X^m$，其中 m 最小为 0；小数部分从左往右的第 n 个数位表示的权重是$X^{-n}$，其中 n 最小为 1。\n八进制的 $720.5$ 可以写成如下形式：\n$720.5_{(8)} = 7 \\times 8^2 + 2 \\times 8^1 + 0 \\times 8^0 + 5 \\times 8^{-1}$\n用我自己的话来说，就是数值*权重\n进制转换的一般思路 一般来说，我们习惯将进制转换成十进制，这样便于理解和手算。当然，我们也可以不通过十进制作为中间态过度，比如我们熟悉的二进制和十六进制的转换。\n非十进制转十进制 将非十进制数转成十进制数，只要将每个数位的加权和即可。\n例如，将八进制数 $720.5_{(8)}$ 转成十进制：\n$720.5_{(8)} = 7 \\times 8^2 + 2 \\times 8^1 + 0 \\times 8^0 + 5 \\times 8^{-1} = 464.625$\n下面是程序的实现(只考虑整数)，我们可以从高位到低位进行读取，按照下面的方式读入,其中n表示是几进制数\n1 2 3 4 5 6 7 8 9 10 11 int read() { char c = getchar(); int k = 0; while (isint(c) == -1) c = getchar(); while (isint(c) != -1) { k *= n; k += isint(c); c = getchar(); } return k; } 十进制转非十进制 首先我们先来看手算，将十进制数转成 X 进制数，需要对整数部分和小数部分分别转换。\n对于整数部分，转换方式是将十进制数的整数部分每次除以 X 直到变成 0，并记录每次的余数，反向遍历每次的余数即可得到 X 进制表示。\n对于小数部分，转换方式是将十进制数的小数部分每次乘以 X 直到变成 0，并记录每次的整数部分，正序遍历每次的整数部分即可得到 X 进制表示。\n下面是整数转换的过程，这里要注意的是转换时是从低位到高位，如果要输出的话要进行倒序，体现在程序中就是先递归再输出。\n1 2 3 4 5 6 void print(int a) { if (!a) return; print(a / m); putchar(itc(a % m)); } 负进制 [NOIP2000 提高组] 进制转换\n在洛谷的这道题中，我们遇到了一个新的概念：负进制\n在负进制数中是用 $-R$ 作为基数，例如 $−15$（十进制）相当于 $110001$ （$-2$进制），并且它可以被表示为 $2$ 的幂级数的和数：\n$110001=1\\times (-2)^5+1\\times (-2)^4+0\\times (-2)^3+0\\times (-2)^2+0\\times (-2)^1 +1\\times (-2)^0$\n如果按照上面所写的转换过程，就会出现一个问题，比如在C++里对$-15$进行取模和相除的结果是：\n$-15%-2=-1$ ； $-15\\div-2=7$ ； $7\\times-2+(-1)=-15$\n虽然式子是成立的，但我们得到的余数是负数，这肯定是不行的，所以我们要想办法进行转换。\n所以我们可以将余数减去一个除数，同时将商+1。由于除数（绝对值）肯定是大于余数的，此时余数就会转换成正数。\n下面是具体实现的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void slove(int n, int r) { if (n == 0) return; int m = n % r; // m为余数 if (m \u0026lt; 0) // 如果余数小于0，转化为正数 m -= r, n += r; //商+1 =\u0026gt; 被除数+除数 if (m \u0026gt;= 10) m = \u0026#39;A\u0026#39; + m - 10; else m += \u0026#39;0\u0026#39;; slove(n / r, r); putchar(m); } 位运算 位运算的基本概念在组成原理这些课上已经讲过不知道多少遍了，这里就只提一下我觉得重要的点。\n位运算共有6种，分别是：与(\u0026amp;)、或(|)、异或(^)、取反(~)、左移(\u0026lt;\u0026lt;)和右移(\u0026gt;\u0026gt;)。\n这里要特别注意一下右移运算，它分为逻辑右移和算术右移：\n算术右移时，高位补最高位 逻辑右移时，高位补0 在C++中，数据类型包含有符号类型和无符号类型，其中有符号类型使用关键字 signed 声明，无符号类型使用关键字 unsigned 声明，两个关键字都不使用时，默认是有符号类型。对于有符号类型，右移运算为算术右移；对于无符号类型，右移运算为逻辑右移。\n在学习和刷题时，我们容易发现，左移运算对应乘法运算。将一个数左移 $k$ 位，等价于将这个数乘以 $2^k$。例如，$29$ 左移 $2$ 位的结果是 $116$，等价于 $29 \\times 4$。\n算术右移运算对应除法运算。将一个数右移 $k$ 位，相当于将这个数除以 $2^k$。例如，$50$ 右移 $2$ 位的结果是 $12$，等价于 $50 / 4$，结果向下取整。\n这里要注意，对于负数，整数除法是向 $0$ 取整，右移运算是向下取整，两者就不相同了。例如，$(-50)\u0026raquo;2$的结果是 $−13$，而 $(-50) / 4$ 的结果是$-12$，两者是不相等的。\n参考资料 位运算和数学 - LeetBook ","date":"2022-04-03T09:45:04+08:00","image":"https://lbqaq.top/p/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/95490521.webp","permalink":"https://lbqaq.top/p/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/","title":"进制转换和位运算"},{"content":"最近看了很多篇关于如何刷题的文章，其中都不约而同的提到了\u0026quot;总结\u0026quot;这个关键词。仔细想想自己确实是从来没有做过一篇总结，刷过的题目就过去了，导致同样的题目再做一次又不会了。\n我的第一篇总结就以最近刷到的「区间求和」问题展开吧。首先，先上一般问题的模板（其中加粗的为最佳方案）：\n数组不变，区间查询：前缀和、树状数组、线段树； 数组单点修改，区间查询：树状数组、线段树； 数组区间修改，单点查询：差分、线段树； 数组区间修改，区间查询：线段树。 前缀和 前缀和的作用就是为了帮助我们快速求某一段的和，是「差分」的逆运算。\n前缀和数组的每一位记录的是当前位置距离起点位置，这连续一段的和区间和。\n一维前缀和 假设有一个一维数组$x$和该数组的一维前缀和数组$y$，则$x$和$y$满足以下关系：\n$$y_0=x_0、y_1=x_0+x_1、y_2=x_0+x_1+x_2、\u0026hellip;\u0026hellip;、y_n=x_0+x_1+\u0026hellip;+x_n$$\n所以我们可以通过 $y_n=y_{n-1}+x_n$ 这个公式计算出前缀和，代码实现如下：\n1 2 3 4 for (int i = 0; i \u0026lt; n; i++) { if (i == 0) y[i] = x[i]; else y[i] = y[i - 1] + x[i]; } 但是在实际使用中，常常会遇到左边界溢出的情况，为了避免这种情况，我们可以将前缀和数组整体向后移动一位，下面给出前缀给计算代码：\n1 2 3 4 int n = x.size(); vector\u0026lt;int\u0026gt; y(n + 1); for (int i = 1; i \u0026lt;= n; i++) y[i] = y[i - 1] + x[i - 1]; 这样当我们想求区间$[a,b]$之和时只需要计算$y[b+1]-y[a]$即可。\n二维前缀和 有一个二维数组$a$和该数组的二维前缀和数组$b$（其同样是个二维数组)\n右侧标注橙色的二维前缀和元素，其值是左侧的原二维数组中标注橙色的所有元素的和。\n二维前缀和实际上就是一个矩阵内值的和，而矩阵又可以由两个行数或列数少一的子矩阵组合后，删去重合部分再加上右下角的值来构成，也就是以下式子：\n$$b_{x,y}=b_{x-1,y}+b_{x,y-1}-b_{x-1,y-1}+a_{x,y}$$\n详细的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 for (int y = 0; y \u0026lt; n; y++) // n行 for (int x = 0; x \u0026lt; m; x++) // m列 { if (x == 0 \u0026amp;\u0026amp; y == 0) b[y][x] = a[y][x]; //左上角的值 else if (x == 0) b[y][x] = b[y - 1][x] + a[y][x]; //第一列 else if (y == 0) b[y][x] = b[y][x - 1] + a[y][x]; //第一行 else b[y][x] = b[y - 1][x] + b[y][x - 1] - b[y - 1][x - 1] + a[y][x]; } 通过二维前缀和，我们可以很方便的计算出给定矩阵的和，即上面求前缀和的逆运算。假设所求矩阵的左上角点为$(x1,y1)$，右下角点为$(x2,y2)$，则有公式：\n$sum=B[y2][x2]+B[y1-1][x1-1]-B[y1-1][x2]-B[y2][x1-1]$\n这里结合图形会更好理解一点。\n例题 力扣303. 区域和检索 - 数组不可变\n就是一维前缀和的模板题，直接上模板即可做出。\n差分 差分是一种处理数据的巧妙而简单的方法，它应用于区间的修改和询问问题。如果我们要经常对数组A某个区间内的所有元素做相同的加减操作，如果一个一个修改效率很差，但是使用差分数组后，这个操作的时间复杂度就能降到$\\Omicron(1)$,当所有的修改操作结束后，再利用差分数组，计算出新的A。\n一维差分 我们定义原数组为$a[]$、差分数组为$D[]$，则有计算公式：$D[k]=a[k]-a[k-1]$,即原数组$a[]$的相邻元素的差。从定义我们可以推出$a[k]=D[0]+D[1]+\u0026hellip;+D[k]$。也就是说$a[]$是$D[]$的前缀和，所以「差分」和「前缀和」就是一组逆运算。\n当我们想要对区间$[L,R]$每个元素加上$d$，则只要进行下面的两步操作：\n1 2 D[L] += d; D[R+1] -= d; 当所有修改都完成时，我们可以通过复杂度为$\\Omicron(n)$的操作计算出新的$a[]$\n当然，差分也不是万能的，它只能解决 区间修改+单点查询 这类问题。当遇到需要多次查询的问题，比如有$m$次修改，$k$次查询，此时修改的复杂度为$\\Omicron(m)$,查询的复杂度为$\\Omicron(kn)$，总复杂度为$\\Omicron(m+kn)$，和暴力法$\\Omicron(mn+k)$的复杂度一致了。\n二维差分 从一维差分可以很容易的推广到二维差分，我们可以通过下面的公式计算$D[][]$：\n$$D[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]$$\n我们想修改坐标点$(x1,y1)$~$(x2,y2)$定义的区间，则需要修改矩阵的四个点：\n1 2 3 4 D[y1][x1] += d; //二维区间的起点 D[y1][x2+1] -= d; //把y看成常数，x从x1到x2+1 D[y2+1][x1] -= d; //把x看成常数，y从y1到y2+1 D[y2+1][x2+1] += d; //由于前两式把d减了2次，多减了1次，这里加1次回来 前缀和$a[][]$的计算可以用下面的公式：\n$$a[i][j]=D[i][j]+a[i-1][j]+a[i][j-1]-a[i-1][j-1]$$\n在计算$a[][]$时，我们可以不新开一个数组，而是以用过的$D[][]$作为$a[][]$，以此来节约空间。使用的话只需要将上面式子中的$a$全部换为$D$\n树状数组 树状数组的优点在于查询和修改的时间复杂度都为$\\Omicron(logn)$，且比线段树好写。\n单点修改、区间查询 树状数组的原理由于时间有限，这里就不展开说了（之后有空再补上😇），先上模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int c[MAXN];\t//树状数组(下标从1开始) int n;\t//数组的长度 inline int lowbit(int i) { return i \u0026amp; (-i); } //在位置i加上k void update(int i, int k) { while (i \u0026lt;= n) { c[i] += k; i += lowbit(i); } } //求A[1]~A[i]的和 int getsum(int i) { int res = 0; while (i \u0026gt; 0) { res += c[i]; i -= lowbit(i); } return res; } 这里一定要注意，树状数组和原数组下标都是从1开始的。\n由此就解决了单点修改、区间查询的问题，我们想要得到区间$(a,b)$的和，只需使用getsum(b) - getsum(a - 1)。\n例题：P3374【模板】树状数组 1\n区间修改、单点查询 在上面的差分中我们分析了，如果有多次查询，仅仅使用差分的时间复杂度就和暴力差不多了。这时，我们可以采用树状数组+差分的方法。\n我们将上面模板中的原始数组改为差分数组。由差分的性质可知，当我们修改一个区间时，只需要修改区间的两个端点即可，此时区间修改的问题便被转化成了单点修改的问题。同时，树状数组前n项和也就变成了原数组第n项的值。\n例题：P3368【模板】树状数组 2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //前面还是树状数组的模板，这里就不放了 int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int pre = 0, now; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; now; //这里每次求差分来生成树状数组 update(i, now - pre); pre = now; } while (m--) { int a, x, y, k; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; x; if (a == 1) { cin \u0026gt;\u0026gt; y \u0026gt;\u0026gt; k; //更新即为对D[X]、D[y+1]进行修改 update(x, k); update(y + 1, -k); } else if (a == 2) { //求D[1]~D[i]的和,即A[i]的值 cout \u0026lt;\u0026lt; getsum(x) \u0026lt;\u0026lt; endl; } } system(\u0026#34;pause\u0026#34;); return 0; } 参考资料 【朝夕的ACM笔记】算法基础-前缀和 差分 \u0026ndash;算法竞赛专题解析（32） 关于各类「区间和」问题如何选择解决方案（含模板） 树状数组详解 ","date":"2022-03-14T20:46:19+08:00","image":"https://lbqaq.top/p/%E5%88%9D%E6%8E%A2%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/95680357.webp","permalink":"https://lbqaq.top/p/%E5%88%9D%E6%8E%A2%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/","title":"初探区间求和问题"},{"content":"题目类型 选择（10分） 10题 填空（10分） 10题 问答（30分） 4题 编程题（30分） 3-4题 综合题（20分） 上机题整理 这里只存放核心的代码，完整的程序见Gitee仓库\n使用Maven 通过使用Maven可以让程序自动配置和导入包，不必自己手动配置和导入，非常方便，推荐大家使用。\n我的配置文件已经把考试会用的包都导入了，包括Servlet、JSP、JSTL、MySQl驱动，版本都已经调整为最佳，保证开箱即用。\n新建项目，选择Maven，直接下一步\n填写项目名称和目录位置，其他的可填可不填\n在pom.xml文件增加这样一句\u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt;\n接着粘贴下面的代码，并点击右上角的图标应用（或者使用快捷键Ctrl+Shift+O）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;dependencies\u0026gt; \u0026lt;!-- servlet 依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- jsp 依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet.jsp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet.jsp-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- jstl --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet.jsp.jstl\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jstl-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- standard标签库 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;taglibs\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;standard\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mysql驱动 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 在左边src的main这个目录下建立一个名叫webapp的目录，再这下面建立一个名叫WEB-INF的目录，再在其中建立web.xml这个文件\n在里面填入下面的内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;!--默认启用EL表达式--\u0026gt; \u0026lt;jsp-config\u0026gt; \u0026lt;jsp-property-group\u0026gt; \u0026lt;url-pattern\u0026gt;*.jsp\u0026lt;/url-pattern\u0026gt; \u0026lt;el-ignored\u0026gt;false\u0026lt;/el-ignored\u0026gt; \u0026lt;/jsp-property-group\u0026gt; \u0026lt;/jsp-config\u0026gt; \u0026lt;/web-app\u0026gt; 这样就配置好了，如果你还是觉得麻烦，可以下载我这个配置好的懒人包，解压即可使用，注意在IDEA打开时要选择“信任MAVEN项目”，否则无法生效。\nServlet生成三角形 正三角\n1 2 3 4 5 6 7 8 9 for (int i = 0; i \u0026lt; num; i++) { for (int j = 0; j \u0026lt; num - i; j++) { out.print(\u0026#34;\u0026amp;nbsp;\u0026#34;); } for (int k = 0; k \u0026lt;= i * 2; k++) { out.print(\u0026#34;*\u0026#34;); } out.println(\u0026#34;\u0026lt;/br\u0026gt;\u0026#34;); } 倒三角\n1 2 3 4 5 6 7 8 9 for (int i = num; i \u0026gt; 0; i--) { for (int j = num - i; j \u0026gt; 0; j--) { out.print(\u0026#34;\u0026amp;nbsp;\u0026#34;); } for (int k = (i * 2) - 1; k \u0026gt; 0; --k) { out.print(\u0026#34;*\u0026#34;); } out.println(\u0026#34;\u0026lt;/br\u0026gt;\u0026#34;); } JSP生成乘法表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;table\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;% String s = request.getParameter(\u0026#34;num\u0026#34;); int num = Integer.parseInt(\u0026#34;\u0026#34;.equals(s) ? \u0026#34;0\u0026#34; : s); for (int i = 1; i \u0026lt;= num; i++) { out.println(\u0026#34;\u0026lt;tr\u0026gt;\u0026#34;); for (int j = 1; j \u0026lt;= num; j++) { if (j \u0026lt;= i) { out.println(\u0026#34;\u0026lt;td\u0026gt;\u0026#34; + i + \u0026#34;*\u0026#34; + j + \u0026#34;=\u0026#34; + i * j + \u0026#34;\u0026lt;/td\u0026gt;\u0026#34;); }else{ out.println(\u0026#34;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026#34;); } } out.println(\u0026#34;\u0026lt;/tr\u0026gt;\u0026#34;); } %\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; 登录界面，三次禁用 数据用数组存储application，但我没使用，如果要使用可以调用request.getServletContext()\n用户信息存在session\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @WebServlet(name = \u0026#34;Servlet3\u0026#34;, value = \u0026#34;/Servlet3\u0026#34;) public class Servlet3 extends HttpServlet { private static final String[] USER_NAME = {\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}; private static final String[] PASSWORD = {\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;}; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String username = req.getParameter(\u0026#34;username\u0026#34;); String password = req.getParameter(\u0026#34;password\u0026#34;); if (username == null || password == null || \u0026#34;\u0026#34;.equals(username) || \u0026#34;\u0026#34;.equals(password)) { req.setAttribute(\u0026#34;msg\u0026#34;, \u0026#34;用户名或密码不能为空！\u0026#34;); req.getRequestDispatcher(\u0026#34;/3.jsp\u0026#34;).forward(req, resp); return; } HttpSession mySession = req.getSession(); int errTime = (int) (mySession.getAttribute(\u0026#34;errTime\u0026#34;) == null ? 0 : mySession.getAttribute(\u0026#34;errTime\u0026#34;)); Date dbDate = (Date) mySession.getAttribute(\u0026#34;dbDate\u0026#34;); Date nowDate = new Date(); if (errTime \u0026gt;= 3) { if (dbDate.after(nowDate)) { req.setAttribute(\u0026#34;msg\u0026#34;, \u0026#34;您被禁止登录！\u0026#34;); req.getRequestDispatcher(\u0026#34;/3.jsp\u0026#34;).forward(req, resp); return; } else { errTime = 0; } } int i; for (i = 0; i \u0026lt; USER_NAME.length; i++) { if (username.equals(USER_NAME[i]) \u0026amp;\u0026amp; password.equals(PASSWORD[i])) { errTime = 0; req.setAttribute(\u0026#34;msg\u0026#34;, \u0026#34;登陆成功！\u0026#34;); break; } } if(i\u0026gt;=USER_NAME.length) { errTime += 1; if (errTime \u0026gt;= 3) { //单位为毫秒 nowDate.setTime(nowDate.getTime() + 1 * 60 * 1000); } req.setAttribute(\u0026#34;msg\u0026#34;, \u0026#34;用户名或密码错误！\u0026#34;); } mySession.setAttribute(\u0026#34;errTime\u0026#34;, errTime); mySession.setAttribute(\u0026#34;dbDate\u0026#34;,nowDate); req.getRequestDispatcher(\u0026#34;/3.jsp\u0026#34;).forward(req, resp); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } 用户认证 不使用Filter\n1 2 3 4 5 6 7 \u0026lt;% Object username = session.getAttribute(\u0026#34;username\u0026#34;); if(username==null){ request.setAttribute(\u0026#34;msg\u0026#34;,\u0026#34;您没有登陆\u0026#34;); request.getRequestDispatcher(\u0026#34;/4-1.jsp\u0026#34;).forward(request,response); } %\u0026gt; 使用Filter\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //filterName：过滤器名称 urlPatterns：过滤的范围 过滤全部为\u0026#34;/*\u0026#34; @WebFilter(filterName = \u0026#34;Filter4\u0026#34;, urlPatterns = \u0026#34;/4-3.jsp\u0026#34;) public class Filter4 implements Filter { public void init(FilterConfig config) throws ServletException {} public void destroy() {} @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse resp = (HttpServletResponse) response; Object username = req.getSession().getAttribute(\u0026#34;username\u0026#34;); if (username == null) { req.setAttribute(\u0026#34;msg\u0026#34;, \u0026#34;您没有登陆\u0026#34;); req.getRequestDispatcher(\u0026#34;/4-1.jsp\u0026#34;).forward(req, resp); } else { chain.doFilter(request, response); } } } 录入用户信息并回显 如姓名爱好（checkbox数组）提交后，在界面上显示提交的信息\n修改数据时，如何将原数据显示在表单中也在此段中。特别是select radio\n使用EL表达式即可\n注意点：\ncheckbox传递的值为数组，需使用request.getParameterValues(\u0026quot;b\u0026quot;);获取 可以将数组转换为列表，方便使用相关方法 List\u0026lt;String\u0026gt; list = Arrays.asList(strArray); 只能查看，不支持修改和删除 ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;(Arrays.asList(strArray)); 可以修改和删除 checkbox和radio选中为checked；select中的option为selected 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;form method=\u0026#34;post\u0026#34; action=\u0026#34;${pageContext.request.contextPath}/Servlet5\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;a\u0026#34;\u0026gt;文本框\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;a\u0026#34; name=\u0026#34;a\u0026#34; value=\u0026#34;${A}\u0026#34;/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;label for=\u0026#34;b\u0026#34;\u0026gt;多选框\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;b\u0026#34; name=\u0026#34;b\u0026#34; value=\u0026#34;1\u0026#34; ${BL.contains(\u0026#34;1\u0026#34;)?\u0026#34;checked\u0026#34;:\u0026#34;\u0026#34;}/\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;b\u0026#34; value=\u0026#34;2\u0026#34; ${BL.contains(\u0026#34;2\u0026#34;)?\u0026#34;checked\u0026#34;:\u0026#34;\u0026#34;}/\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;b\u0026#34; value=\u0026#34;3\u0026#34; ${BL.contains(\u0026#34;3\u0026#34;)?\u0026#34;checked\u0026#34;:\u0026#34;\u0026#34;}/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;label for=\u0026#34;c1\u0026#34;\u0026gt;单选框 4\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; id=\u0026#34;c1\u0026#34; name=\u0026#34;c\u0026#34; value=\u0026#34;4\u0026#34; ${\u0026#34;4\u0026#34;.equals(C)?\u0026#34;checked\u0026#34;:\u0026#34;\u0026#34;}/\u0026gt; \u0026lt;label for=\u0026#34;c2\u0026#34;\u0026gt;单选框 5\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; id=\u0026#34;c2\u0026#34; name=\u0026#34;c\u0026#34; value=\u0026#34;5\u0026#34; ${\u0026#34;5\u0026#34;.equals(C)?\u0026#34;checked\u0026#34;:\u0026#34;\u0026#34;}/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;label for=\u0026#34;d\u0026#34;\u0026gt;下拉框\u0026lt;/label\u0026gt; \u0026lt;select name=\u0026#34;d\u0026#34; id=\u0026#34;d\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;6\u0026#34; ${\u0026#34;6\u0026#34;.equals(D)?\u0026#34;selected\u0026#34;:\u0026#34;\u0026#34;}\u0026gt;6\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;7\u0026#34; ${\u0026#34;7\u0026#34;.equals(D)?\u0026#34;selected\u0026#34;:\u0026#34;\u0026#34;}\u0026gt;7\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;8\u0026#34; ${\u0026#34;8\u0026#34;.equals(D)?\u0026#34;selected\u0026#34;:\u0026#34;\u0026#34;}\u0026gt;8\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 请求转发、重定向，实现传值 请求转发：\nrequest.setAttribute(\u0026quot;D\u0026quot;, d); 或者存放到Session里request.getSession().setAttribute(\u0026quot;D\u0026quot;, d); 重定向：\n只能放在Session里 或者通过构造URL参数传递，如response.sendRedirect(\u0026quot;/1.jsp?a=\u0026quot;+a+\u0026quot;\u0026amp;b=\u0026quot;+b); 在servlet如何使用jsp:usebean jsp来接收form内的值 jsp中使用下面的代码\n1 2 \u0026lt;jsp:useBean id=\u0026#34;s\u0026#34; class=\u0026#34;yzu.calc\u0026#34; scope=\u0026#34;request\u0026#34; /\u0026gt; \u0026lt;jsp:setProperty name=\u0026#34;s\u0026#34; property=\u0026#34;*\u0026#34; /\u0026gt; servlet中使用\n1 2 request.getRequestDispatcher(\u0026#34;getForm.jsp\u0026#34;).include(request,response); calc mybean=(calc)request.getAttribute(\u0026#34;s\u0026#34;); 从web表单接收数据 request.getParameter request.getParameterValues 数据库实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 private static final String DRIVER = \u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;; private static final String URL = \u0026#34;jdbc:mysql://localhost:3306/web?serverTimezone=Asia/Shanghai\u0026amp;characterEncoding=utf-8\u0026#34;; private static final String USERNAME = \u0026#34;root\u0026#34;; private static final String PASSWORD = \u0026#34;root\u0026#34;; //加载驱动 try { Class.forName(DRIVER); connection = DriverManager.getConnection(URL, USERNAME, PASSWORD); } catch (Exception e) { e.printStackTrace(); } if (connection != null) { String sql = \u0026#34;select * from user where name=?\u0026#34;; PreparedStatement pstm = null; ResultSet rs = null; try { //加载SQL语句 pstm = connection.prepareStatement(sql); //填入变量 pstm.setObject(1, username); //执行SQL（查询） rs = pstm.executeQuery(); //执行SQL（增删改） updateRows = pstm.executeUpdate(); //读取数据（多行使用while） if (rs.next()) { dbPassword = rs.getString(\u0026#34;password\u0026#34;); dbDate = new Date(rs.getTimestamp(\u0026#34;time\u0026#34;).getTime()); dbErrorTime = rs.getInt(\u0026#34;error_count\u0026#34;); } //释放资源 rs.close(); pstm.close(); connection.close(); }SQLException (e) { e.printStackTrace(); } 注册用户 多个信息 不懂什么意思，有懂哥可以评论区留言\nDB CRUD查询组合查询不需要分页 见上面\n用会话对象实现购物车的CRUD商品名称，单价，数量购物车列表，总价 具体代码见仓库Servlet6\n问答题 C/S B/S优缺点 C/S架构\n全称是Client/Server，即客户端服务器端架构\n优点：\nC/S架构的界面和操作可以很丰富。 安全性能可以很容易保证，实现多层认证也不难。 由于只有一层交互，因此响应速度较快。 缺点：\n适用面窄，通常用于局域网中。 用户群固定。由于程序需要安装才可使用，因此不适合面向一些不可知的用户。 维护成本高，发生一次升级，则所有客户端的程序都需要改变。 B/S架构\n全称为Browser/Server，即浏览器/服务器结构。\n优点：\n客户端无需安装，有Web浏览器即可。 BS架构可以直接放在广域网上，通过一定的权限控制实现多客户访问的目的，交互性较强。 BS架构无需升级多个客户端，升级服务器即可。 缺点：\n在跨浏览器上，BS架构不尽如人意。 表现要达到CS程序的程度需要花费不少精力。 在速度和安全性上需要花费巨大的设计成本，这是BS架构的最大问题。 JSTL EL JDBC VO DAO MVC JSP中英文全称 JSTL:Java server pages standarded tag library，JSP标准标签库 EL:Expression Language,EL表达式 JDBC:Java Database Connectivity,Java数据库连接 VO:Value Object,值对象 DAO:Data Access Object,数据库访问对象 MVC:Model View Controller,模型 视图 控制器 JSP:Java Server Pages,JAVA服务器页面 多层架构的优点 高内聚低耦合，便于团队开发\n内聚：一个模块内各个元素彼此结合的紧密程度；\n耦合：一个软件结构内不同模块之间关联程度的度量。\n在团队开发中，分层可以让软件开发人员专注于自己负责的层，而不必关心其他层的设计，也不必担心自己的设计会影响其它层。如果不分层，根本不可能进行团队开发，只会一团糟。\n使软件升级和维护更为容易\n分层设计使得程序结构清晰，升级和维护都变得十分容易，更改层的具体实现代码，只要层接口保持稳定，其他层可以不必修改。即使层的接口发生变化，也只影响上层和下层，修改工作量小而且错误可以控制，不会带来意外的风险。\nMVC的特点和优点 MVC主要分模型、视图、控制器三层。\n模型(model)\n它是应用程序的主体部分，主要包括业务逻辑模块和数据模块。模型与数据格式无关，这样一个模型能为多个视图提供数据。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性\n视图(view)\n用户与之交互的界面、在 web 中视图一般由 jsp,html 组成\n控制器(controller)\n接收来自界面的请求 并交给模型进行处理 在这个过程中控制器不做任何处理只是起到了一个连接的作用\n优点：\n降低代码耦合性。在 MVC 模式中，三个层各施其职，所以如果一旦哪一层的需求发生了变化，就只需要更改相应的层中的代码而不会影响到其他层中的代码。 有利于分工合作。在 MVC 模式中，由于按层把系统分开，那么就能更好的实现开发中的分工。网页设计人员可进行开发视图层中的 JSP，而对业务熟悉的人员可开发业务层，而其他开发人员可开发控制层。 有利于组件的重用。如控制层可独立成一个能用的组件，表示层也可做成通用的操作界面。可以为一个模型在运行时同时建立和使用多个视图。 GET、POST特点和优缺点 GET\n查询字符串（名称/值对）是在GET请求的URL中发送的\n优点：\nGET请求可被缓存 GET请求速度快 GET请求可被收藏为书签 GET请求保留在浏览器历史记录中 缺点：\nGET请求不安全 GET请求有url长度限制 POST\n查询字符串（名称/值对）是在POST请求的HTTP消息主体中发送的\n优点：\nPOST请求对数据长度没有要求 POST请求相对GET请求更安全 缺点：\nPOST请求不会被缓存 POST请求速度慢 重定向与请求转发的优缺点 实现的核心代码 重定向\n优点：\n不限制应用范围，可以重定向到服务器内部其他资源，也可以是外部的应用 缺点：\n重定向解决方案需要在浏览器与服务器之间进行多次往返，大量时间消耗在往返次数上，增加用户等待服务时间 核心代码：response.sendRedirect(\u0026quot;请求地址\u0026quot;)\n请求转发\n优点：\n安全性高，在内部发生跳转，浏览器地址不变 转发只需要一次请求，就可以访问至少两个servlet或jsp页面。 缺点：\n只能在同一web应用内使用，不能转发到外部的url地址。 核心代码：request.getRequestDispatcher(\u0026quot;URL地址\u0026quot;).forward(request, response)\nJSP Servlet 区别与联系 区别：\njsp更擅长表现于页面显示,servlet更擅长于逻辑控制。 Servlet中没有内置对象，Jsp中有内置对象。 Servlet在Java代码中通过HttpServletResponse对象动态输出HTML内容；JSP在静态HTML内容中嵌入Java代码，Java代码被动态执行后生成HTML内容 联系：\njsp是对servlet的一种高级封装。本质还是servlet。 jsp会由TomCat自动编译成“类servlet”。 JSP内置对象 对象 描述 request HttpServletRequest 接口的实例 response HttpServletResponse 接口的实例 out JspWriter类的实例，用于把结果输出至网页上 session HttpSession类的实例 application ServletContext类的实例，与应用上下文有关 config ServletConfig类的实例 pageContext PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问 page 类似于Java类中的this关键字 Exception Exception类的对象，代表发生错误的JSP页面中对应的异常对象 JavaBean相关动作标记有哪些，用代码说明之 语法 描述 jsp:useBean 寻找或者实例化一个JavaBean。 jsp:setProperty 设置JavaBean的属性。 jsp:getProperty 输出某个JavaBean的属性。 \u0026lt;jsp:useBean id = \u0026quot;name\u0026quot; class = \u0026quot;package.class\u0026quot; scope= \u0026quot;page | request | session | application\u0026quot; /\u0026gt;\n其中：\n1）id\n表示 Bean 实例化对象的变量名，可以在指定范围内使用该变量名。\n2）class\n表示需要实例化 Bean 的类路径，指定的类必须包含 public 且无参数的构造方法。\n3）scope\n指定 Bean 的作用域，取值为：\npage：只能在当前页面使用该 Bean 对象； request：只能在一次请求范围内使用该 Bean 对象； session：只能在一次会话范围内使用该 Bean 对象； application：可以在整个应用范围内使用该 Bean 对象。 \u0026lt;jsp:setProperty name = \u0026quot;beanName\u0026quot; property = \u0026quot;attributeName\u0026quot; value = \u0026quot;attributeValue\u0026quot;/\u0026gt;\n\u0026lt;jsp:setProperty\u0026gt; 通常和 \u0026lt;jsp:useBean\u0026gt; 一起使用，分为两种情况。\n在 \u0026lt;jsp:useBean\u0026gt; 标签外使用\u0026lt;jsp:setProperty\u0026gt;\n以上情况，无论 \u0026lt;jsp:useBean\u0026gt; 是否实例化了 User 对象，\u0026lt;jsp:setProperty\u0026gt; 都会执行。\n在 \u0026lt;jsp:useBean\u0026gt; 标签里使用 \u0026lt;jsp:setProperty\u0026gt;\n只有 \u0026lt;jsp:useBean\u0026gt; 实例化了 User 对象，\u0026lt;jsp:setProperty\u0026gt; 才会执行\n\u0026lt;jsp:getProperty name = \u0026quot;beanName\u0026quot; property = \u0026quot;attributeName\u0026quot;\u0026gt;\n其中，name 指定需要获取属性的 Bean 的名称；property 指定 Bean 的属性，即 Bean 类中的属性。\n当 property 的取值为 * 时，要求 Bean 属性的名称与类型要与 request 请求中参数的名称及类型一致，以便用 Bean 中的属性来接收客户输入的数据，系统会根据名称来自动匹配。\n注意：\u0026lt;jsp:setProperty\u0026gt; 和 \u0026lt;jsp:getProperty\u0026gt; 动作都会按照 page、request、session 和 application 的顺序依次查找指定 Bean 的实例对象，直到第一个实例被找到。如果任何范围内都不存在这个 Bean 实例，则会拋出异常。\nEL与作用城相关的隐含对象有哪些 内置对象 说明 pageScope 获取 page 范围的变量 requestScope 获取 request 范围的变量 sessionScope 获取 session 范围的变量 applicationScope 获取 application 范围的变量 param 相当于 request.getParameter(String name)，获取单个参数的值 paramValues 相当于 request.getParameterValues(String name)，获取参数集合中的变量值 header 相当于 request.getHeader(String name)，获取 HTTP 请求头信息 headerValues 相当于 request.getHeaders(String name)，获取 HTTP 请求头数组信息 initParam 相当于 application.getInitParameter(String name)，获取 web.xml 文件中的参数值 cookie 相当于 request.getCookies()，获取 cookie 中的值 pageContext 表示当前 JSP 页面的 pageContext 对象 EL 表达式可以输出 4 种属性范围的内容。如果在不同的属性范围中设置了同一个属性名称，则按照 page、request、session、application 的顺序依次查找。\n${person.name} person存放在request属性中person对象的类yzu.Person，对象的java代码是什么(JavaBean) \u0026lt;%=((yzu.Person)request.getAttribute(\u0026quot;person\u0026quot;)).getName()%\u0026gt;\n过滤器与Servlet区别与联系，他有什么作用 过滤器（Filter）：对Request请求起到过滤的作用，作用在Servlet之前\nServlet：处理Request请求和Response响应\nJava和JSP的区别 Java是一种通用的计算机编程语言，它是并发的，基于类的，面向对象的，并且专门设计为具有尽可能少的实现依赖性。而JSP是一种技术，可帮助软件开发人员基于HTML，XML或其他文档类型创建动态生成的Web页面。 Java applet是使用Java编程语言编写的。JSP使用“scriptlet元素”（Java代码）和“标记”（通常是HTML或XML）的混合编程，以提供数据驱动（“动态”）网页。 Java为面向对象语言，JSP可以理解为一种脚本 Java主要负责逻辑，业务处理，而JSP主要负责页面展现 JSP的本质是servlet，而servlet的本质是Java类 JSP开发的优点 将内容的生成和显示分离\n借助jsp技术，web页面发开人员可以使用html或者xml标签来设计和格式化最终页面，使用jsp标签或者脚本程序来生成动态web页面的内容（页面的内容是根据请求来变化的，例如，请求账户信息或者特定的一本书的价格）。生成内容的逻辑被封装在标签和javabean组件中，并且捆绑在脚本程序中，所有的脚本程序在服务器端运行。因此，其他人能够方便地编辑和使用jsp页面，而不影响内容的生成。\n强调可重用的组件\njsp页面可借助可重用的、跨平台的组件来执行应用程序所要求的极为复杂的业务逻辑。开发人员能够共享和交换执行普通操作的组件，或者让这些组件被别的开发人员或开发团队所使用。基于组件的方法加速了总体开发进程，并且使得各种组织在他们现有的技能和优化结果的开发努力中得到平衡。\n采用标签简化页面开发\n通过使用jsp提供的标准标签库，web页面开发人员能够访问和实例化javabean组件、设置或者检索组件属性、下载applet以及执行用其他方法更难于编码和耗时的功能。此外，web页面开发人员还可以为常用功能创建自己的标签库，这是的web页面开发人员能够使用熟悉的工具盒如同标签一样的执行特定功能的构件来工作。\n一次编写、处处运行\n由于jsp页面的内置脚本是基于java语言的，而且所有的jsp页面都被编译为java servlet，因此jsp页面就具有java技术的所有好处，包括健壮性和安全性等。作为java平台的一部分，jsp拥有java语言“一次编写，处处运行”的特点。jsp几乎可以运行于所有的平台，如windows nt、linux、unix等。\n更高的效率和安全性\njsp程序在执行之前先被编译成字节码文件，字节码文件有java虚拟机解释执行，比源代码解释的效率高。此外，服务器端还有字节码的cache机构，能提高字节码的访问效率。第一次调用jsp网页可能稍慢，因为它被编译成cache，以后就快的多了。同时，jsp源程序不大可能被下载，特别是javabean程序，完全可能放到不对外的目录中。\n","date":"2022-01-03T19:52:31+08:00","image":"https://lbqaq.top/p/javawebexam/92462192.webp","permalink":"https://lbqaq.top/p/javawebexam/","title":"JavaWeb期末复习"},{"content":"新番“先审后播”政策已经实行了快半年了，现在看来在哔哩哔哩上追番的体验已经没有之前那样舒适了，更不用提还有好多番剧连上线都没有上线。这时本地看番就成了一个比较不错的选择了。这篇文章就记录以下这段时间我本地追番使用的工具和网站，大家也可以以此为参照，打造属于自己的追番体验。\n找番 “巧妇难为无米之炊”，没有片源的话，本文使用的一切工具也就无从谈起了。下面我就列举几个我知道的找番网址：\n（推荐）萌番组\n只能说是良心网站了，国内可以直连，支持RSS订阅和筛选\n動漫花園\n老牌网站了，国内无法直连，但分享内容不止番剧，还有音乐等内容\nNyaa\n一般是英文资源，可做为备用网站\n下载 找到了需要的资源（一般都是BT链接），下一步就是下载了，这里我推荐qBittorrent，我认为是BT下载的最优解了。Windows平台我建议选择增强版qBittorrent-Enhanced-Edition\n对于新番来说，速度基本是不慢的。但如果要下载旧番的话，如果分享的人不多的话速度就不太理想了。\n面对这种情况我知道的有这样几种解决方法：\n使用115等支持离线的网盘\n这里我推荐一个安卓的APP，叫PikPak。由于是新出的，现在有会员免费领取的活动，可以无限次离线+3T空间。我个人测试了一下离线成功率和下载速度还是不错的，乘现在还能白嫖就多用用吧_(:з)∠)_\n租一台国外的VPS，先在上面下载好再转存到国内（因为有些资源分享的人在国内无法连接到，所以这个方法才有用😂）\n看看百度云等网盘上有没有人分享\n使用PT，当然这个难度过大了，就连我也没整过😇\n播放 说到本地播放器，那就不得不提到PotPlayer的大名了，这基本是播放器的最优解了，在这里我就不过多阐述它的优点了，我主要是想提一提另外的一款播放器——弹弹play\n相比PotPlayer，它最大的优点就是支持弹幕的播放。在看了这么多年的B站以后，现在看番不带弹幕就觉得缺了些什么，这款播放器就很好的解决了我这个痛点。当然它的功能不止这些，比如可以配置自动下载、开启远程访问等等。但我一般不会让一个播放器后台常驻+开机自启的，所以这些功能对我来说并没有多大的作用。\n当然还是有缺点的，比如不能像pakku那样将重复弹幕合并成一条大弹幕，使用自带的重复弹幕屏蔽会有肉眼可见的弹幕消失等BUG。不过瑕不掩瑜，这款播放器我还是很推荐的。\n补帧 终于到这个环节了，这才是我写这篇文章的主要动力。\n国际惯例，先来一段名词解释：\n帧数(Frames)，为帧生成数量的简称。由于口语习惯上的原因，我们通常将帧数与帧率混淆。每一帧都是静止的图象，快速连续地显示帧便形成了运动的假象，因此高的帧率可以得到更流畅、更逼真的动画。\n而帧率（Frame rate）是用于测量显示帧数的量度。所谓的测量单位为每秒显示帧数(Frames per Second，简称：FPS）或“赫兹”（Hz）。此词多用于影视制作和电子游戏。\n所以说补帧就是将低帧率的视频通过一定的算法提升到高帧率。直观来看，就是画面变得更加流畅丝滑了，还不理解的话可以看下面的动图或者看看极客湾的这期视频，通过不同帧率的对比能有个更清晰的认识。\n当然，上面的视频中使用的是AI补帧，对显卡和时间要求都十分高。我们正常看番是用不到这些的。这里就列举本地实时插帧的三款软件。\nAMD Fluid Motion SVP dmitriRender 硬件需求 支持此功能的A卡 无 高性能的显卡 是否收费 免费 收费（可试用） 收费（可试用） 正版体验 / 优秀 较差 配置难度 不知道 复杂 简单 支持格式 全部 不支持HEVC 全部 至于补帧效果，我感觉对于动漫dmitriRender要比SVP要好一点。当然由于动漫的画面一般不具有逻辑连续，所以还是会有一点虚影的，不过不影响观看。\n两款软件的正版激活体验来说，还是SVP比较好，不限次数反激活，支持官网反激活。而dmitriRender不但不支持官网反激活，而且只有20次反激活的限制，更要命的是如果系统重装、硬件更新都可能会掉激活，贴吧上也有好多丢失激活的情况。\ndmitriRender的官网售价是$15.00（我当时买的是12刀，居然涨价了）\nSVP的官网售价是$19.99（太贵了，等黑五促销再说）\nSVP是支持支付宝付款的，而dmitriRender需要一张信用卡\n不过，上面两块软件都有爱心分享版，这里就不直接写出来了（避免查水表），如果有需要可以在评论里留言。\n小结 这篇文章还是拖更了好久，每次在心里列下想写的内容，一到电脑前就懒得动手了😭之后一定会补上两款补帧软件的安装和配置方法。\n","date":"2021-10-26T15:39:41+08:00","image":"https://lbqaq.top/p/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%9C%8B%E7%95%AA/90624322.webp","permalink":"https://lbqaq.top/p/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%9C%8B%E7%95%AA/","title":"如何优雅的看番"},{"content":"最近把服务器重装成Ubuntu了，所以要重装MySQL，没想到在这里踩了好几个坑，在这里记录下来备忘。\n安装 这其实很简单，直接通过Ubuntu的包管理器直接安装就行了（我把系统转为Ubuntu也有这方面的原因）。\n1 sudo apt-get install mysql-server 通过这条命令安装的MySQL的root账号是没有密码的，所以只要输入mysql就直接可以进入了\n开启远程访问 这里就是本文的重点了，我在这里花了很多时间😇\n设定MySQL的监听端口 通过apt安装的MySQL默认是只监听本地的端口的，我们要修改使其监听所有ip地址的请求。\n1 2 3 4 vim /etc/mysql/mysql.conf.d/mysqld.cnf #把bind - address后面的127.0.0.1改为0.0.0.0 #重启MySQL服务器 systemctl restart mysql 设置root账号密码并开启远程访问 默认root账号是没有密码的，这当然是不行的，我们需要给一个密码\n1 2 3 4 use mysql; ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;新的密码\u0026#39;; update user set host = \u0026#39;%\u0026#39; where user=\u0026#39;root\u0026#39;; flush privileges; 还要注意把防火墙的3306端口放行，这样就可以实现MySQL的远程访问了。\n","date":"2021-10-21T10:19:52+08:00","image":"https://lbqaq.top/p/mysql8%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/90561040.webp","permalink":"https://lbqaq.top/p/mysql8%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/","title":"MySQL8开启远程访问"},{"content":"在我现在在做的项目中需要进行身份和权限认证，在网上找了些教程，推荐都是使用JWT来进行身份认证，于是便决定使用此方法来实现。（然而用完了才发现JWT也有缺点）\n何为JWT 所谓JWT，全称是JSON Web Token。下面是从官网摘抄的定义：\nJWT是一个开放的标准（RFC 7519），它定义了一种紧凑和独立的方式，以JSON对象的形式在各方之间安全地传输信息。这种信息可以被验证和信任，因为它是经过数字签名的。JWTs可以使用秘密（使用HMAC算法）或使用RSA或ECDSA的公共/私人密钥对进行签名。\n按我的理解，JWT其实就是将传统的session认证中的token存储位置从服务器上下发给用户，服务器只需要判断传来的token是否合法而无需存储。这样做的好处就是可以做分布式的服务器，无需考虑用户是在哪一台服务器上登录的。\n详细的定义和构成我这里就不展开了，这里主要关注JWT中Payload（载荷）。这是有效信息存放的地方，我们一般关注这里就行了。\n下面是官方提供且建议（并不强制）使用的声明：\niss: jwt签发者\nsub: 主题\naud: 接收jwt的一方\nexp: jwt的过期时间，这个过期时间必须要大于签发时间\nnbf: 生效时间，在此时间之前该jwt都是不可用的.\niat: jwt的签发时间\njti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。\n当然，在载荷中还可以存放自定义的信息，在本项目中使用官方提供的就足以了，故不展开。\n认证流程 用户使用用户名密码来请求服务器 服务器进行验证用户的信息 服务器通过验证发送给用户一个token 客户端存储token，并在每次请求时附送上这个token值 服务端验证token值，并返回数据 具体实现 导入依赖包 第一步当然是导入相关依赖了，使用Maven进行包管理。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- shiro --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shiro\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shiro-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.8.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- jwt --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.auth0\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;java-jwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.18.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 封装JWT工具类 这里主要实现JWT的生成、验证、提取用户名三个功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 @Slf4j public class JwtUtil { /** * 服务器私钥 */ private static final Algorithm ALGORITHM = Algorithm.HMAC256(\u0026#34;test\u0026#34;); /** * 生成JSON Web Token * * @param username 用户名 * @param issuer 签发者 * @param subject 面向主体 * @param ttlMillis 生效时长(单位:毫秒) */ public static String creatJwt(String username, String issuer, String subject, long ttlMillis) { long nowMillis = System.currentTimeMillis(); Date now = new Date(nowMillis); JWTCreator.Builder builder = JWT.create() .withAudience(username) .withIssuedAt(now) .withSubject(subject) .withIssuer(issuer); if (ttlMillis \u0026gt;= 0) { long expMillis = nowMillis + ttlMillis; Date exp = new Date(expMillis); builder.withExpiresAt(exp); } return builder.sign(ALGORITHM); } /** * 生成JSON Web Token * * @param username 用户名 * @param issuer 签发者 * @param subject 面向主体 * @param expDate 失效日期 */ public static String creatJwt(String username, String issuer, String subject, Date expDate) { Date now = new Date(); JWTCreator.Builder builder = JWT.create() .withAudience(username) .withIssuedAt(now) .withSubject(subject) .withIssuer(issuer); if (now.before(expDate)) { builder.withExpiresAt(expDate); } return builder.sign(ALGORITHM); } /** * 获取签发对象 * * @param token 需要解密的token * @return 解密后获得的对象，失败返回null */ public static String getAudience(String token) { String audience; try { audience = JWT.decode(token).getAudience().get(0); } catch (JWTDecodeException exception) { log.error(\u0026#34;输入的token无法解析\u0026#34;); return null; } return audience; } /** * 验证token是否正确 * * @param token 需要验证的token * @return 通过验证返回true，反之抛出异常 */ public static Boolean verifyToken(String token) throws JWTVerificationException { JWTVerifier verifier = JWT.require(ALGORITHM).build(); verifier.verify(token); return true; } } 配置Shiro 这里的ShiroConfig.java与一般Shiro项目的配置有以下几点不同：\n禁用Session 使用自定义的jwtFilter过滤器，用来拦截并处理携带JWT token的请求 使用自定义的Realm认证器，用于验证用户是否存在及查询用户权限 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @Configuration public class ShiroConfig { @Autowired private MyRealm myRealm; @Bean public DefaultWebSecurityManager getDefaultWebSecurityManager() { DefaultWebSecurityManager manger = new DefaultWebSecurityManager(); manger.setRealm(myRealm); // 关闭shiro自带的session DefaultSubjectDAO subjectDAO = new DefaultSubjectDAO(); subjectDAO.setSessionStorageEvaluator(sessionStorageEvaluator()); manger.setSubjectDAO(subjectDAO); return manger; } @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager manger) { ShiroFilterFactoryBean bean = new CustomShiroFilterFactoryBean(); bean.setSecurityManager(manger); Map\u0026lt;String, Filter\u0026gt; filterMap = new HashMap\u0026lt;\u0026gt;(); filterMap.put(\u0026#34;jwt\u0026#34;, getJwtFilter()); bean.setFilters(filterMap); Map\u0026lt;String, String\u0026gt; map = new LinkedHashMap\u0026lt;\u0026gt;(); //设置过滤规则，anon表示无需认证，其余的请求都通过自定义的jwt认证器 map.put(\u0026#34;/\u0026#34;, \u0026#34;anon\u0026#34;); map.put(\u0026#34;/swagger-ui/**\u0026#34;, \u0026#34;anon\u0026#34;); map.put(\u0026#34;/v3/api-docs\u0026#34;, \u0026#34;anon\u0026#34;); map.put(\u0026#34;/swagger-resources/**\u0026#34;, \u0026#34;anon\u0026#34;); map.put(\u0026#34;/unauthorized/**\u0026#34;, \u0026#34;anon\u0026#34;); map.put(\u0026#34;/**\u0026#34;, \u0026#34;jwt\u0026#34;); bean.setFilterChainDefinitionMap(map); bean.setLoginUrl(\u0026#34;/login\u0026#34;); // 设置无权限时跳转的 url bean.setUnauthorizedUrl(\u0026#34;/unauthorized/无权限\u0026#34;); return bean; } public JwtFilter getJwtFilter() { return new JwtFilter(); } /** * 开启注解代理 */ @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) { AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager); return authorizationAttributeSourceAdvisor; } /** * 禁用session, 不保存用户登录状态。保证每次请求都重新认证 */ @Bean protected SessionStorageEvaluator sessionStorageEvaluator() { DefaultSessionStorageEvaluator sessionStorageEvaluator = new DefaultSessionStorageEvaluator(); sessionStorageEvaluator.setSessionStorageEnabled(false); return sessionStorageEvaluator; } } 自定义Token 由于使用了JWT当token，自然要写自定义的Token\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class JwtToken implements AuthenticationToken { private String token; public JwtToken(String token) { this.token = token; } @Override public Object getPrincipal() { return token; } @Override public Object getCredentials() { return token; } } 自定义过滤器 由于使用了JWT，所以不能使用shiro中自带的过滤器，而是自定义自己的过滤器 JWTFilter，JWTFilter 继承了 BasicHttpAuthenticationFilter，并部分原方法进行了重写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @Slf4j public class JwtFilter extends BasicHttpAuthenticationFilter { @Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) { //判断请求的请求头是否带上 \u0026#34;Token\u0026#34; if (isLoginAttempt(request, response)) { //如果存在，则进入 executeLogin 方法执行登入，检查 token 是否正确 try { executeLogin(request, response); return true; } catch (Exception e) { //token 错误 responseError(response, e.getMessage()); } } //如果请求头不存在 Token，则可能是执行登陆操作或者是游客状态访问，无需检查 token，直接返回 true return true; } /** * 判断用户是否想要登入。 * 检测 header 里面是否包含 Token 字段 */ @Override protected boolean isLoginAttempt(ServletRequest request, ServletResponse response) { HttpServletRequest req = (HttpServletRequest) request; String token = req.getHeader(\u0026#34;Token\u0026#34;); return token != null; } @Override protected boolean executeLogin(ServletRequest request, ServletResponse response) throws Exception { HttpServletRequest httpServletRequest = (HttpServletRequest) request; String token = httpServletRequest.getHeader(\u0026#34;Token\u0026#34;); JwtToken jwtToken = new JwtToken(token); // 提交给realm进行登入，如果错误他会抛出异常并被捕获 getSubject(request, response).login(jwtToken); // 如果没有抛出异常则代表登入成功，返回true return true; } /** * 将非法请求跳转到 /unauthorized/** */ private void responseError(ServletResponse response, String message) { try { HttpServletResponse httpServletResponse = (HttpServletResponse) response; //设置编码，否则中文字符在重定向时会变为空字符串 message = URLEncoder.encode(message, \u0026#34;UTF-8\u0026#34;); //允许跨域请求 httpServletResponse.setHeader(\u0026#34;Access-Control-Allow-Credentials\u0026#34;, \u0026#34;true\u0026#34;); httpServletResponse.setHeader(\u0026#34;Access-Control-Allow-Methods\u0026#34;, \u0026#34;GET, POST\u0026#34;); httpServletResponse.setHeader(\u0026#34;Access-Control-Allow-Origin\u0026#34;, \u0026#34;*\u0026#34;); httpServletResponse.setHeader(\u0026#34;Access-Control-Max-Age\u0026#34;, \u0026#34;3600\u0026#34;); httpServletResponse.sendRedirect(\u0026#34;/unauthorized/\u0026#34; + message); } catch (IOException e) { log.error(e.getMessage()); } } } 该过滤器有这几大步骤：\n检验请求头是否带有Token 如果带有 token，执行 shiro 的 login() 方法，将 token 提交到 Realm 中进行检验；如果没有 token，说明当前状态为游客状态（或者其他一些不需要进行认证的接口） 如果在 token 校验的过程中出现错误，如 token 校验失败，那么我会将该请求视为认证不通过，则重定向到 /unauthorized/** 自定义Realm 这里主要是进行身份认证和权限认证\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 @Component public class MyRealm extends AuthorizingRealm { @Autowired UserService userService; @Autowired RoleService roleService; @Autowired PermissionService permissionService; @Override public boolean supports(AuthenticationToken token) { return token instanceof JwtToken; } /** * 权限认证 * 只有当需要检测用户权限的时候才会调用此方法，例如checkRole,checkPermission之类的 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { String userName = (String) principals.iterator().next(); Set\u0026lt;String\u0026gt; roles = roleService.getAllRoleByUserName(userName); Set\u0026lt;String\u0026gt; permissions = permissionService.getAllPermissionByUserName(userName); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); info.setRoles(roles); info.setStringPermissions(permissions); return info; } /** * 身份认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { JwtToken jwtToken = (JwtToken) token; String jwtTokenPrincipal = (String) jwtToken.getPrincipal(); String userName = JwtUtil.getAudience(jwtTokenPrincipal); if (userName == null) { throw new AuthenticationException(\u0026#34;token认证失败！\u0026#34;); } try { JwtUtil.verifyToken(jwtTokenPrincipal); } catch (JWTDecodeException e) { throw new AuthenticationException(\u0026#34;不是有效的JWT格式\u0026#34;); } catch (SignatureVerificationException e) { throw new AuthenticationException(\u0026#34;无效的签名\u0026#34;); } catch (TokenExpiredException e) { throw new AuthenticationException(\u0026#34;token已过期\u0026#34;); } User user = userService.getUserByUserName(userName); if (user == null) { throw new AuthenticationException(\u0026#34;该用户不存在！\u0026#34;); } return new SimpleAuthenticationInfo(userName, jwtTokenPrincipal, user.getUserId()); } } 这里有个细节，在Controller中要求进行身份认证时，Shiro会自动把上面doGetAuthenticationInfo方法中返回的Info存起来。这样我们就可以在Controller中调用这里面的值了。\nuserName可以通过(String) SecurityUtils.getSubject().getPrincipal()取出来\nuserId可以通过SecurityUtils.getSubject().getPrincipals().getRealmNames().iterator().next()取出来。当然，这里根据Shiro的设计，SimpleAuthenticationInfo的第三个构造参数应该填入RealmName，用来区分用户该使用哪一个Realm进行验证的。但我这个项目就只有一个Realm，所以在这里就偷了个懒，就没按官方标准来了。\n异常处理 第一个是专门处理身份认证时的异常\n1 2 3 4 5 @ApiOperation(value = \u0026#34;接收未授权错误\u0026#34;, notes = \u0026#34;返回错误信息\u0026#34;) @GetMapping(\u0026#34;/unauthorized/{message}\u0026#34;) public Result unauthorized(@PathVariable String message) { return new Result().setCode(233).setMessage(message); } 第二个则是全局接管Shiro的异常，在其中进行处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @RestControllerAdvice public class ExceptionController { /** * 捕捉shiro的异常 */ @ExceptionHandler(ShiroException.class) public Result handle401(ShiroException e) { Result result = new Result(); result.setCode(666); if(e instanceof UnauthenticatedException){ result.setMessage(\u0026#34;您没有登录！\u0026#34;); }else if(e instanceof UnauthorizedException){ result.setMessage(\u0026#34;您没有权限访问！\u0026#34;); } else { result.setMessage(e.toString()); } return result; } } 解决中文报错 在Shiro1.7版本之后增加了url校验，如果有中文字符就不通过。然而我们项目里返回错误信息就是通过url来实现的。参考这篇文章知道，需要自己重写ShiroFilterFactoryBean来实现关闭url校验\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class CustomShiroFilterFactoryBean extends ShiroFilterFactoryBean { @Override protected FilterChainManager createFilterChainManager() { FilterChainManager manager = super.createFilterChainManager(); // URL携带中文400，servletPath中文校验bug Map\u0026lt;String, Filter\u0026gt; filterMap = manager.getFilters(); Filter invalidRequestFilter = filterMap.get(DefaultFilter.invalidRequest.name()); if (invalidRequestFilter instanceof InvalidRequestFilter) { ((InvalidRequestFilter) invalidRequestFilter).setBlockNonAscii(false); } return manager; } } 开始使用 身份认证在Controller上添加@RequiresAuthentication 角色认证在Controller上添加@RequiresRoles(\u0026quot;xxx\u0026quot;) 权限认证在Controller上添加@RequiresPermissions(\u0026quot;xxx\u0026quot;) 测试 测试接口的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @GetMapping(\u0026#34;/test\u0026#34;) @ResponseBody public Result test() { return new Result().setCode(200).setMessage(\u0026#34;当你看到这段话时，说明服务成功运行了\u0026#34;); } @GetMapping(\u0026#34;/test2\u0026#34;) @ResponseBody @RequiresPermissions(\u0026#34;user:insert\u0026#34;) public Result test2() { return new Result().setCode(200).setMessage(\u0026#34;当你看到这段话时，说明你已经通过了验证\u0026#34;); } @GetMapping(\u0026#34;/test3\u0026#34;) @ResponseBody @RequiresPermissions(\u0026#34;noBody\u0026#34;) public Result test3() { return new Result().setCode(200).setMessage(\u0026#34;当你看到这段话时，说明认证系统出现了问题\u0026#34;); } 参考文章 教你 Shiro + SpringBoot 整合 JWT Shiro步步为营\u0026ndash;如何优雅地与JWT集成 更新日志 2021.11.7：\n增加解决跳转时的跨域请求 更细粒度的展示JWT错误原因 增加SecurityUtils的使用 增加测试接口的代码 ","date":"2021-10-08T15:19:44+08:00","image":"https://lbqaq.top/p/shiro%E6%95%B4%E5%90%88jwt/92388693.webp","permalink":"https://lbqaq.top/p/shiro%E6%95%B4%E5%90%88jwt/","title":"shiro整合JWT"},{"content":"最近看了很久的Vue教程，为了避免之后的遗忘，还是停下脚步，花点时间讲笔记写出来吧。\n这篇笔记是基于B站上的尚硅谷Vue2.0+Vue3.0全套教程而成，在此感谢提供这么优秀的学习教程。\nVue2基础 想要学好Vue，那肯定还是从Vue2开始学起。那么这一章主要是Vue2中的基础内容，没有使用到脚手架。\n初识Vue 每学一个新的语言，HelloWord是必不可少的。话不多说，上代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;!-- 准备好一个容器 --\u0026gt; \u0026lt;div id=\u0026#34;demo\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Hello，{{name.toUpperCase()}}，{{address}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; \u0026gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 //创建Vue实例 new Vue({ el:\u0026#39;#demo\u0026#39;, //el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。 data:{ //data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象。 name:\u0026#39;vue\u0026#39;, address:\u0026#39;北京\u0026#39; } }) \u0026lt;/script\u0026gt; 这样就完成了一个基础的Vue程序。\n1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；\n2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；\n3.root容器里的代码被称为【Vue模板】；\n4.Vue实例和容器是一一对应的；\n5.真实开发中只有一个Vue实例，并且会配合着组件一起使用；\n6.{{xxx}}中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；\n7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；\nVue模板语法 Vue模板语法有2大类：\n1.插值语法：\n​ 功能：用于解析标签体内容。\n​ 写法：{{xxx}}，xxx是js表达式，且可以直接读取到data中的所有属性。\n2.指令语法：\n​ 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件\u0026hellip;..）。\n​ 举例：v-bind:href=\u0026ldquo;xxx\u0026rdquo; 或 简写为 :href=\u0026ldquo;xxx\u0026rdquo;，xxx同样要写js表达式，\n​ 且可以直接读取到data中的所有属性。\n​ 备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。\n其实很好理解，想要显示在页面上的内容就使用{{value}}这样的写法，而v-bind:则是用于html标签中的属性绑定。\n数据绑定 Vue中有2种数据绑定的方式：\n​ 1.单向绑定(v-bind)：数据只能从data流向页面。\n​ 2.双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。\n​ 备注：\n​ 1.双向绑定一般都应用在表单类元素上（如：input、select等）\n​ 2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。\n1 2 3 4 5 6 7 \u0026lt;!-- 普通写法 --\u0026gt; 单向数据绑定：\u0026lt;input type=\u0026#34;text\u0026#34; v-bind:value=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;br/\u0026gt; 双向数据绑定：\u0026lt;input type=\u0026#34;text\u0026#34; v-model:value=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;!-- 简写 --\u0026gt; 单向数据绑定：\u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;br/\u0026gt; 双向数据绑定：\u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;br/\u0026gt; el与data的两种写法 data与el的2种写法\n​ 1.el有2种写法\n​ (1).new Vue时候配置el属性。\n​ (2).先创建Vue实例，随后再通过vm.$mount(\u0026rsquo;#root\u0026rsquo;)指定el的值。\n1 2 3 4 5 6 7 const v = new Vue({ //el:\u0026#39;#root\u0026#39;, //第一种写法 data:{ name:\u0026#39;Vue\u0026#39; } }) v.$mount(\u0026#39;#root\u0026#39;) //第二种写法 ​ 2.data有2种写法\n​ (1).对象式\n​ (2).函数式\n​ 如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 new Vue({ el:\u0026#39;#root\u0026#39;, //data的第一种写法：对象式 /* data:{ name:\u0026#39;Vue\u0026#39; } */ //data的第二种写法：函数式 data(){ console.log(\u0026#39;@@@\u0026#39;,this) //此处的this是Vue实例对象 return{ name:\u0026#39;Vue\u0026#39; } } }) ​ 3.一个重要的原则：\n​ 由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。\n数据代理 在讲Vue中的数据代理之前，先讲一下js中Object.defineproperty方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 let number = 18 let person = { name:\u0026#39;张三\u0026#39;, sex:\u0026#39;男\u0026#39;, } Object.defineProperty(person,\u0026#39;age\u0026#39;,{ // value:18, // enumerable:true, //控制属性是否可以枚举，默认值是false // writable:true, //控制属性是否可以被修改，默认值是false // configurable:true //控制属性是否可以被删除，默认值是false //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值 get(){ console.log(\u0026#39;有人读取age属性了\u0026#39;) return number }, //当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值 set(value){ console.log(\u0026#39;有人修改了age属性，且值是\u0026#39;,value) number = value } }) // 输出person中所有的key // console.log(Object.keys(person)) console.log(person) 通过Object.defineProperty添加进的属性，默认是不可枚举、不可修改、不可删除的，可以通过上面的三条配置项，让其和普通的属性一样。\n所谓数据代理，就是指通过一个对象代理对另一个对象中属性的操作（读/写）。\n1.Vue中的数据代理：\n​ 通过vm对象来代理data对象中属性的操作（读/写）\n2.Vue中数据代理的好处：\n​ 更加方便的操作data中的数据\n3.基本原理：\n​ 通过Object.defineProperty()把data对象中所有属性添加到vm上。\n​ 为每一个添加到vm上的属性，都指定一个getter/setter。\n​ 在getter/setter内部去操作（读/写）data中对应的属性。\n1 2 3 4 5 6 7 const vm = new Vue({ el:\u0026#39;#root\u0026#39;, data:{ name:\u0026#39;Vue\u0026#39;, password:123 } }) 通过在控制台查看vm，可以发现data中的数据都通过数据代理在vm身上了\n事件处理 事件的基本使用：\n​ 1.使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；\n​ 2.事件的回调需要配置在methods对象中，最终会在vm上；\n​ 3.methods中配置的函数，不要用箭头函数！否则this就不是vm了；\n​ 4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；\n​ 5.@click=\u0026ldquo;demo\u0026rdquo; 和 @click=\u0026ldquo;demo($event)\u0026rdquo; 效果一致，但后者可以传参；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;!-- 准备好一个容器--\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Hello,{{name}}\u0026lt;/h2\u0026gt; \u0026lt;!-- \u0026lt;button v-on:click=\u0026#34;showInfo\u0026#34;\u0026gt;点我提示信息\u0026lt;/button\u0026gt; --\u0026gt; \u0026lt;button @click=\u0026#34;showInfo1\u0026#34;\u0026gt;点我提示信息1（不传参）\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;showInfo2($event,66)\u0026#34;\u0026gt;点我提示信息2（传参）\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; const vm = new Vue({ el:\u0026#39;#root\u0026#39;, data:{ name:\u0026#39;Vue\u0026#39;, }, methods:{ showInfo1(event){ // console.log(event.target.innerText) // console.log(this) //此处的this是vm alert(\u0026#39;同学你好！\u0026#39;) }, showInfo2(event,number){ console.log(event,number) // console.log(event.target.innerText) // console.log(this) //此处的this是vm alert(\u0026#39;同学你好！！\u0026#39;) } } }) \u0026lt;/script\u0026gt; Vue中的事件修饰符：\n​ 1.prevent：阻止默认事件（常用）；\n​ 2.stop：阻止事件冒泡（常用）；\n​ 3.once：事件只触发一次（常用）；\n​ 4.capture：使用事件的捕获模式；\n​ 5.self：只有event.target是当前操作的元素时才触发事件；\n​ 6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- 阻止默认事件（常用） --\u0026gt; \u0026lt;a href=\u0026#34;http://www.baidu.com\u0026#34; @click.prevent=\u0026#34;showInfo\u0026#34;\u0026gt;点我提示信息\u0026lt;/a\u0026gt; \u0026lt;!-- 阻止事件冒泡（常用） --\u0026gt; \u0026lt;div class=\u0026#34;demo1\u0026#34; @click=\u0026#34;showInfo\u0026#34;\u0026gt; \u0026lt;button @click.stop=\u0026#34;showInfo\u0026#34;\u0026gt;点我提示信息\u0026lt;/button\u0026gt; \u0026lt;!-- 修饰符可以连续写 --\u0026gt; \u0026lt;!-- \u0026lt;a href=\u0026#34;http://www.baidu.com\u0026#34; @click.prevent.stop=\u0026#34;showInfo\u0026#34;\u0026gt;点我提示信息\u0026lt;/a\u0026gt; --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 事件只触发一次（常用） --\u0026gt; \u0026lt;button @click.once=\u0026#34;showInfo\u0026#34;\u0026gt;点我提示信息\u0026lt;/button\u0026gt; 1.Vue中常用的按键别名：\n​ 回车 =\u0026gt; enter\n​ 删除 =\u0026gt; delete (捕获“删除”和“退格”键)\n​ 退出 =\u0026gt; esc\n​ 空格 =\u0026gt; space\n​ 换行 =\u0026gt; tab (特殊，必须配合keydown去使用)\n​ 上 =\u0026gt; up\n​ 下 =\u0026gt; down\n​ 左 =\u0026gt; left\n​ 右 =\u0026gt; right\n2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）\n3.系统修饰键（用法特殊）：ctrl、alt、shift、meta\n​ (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。\n​ (2).配合keydown使用：正常触发事件。\n4.也可以使用keyCode去指定具体的按键（不推荐）\n5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名\n一般都是@keydown.xxx或者@keyup.xxx来绑定按键\n计算属性 计算属性：\n​ 1.定义：要用的属性不存在，要通过已有属性计算得来。\n​ 2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。\n​ 3.get函数什么时候执行？\n​ (1).初次读取时会执行一次。\n​ (2).当依赖的数据发生改变时会被再次调用。\n​ 4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。\n​ 5.备注：\n​ 1.计算属性最终会出现在vm上，直接读取使用即可。\n​ 2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const vm = new Vue({ el:\u0026#39;#root\u0026#39;, data:{ firstName:\u0026#39;张\u0026#39;, lastName:\u0026#39;三\u0026#39;, x:\u0026#39;你好\u0026#39; }, computed:{ fullName:{ //get有什么作用？当有人读取fullName时，get就会被调用，且返回值就作为fullName的值 //get什么时候调用？1.初次读取fullName时。2.所依赖的数据发生变化时。 get(){ console.log(\u0026#39;get被调用了\u0026#39;) // console.log(this) //此处的this是vm return this.firstName + \u0026#39;-\u0026#39; + this.lastName }, //set什么时候调用? 当fullName被修改时。 set(value){ console.log(\u0026#39;set\u0026#39;,value) const arr = value.split(\u0026#39;-\u0026#39;) this.firstName = arr[0] this.lastName = arr[1] } } } }) 计算属性调用就和普通属性的调用一样，用{{key}}就行了。\n当我们不需要计算属性的set方法时，我们就可以使用简写方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const vm = new Vue({ el:\u0026#39;#root\u0026#39;, data:{ firstName:\u0026#39;张\u0026#39;, lastName:\u0026#39;三\u0026#39;, }, computed:{ //简写 fullName(){ console.log(\u0026#39;get被调用了\u0026#39;) return this.firstName + \u0026#39;-\u0026#39; + this.lastName } } }) 监视属性 监视属性watch：\n1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作\n2.监视的属性必须存在，才能进行监视！！\n3.监视的两种写法：\n​ (1).new Vue时传入watch配置\n​ (2).通过vm.$watch监视\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;!-- 准备好一个容器--\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;今天天气很{{info}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeWeather\u0026#34;\u0026gt;切换天气\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; const vm = new Vue({ el:\u0026#39;#root\u0026#39;, data:{ isHot:true, }, computed:{ info(){ return this.isHot ? \u0026#39;炎热\u0026#39; : \u0026#39;凉爽\u0026#39; } }, methods: { changeWeather(){ this.isHot = !this.isHot } }, /* watch:{ isHot:{ immediate:true, //初始化时让handler调用一下 //handler什么时候调用？当isHot发生改变时。 handler(newValue,oldValue){ console.log(\u0026#39;isHot被修改了\u0026#39;,newValue,oldValue) } } } */ }) vm.$watch(\u0026#39;isHot\u0026#39;,{ immediate:true, //初始化时让handler调用一下 //handler什么时候调用？当isHot发生改变时。 handler(newValue,oldValue){ console.log(\u0026#39;isHot被修改了\u0026#39;,newValue,oldValue) } }) \u0026lt;/script\u0026gt; 深度监视：\n​ (1).Vue中的watch默认不监测对象内部值的改变（一层）。\n​ (2).配置deep:true可以监测对象内部值改变（多层）。\n备注：\n​ (1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！\n​ (2).使用watch时根据数据的具体结构，决定是否采用深度监视。\n计算属性也同样可以简写：\n1 2 3 4 5 6 watch:{ //简写 isHot(newValue,oldValue){ console.log(\u0026#39;isHot被修改了\u0026#39;,newValue,oldValue,this) } } computed和watch之间的区别：\n​ 1.computed能完成的功能，watch都可以完成。\n​ 2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。\n两个重要的小原则：\n​ 1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。\n​ 2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，\n​ 这样this的指向才是vm 或 组件实例对象。\n绑定样式 绑定样式：\nclass样式\n写法:class=\u0026ldquo;xxx\u0026rdquo; xxx可以是字符串、对象、数组。\n字符串写法适用于：类名不确定，要动态获取。\n对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。\n数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。\nstyle样式\n:style=\u0026quot;{fontSize: xxx}\u0026ldquo;其中xxx是动态值。\n:style=\u0026quot;[a,b]\u0026ldquo;其中a、b是样式对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --\u0026gt; \u0026lt;div class=\u0026#34;basic\u0026#34; :class=\u0026#34;mood\u0026#34; @click=\u0026#34;changeMood\u0026#34;\u0026gt;{{name}}\u0026lt;/div\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 --\u0026gt; \u0026lt;div class=\u0026#34;basic\u0026#34; :class=\u0026#34;classArr\u0026#34;\u0026gt;{{name}}\u0026lt;/div\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --\u0026gt; \u0026lt;div class=\u0026#34;basic\u0026#34; :class=\u0026#34;classObj\u0026#34;\u0026gt;{{name}}\u0026lt;/div\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;!-- 绑定style样式--对象写法 --\u0026gt; \u0026lt;div class=\u0026#34;basic\u0026#34; :style=\u0026#34;styleObj\u0026#34;\u0026gt;{{name}}\u0026lt;/div\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;!-- 绑定style样式--数组写法 --\u0026gt; \u0026lt;div class=\u0026#34;basic\u0026#34; :style=\u0026#34;styleArr\u0026#34;\u0026gt;{{name}}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; Vue.config.productionTip = false const vm = new Vue({ el:\u0026#39;#root\u0026#39;, data:{ name:\u0026#39;尚硅谷\u0026#39;, mood:\u0026#39;normal\u0026#39;, classArr:[\u0026#39;atguigu1\u0026#39;,\u0026#39;atguigu2\u0026#39;,\u0026#39;atguigu3\u0026#39;], classObj:{ atguigu1:false, atguigu2:false, }, styleObj:{ fontSize: \u0026#39;40px\u0026#39;, color:\u0026#39;red\u0026#39;, }, styleObj2:{ backgroundColor:\u0026#39;orange\u0026#39; }, styleArr:[ { fontSize: \u0026#39;40px\u0026#39;, color:\u0026#39;blue\u0026#39;, }, { backgroundColor:\u0026#39;gray\u0026#39; } ] }, methods: { changeMood(){ const arr = [\u0026#39;happy\u0026#39;,\u0026#39;sad\u0026#39;,\u0026#39;normal\u0026#39;] const index = Math.floor(Math.random()*3) this.mood = arr[index] } }, }) \u0026lt;/script\u0026gt; 条件渲染 条件渲染：\n​ 1.v-if\n​ 写法：\n​ (1).v-if=\u0026ldquo;表达式\u0026rdquo;\n​ (2).v-else-if=\u0026ldquo;表达式\u0026rdquo;\n​ (3).v-else=\u0026ldquo;表达式\u0026rdquo;\n​ 适用于：切换频率较低的场景。\n​ 特点：不展示的DOM元素直接被移除。\n​ 注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。\n​ 2.v-show\n​ 写法：v-show=\u0026ldquo;表达式\u0026rdquo;\n​ 适用于：切换频率较高的场景。\n​ 特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉\n​ 3.备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!-- 使用v-show做条件渲染 --\u0026gt; \u0026lt;h2 v-show=\u0026#34;false\u0026#34;\u0026gt;欢迎来到{{name}}\u0026lt;/h2\u0026gt; \u0026lt;h2 v-show=\u0026#34;1 === 1\u0026#34;\u0026gt;欢迎来到{{name}}\u0026lt;/h2\u0026gt; \u0026lt;!-- 使用v-if做条件渲染 --\u0026gt; \u0026lt;h2 v-if=\u0026#34;1 === 1\u0026#34;\u0026gt;欢迎来到{{name}}\u0026lt;/h2\u0026gt; \u0026lt;h2 v-if=\u0026#34;false\u0026#34;\u0026gt;欢迎来到{{name}}\u0026lt;/h2\u0026gt; \u0026lt;!-- v-else和v-else-if --\u0026gt; \u0026lt;div v-if=\u0026#34;n === 1\u0026#34;\u0026gt;Angular\u0026lt;/div\u0026gt; \u0026lt;div v-else-if=\u0026#34;n === 2\u0026#34;\u0026gt;React\u0026lt;/div\u0026gt; \u0026lt;div v-else-if=\u0026#34;n === 3\u0026#34;\u0026gt;Vue\u0026lt;/div\u0026gt; \u0026lt;div v-else\u0026gt;哈哈\u0026lt;/div\u0026gt; \u0026lt;!-- v-if与template的配合使用 --\u0026gt; \u0026lt;template v-if=\u0026#34;n === 1\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;你好\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;尚硅谷\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;北京\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; 列表渲染 基本列表 v-for指令:\n​ 1.用于展示列表数据\n​ 2.语法：v-for=\u0026quot;(item, index) in xxx\u0026rdquo; :key=\u0026ldquo;yyy\u0026rdquo;\n​ 3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \u0026lt;!-- 遍历数组 --\u0026gt; \u0026lt;h2\u0026gt;人员列表（遍历数组）\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(p,index) of persons\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt; {{p.name}}-{{p.age}} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;!-- 遍历对象 --\u0026gt; \u0026lt;h2\u0026gt;汽车信息（遍历对象）\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(value,k) of car\u0026#34; :key=\u0026#34;k\u0026#34;\u0026gt; {{k}}-{{value}} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;!-- 遍历字符串 --\u0026gt; \u0026lt;h2\u0026gt;测试遍历字符串（用得少）\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(char,index) of str\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt; {{char}}-{{index}} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;!-- 遍历指定次数 --\u0026gt; \u0026lt;h2\u0026gt;测试遍历指定次数（用得少）\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(number,index) of 5\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt; {{index}}-{{number}} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; new Vue({ el:\u0026#39;#root\u0026#39;, data:{ persons:[ {id:\u0026#39;001\u0026#39;,name:\u0026#39;张三\u0026#39;,age:18}, {id:\u0026#39;002\u0026#39;,name:\u0026#39;李四\u0026#39;,age:19}, {id:\u0026#39;003\u0026#39;,name:\u0026#39;王五\u0026#39;,age:20} ], car:{ name:\u0026#39;奥迪A8\u0026#39;, price:\u0026#39;70万\u0026#39;, color:\u0026#39;黑色\u0026#39; }, str:\u0026#39;hello\u0026#39; } }) \u0026lt;/script\u0026gt; 面试题：react、vue中的key有什么作用？（key的内部原理）\n虚拟DOM中key的作用： ​ key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】,\n​ 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：\n​ 2.对比规则：\n​ (1).旧虚拟DOM中找到了与新虚拟DOM相同的key：\n​ ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！\n​ ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。\n​ (2).旧虚拟DOM中未找到与新虚拟DOM相同的key\n​ 创建新的真实DOM，随后渲染到到页面。\n​ 3. 用index作为key可能会引发的问题：\n​ 1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作:\n​ 会产生没有必要的真实DOM更新 ==\u0026gt; 界面效果没问题, 但效率低。\n​ 2. 如果结构中还包含输入类的DOM：\n​ 会产生错误DOM更新 ==\u0026gt; 界面有问题。\n​ 4. 开发中如何选择key?:\n​ 1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。\n​ 2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，\n​ 使用index作为key是没有问题的。\n列表过滤 可以通过watch或者computed实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 \u0026lt;!-- 准备好一个容器--\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;人员列表\u0026lt;/h2\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;请输入名字\u0026#34; v-model=\u0026#34;keyWord\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(p,index) of filPerons\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt; {{p.name}}-{{p.age}}-{{p.sex}} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; Vue.config.productionTip = false //用watch实现 //#region new Vue({ el:\u0026#39;#root\u0026#39;, data:{ keyWord:\u0026#39;\u0026#39;, persons:[ {id:\u0026#39;001\u0026#39;,name:\u0026#39;马冬梅\u0026#39;,age:19,sex:\u0026#39;女\u0026#39;}, {id:\u0026#39;002\u0026#39;,name:\u0026#39;周冬雨\u0026#39;,age:20,sex:\u0026#39;女\u0026#39;}, {id:\u0026#39;003\u0026#39;,name:\u0026#39;周杰伦\u0026#39;,age:21,sex:\u0026#39;男\u0026#39;}, {id:\u0026#39;004\u0026#39;,name:\u0026#39;温兆伦\u0026#39;,age:22,sex:\u0026#39;男\u0026#39;} ], filPerons:[] }, watch:{ keyWord:{ immediate:true, handler(val){ this.filPerons = this.persons.filter((p)=\u0026gt;{ return p.name.indexOf(val) !== -1 }) } } } }) //#endregion //用computed实现 new Vue({ el:\u0026#39;#root\u0026#39;, data:{ keyWord:\u0026#39;\u0026#39;, persons:[ {id:\u0026#39;001\u0026#39;,name:\u0026#39;马冬梅\u0026#39;,age:19,sex:\u0026#39;女\u0026#39;}, {id:\u0026#39;002\u0026#39;,name:\u0026#39;周冬雨\u0026#39;,age:20,sex:\u0026#39;女\u0026#39;}, {id:\u0026#39;003\u0026#39;,name:\u0026#39;周杰伦\u0026#39;,age:21,sex:\u0026#39;男\u0026#39;}, {id:\u0026#39;004\u0026#39;,name:\u0026#39;温兆伦\u0026#39;,age:22,sex:\u0026#39;男\u0026#39;} ] }, computed:{ filPerons(){ return this.persons.filter((p)=\u0026gt;{ return p.name.indexOf(this.keyWord) !== -1 }) } } }) \u0026lt;/script\u0026gt; 列表排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;!-- 准备好一个容器--\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;人员列表\u0026lt;/h2\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;请输入名字\u0026#34; v-model=\u0026#34;keyWord\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;sortType = 2\u0026#34;\u0026gt;年龄升序\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;sortType = 1\u0026#34;\u0026gt;年龄降序\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;sortType = 0\u0026#34;\u0026gt;原顺序\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(p,index) of filPerons\u0026#34; :key=\u0026#34;p.id\u0026#34;\u0026gt; {{p.name}}-{{p.age}}-{{p.sex}} \u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; Vue.config.productionTip = false new Vue({ el:\u0026#39;#root\u0026#39;, data:{ keyWord:\u0026#39;\u0026#39;, sortType:0, //0原顺序 1降序 2升序 persons:[ {id:\u0026#39;001\u0026#39;,name:\u0026#39;马冬梅\u0026#39;,age:30,sex:\u0026#39;女\u0026#39;}, {id:\u0026#39;002\u0026#39;,name:\u0026#39;周冬雨\u0026#39;,age:31,sex:\u0026#39;女\u0026#39;}, {id:\u0026#39;003\u0026#39;,name:\u0026#39;周杰伦\u0026#39;,age:18,sex:\u0026#39;男\u0026#39;}, {id:\u0026#39;004\u0026#39;,name:\u0026#39;温兆伦\u0026#39;,age:19,sex:\u0026#39;男\u0026#39;} ] }, computed:{ filPerons(){ const arr = this.persons.filter((p)=\u0026gt;{ return p.name.indexOf(this.keyWord) !== -1 }) //判断一下是否需要排序 if(this.sortType){ arr.sort((p1,p2)=\u0026gt;{ return this.sortType === 1 ? p2.age-p1.age : p1.age-p2.age }) } return arr } } }) \u0026lt;/script\u0026gt; Vue监视数据的原理：\nvue会监视data中所有层次的数据。\n如何监测对象中的数据？\n​ 通过setter实现监视，且要在new Vue时就传入要监测的数据。\n​ (1).对象中后追加的属性，Vue默认不做响应式处理\n​ (2).如需给后添加的属性做响应式，请使用如下API：\n​ Vue.set(target，propertyName/index，value) 或\n​ vm.$set(target，propertyName/index，value)\n如何监测数组中的数据？ ​ 通过包裹数组更新元素的方法实现，本质就是做了两件事：\n​ (1).调用原生对应的方法对数组进行更新。\n​ (2).重新解析模板，进而更新页面。\n4.在Vue修改数组中的某个元素一定要用如下方法：\n​ 1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()\n​ 2.Vue.set() 或 vm.$set()\n特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！\n收集表单数据 若：\u0026lt;input type=\u0026quot;text\u0026quot;/\u0026gt;，则v-model收集的是value值，用户输入的就是value值。\n若：\u0026lt;input type=\u0026quot;radio\u0026quot;/\u0026gt;，则v-model收集的是value值，且要给标签配置value值。\n若：\u0026lt;input type=\u0026quot;checkbox\u0026quot;/\u0026gt;\n​ 1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）\n​ 2.配置input的value属性:\n​ (1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）\n​ (2)v-model的初始值是数组，那么收集的的就是value组成的数组\n备注：v-model的三个修饰符：\n​ lazy：失去焦点再收集数据\n​ number：输入字符串转为有效的数字\n​ trim：输入首尾空格过滤\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;form @submit.prevent=\u0026#34;demo\u0026#34;\u0026gt; 账号：\u0026lt;input type=\u0026#34;text\u0026#34; v-model.trim=\u0026#34;userInfo.account\u0026#34;\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; 密码：\u0026lt;input type=\u0026#34;password\u0026#34; v-model=\u0026#34;userInfo.password\u0026#34;\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; 年龄：\u0026lt;input type=\u0026#34;number\u0026#34; v-model.number=\u0026#34;userInfo.age\u0026#34;\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; 性别： 男\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; v-model=\u0026#34;userInfo.sex\u0026#34; value=\u0026#34;male\u0026#34;\u0026gt; 女\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; v-model=\u0026#34;userInfo.sex\u0026#34; value=\u0026#34;female\u0026#34;\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; 爱好： 学习\u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;userInfo.hobby\u0026#34; value=\u0026#34;study\u0026#34;\u0026gt; 打游戏\u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;userInfo.hobby\u0026#34; value=\u0026#34;game\u0026#34;\u0026gt; 吃饭\u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;userInfo.hobby\u0026#34; value=\u0026#34;eat\u0026#34;\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; 所属校区 \u0026lt;select v-model=\u0026#34;userInfo.city\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;\u0026#34;\u0026gt;请选择校区\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;beijing\u0026#34;\u0026gt;北京\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;shanghai\u0026#34;\u0026gt;上海\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;shenzhen\u0026#34;\u0026gt;深圳\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;wuhan\u0026#34;\u0026gt;武汉\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; 其他信息： \u0026lt;textarea v-model.lazy=\u0026#34;userInfo.other\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;userInfo.agree\u0026#34;\u0026gt;阅读并接受\u0026lt;a href=\u0026#34;http://www.atguigu.com\u0026#34;\u0026gt;《用户协议》\u0026lt;/a\u0026gt; \u0026lt;button\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt; new Vue({ el:\u0026#39;#root\u0026#39;, data:{ userInfo:{ account:\u0026#39;\u0026#39;, password:\u0026#39;\u0026#39;, age:18, sex:\u0026#39;female\u0026#39;, hobby:[], city:\u0026#39;beijing\u0026#39;, other:\u0026#39;\u0026#39;, agree:\u0026#39;\u0026#39; } }, methods: { demo(){ console.log(JSON.stringify(this.userInfo)) } } }) \u0026lt;/script\u0026gt; 过滤器 过滤器：\n定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。\n语法：\n​ 1.注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}\n​ 2.使用过滤器：{{ xxx | 过滤器名}} 或 v-bind:属性 = \u0026ldquo;xxx | 过滤器名\u0026rdquo;\n备注：\n​ 1.过滤器也可以接收额外参数、多个过滤器也可以串联\n​ 2.并没有改变原本的数据, 是产生新的对应的数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;显示格式化后的时间\u0026lt;/h2\u0026gt; \u0026lt;!-- 计算属性实现 --\u0026gt; \u0026lt;h3\u0026gt;现在是：{{fmtTime}}\u0026lt;/h3\u0026gt; \u0026lt;!-- methods实现 --\u0026gt; \u0026lt;h3\u0026gt;现在是：{{getFmtTime()}}\u0026lt;/h3\u0026gt; \u0026lt;!-- 过滤器实现 --\u0026gt; \u0026lt;h3\u0026gt;现在是：{{time | timeFormater}}\u0026lt;/h3\u0026gt; \u0026lt;!-- 过滤器实现（传参） --\u0026gt; \u0026lt;h3\u0026gt;现在是：{{time | timeFormater(\u0026#39;YYYY_MM_DD\u0026#39;) | mySlice}}\u0026lt;/h3\u0026gt; \u0026lt;h3 :x=\u0026#34;msg | mySlice\u0026#34;\u0026gt;尚硅谷\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;root2\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;{{msg | mySlice}}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.filter(\u0026#39;mySlice\u0026#39;,function(value){ return value.slice(0,4) }) new Vue({ el:\u0026#39;#root\u0026#39;, data:{ time:1621561377603, //时间戳 msg:\u0026#39;你好，尚硅谷\u0026#39; }, computed: { fmtTime(){ return dayjs(this.time).format(\u0026#39;YYYY年MM月DD日 HH:mm:ss\u0026#39;) } }, methods: { getFmtTime(){ return dayjs(this.time).format(\u0026#39;YYYY年MM月DD日 HH:mm:ss\u0026#39;) } }, //局部过滤器 filters:{ timeFormater(value,str=\u0026#39;YYYY年MM月DD日 HH:mm:ss\u0026#39;){ // console.log(\u0026#39;@\u0026#39;,value) return dayjs(value).format(str) } } }) new Vue({ el:\u0026#39;#root2\u0026#39;, data:{ msg:\u0026#39;hello,atguigu!\u0026#39; } }) \u0026lt;/script\u0026gt; 内置指令 我们学过的指令：\n​ v-bind : 单向绑定解析表达式, 可简写为 :xxx\n​ v-model : 双向数据绑定\n​ v-for : 遍历数组/对象/字符串\n​ v-on : 绑定事件监听, 可简写为@\n​ v-if : 条件渲染（动态控制节点是否存存在）\n​ v-else : 条件渲染（动态控制节点是否存存在）\n​ v-show : 条件渲染 (动态控制节点是否展示)\nv-text指令：\n​ 1.作用：向其所在的节点中渲染文本内容。\n​ 2.与插值语法的区别：v-text会替换掉节点中的内容，{{xx}}则不会。\nv-html指令：\n​ 1.作用：向指定节点中渲染包含html结构的内容。\n​ 2.与插值语法的区别：\n​ (1).v-html会替换掉节点中所有的内容，{{xx}}则不会。\n​ (2).v-html可以识别html结构。\n​ 3.严重注意：v-html有安全性问题！！！！\n​ (1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。\n​ (2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！\nv-cloak指令（没有值）：\n​ 1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。\n​ 2.使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题。\nv-once指令：\n​ 1.v-once所在节点在初次动态渲染后，就视为静态内容了。\n​ 2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。\nv-pre指令：\n​ 1.跳过其所在节点的编译过程。\n​ 2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。\n生命周期 话不多说先上图：\n生命周期：\n​ 1.又名：生命周期回调函数、生命周期函数、生命周期钩子。\n​ 2.是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。\n​ 3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。\n​ 4.生命周期函数中的this指向是vm 或 组件实例对象。\n常用的生命周期钩子：\n​ 1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。\n​ 2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。\n关于销毁Vue实例\n​ 1.销毁后借助Vue开发者工具看不到任何信息。\n​ 2.销毁后自定义事件会失效，但原生DOM事件依然有效。\n​ 3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。\n组件 Vue中使用组件的三大步骤：\n​ 一、定义组件(创建组件)\n​ 二、注册组件\n​ 三、使用组件(写组件标签)\n一、如何定义一个组件？\n​ 使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；\n​ 区别如下：\n​ 1.el不要写，为什么？ ——— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。\n​ 2.data必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。\n​ 备注：使用template可以配置组件结构。\n二、如何注册组件？\n​ 1.局部注册：靠new Vue的时候传入components选项\n​ 2.全局注册：靠Vue.component(\u0026lsquo;组件名\u0026rsquo;,组件)\n三、编写组件标签：\n​ \u0026lt;school\u0026gt;\u0026lt;/school\u0026gt;\n几个注意点：\n​ 1.关于组件名:\n​ 一个单词组成：\n​ 第一种写法(首字母小写)：school\n​ 第二种写法(首字母大写)：School\n​ 多个单词组成：\n​ 第一种写法(kebab-case命名)：my-school\n​ 第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)\n​ 备注：\n​ (1).组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。\n​ (2).可以使用name配置项指定组件在开发者工具中呈现的名字。\n​ 2.关于组件标签:\n​ 第一种写法：\n​ 第二种写法：\n​ 备注：不用使用脚手架时，会导致后续组件不能渲染。\n​ 3.一个简写方式：\n​ const school = Vue.extend(options) 可简写为：const school = options\n关于VueComponent：\n​ 1.school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。\n​ 2.我们只需要写或，Vue解析时会帮我们创建school组件的实例对象，\n​ 即Vue帮我们执行的：new VueComponent(options)。\n​ 3.特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！\n​ 4.关于this指向：\n​ (1).组件配置中：\n​ data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。\n​ (2).new Vue(options)配置中：\n​ data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。\n​ 5.VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。\n​ Vue的实例对象，以后简称vm。\nVue2进阶 到这一部分，就要使用到脚手架了，同时也向正式的项目靠近了。\n脚手架文件结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ├── node_modules ├── public │ ├── favicon.ico: 页签图标 │ └── index.html: 主页面 ├── src │ ├── assets: 存放静态资源 │ │ └── logo.png │ │── component: 存放组件 │ │ └── HelloWorld.vue │ │── App.vue: 汇总所有组件 │ │── main.js: 入口文件 ├── .gitignore: git版本管制忽略的配置 ├── babel.config.js: babel的配置文件 ├── package.json: 应用包配置文件 ├── README.md: 应用描述文件 ├── package-lock.json：包版本控制文件 关于不同版本的Vue vue.js与vue.runtime.xxx.js的区别： vue.js是完整版的Vue，包含：核心功能 + 模板解析器。 vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。 因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。也就是代码中的这句render: h =\u0026gt; h(App) vue.config.js配置文件 使用vue inspect \u0026gt; output.js可以查看到Vue脚手架的默认配置。 使用vue.config.js可以对脚手架进行个性化定制，详情见：https://cli.vuejs.org/zh ref属性 被用来给元素或子组件注册引用信息（id的替代者） 应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc） 使用方式： 打标识：\u0026lt;h1 ref=\u0026quot;xxx\u0026quot;\u0026gt;.....\u0026lt;/h1\u0026gt; 或 \u0026lt;School ref=\u0026quot;xxx\u0026quot;\u0026gt;\u0026lt;/School\u0026gt; 获取：this.$refs.xxx props配置项 功能：让组件接收外部传过来的数据\n传递数据：\u0026lt;Demo name=\u0026quot;xxx\u0026quot;/\u0026gt;\n接收数据：\n第一种方式（只接收）：props:['name'] 第二种方式（限制类型）：props:{name:String}\n第三种方式（限制类型、限制必要性、指定默认值）：\n1 2 3 4 5 6 7 props:{ name:{ type:String, //类型 required:true, //必要性 default:\u0026#39;老王\u0026#39; //默认值 } } 备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。\nmixin(混入) 功能：可以把多个组件共用的配置提取成一个混入对象\n使用方式：\n第一步定义混合：\n1 2 3 4 5 { data(){....}, methods:{....} .... } 第二步使用混入：\n​\t全局混入：Vue.mixin(xxx) ​\t局部混入：mixins:['xxx']\t插件 功能：用于增强Vue\n本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。\n定义插件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 对象.install = function (Vue, options) { // 1. 添加全局过滤器 Vue.filter(....) // 2. 添加全局指令 Vue.directive(....) // 3. 配置全局混入(合) Vue.mixin(....) // 4. 添加实例方法 Vue.prototype.$myMethod = function () {...} Vue.prototype.$myProperty = xxxx } 使用插件：Vue.use()\nscoped样式 作用：让样式在局部生效，防止冲突。 写法：\u0026lt;style scoped\u0026gt; 总结TodoList案例 组件化编码流程：\n​\t(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。\n​\t(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：\n​\t1).一个组件在用：放在组件自身即可。\n​\t2). 一些组件在用：放在他们共同的父组件上（状态提升）。\n​\t(3).实现交互：从绑定事件开始。\nprops适用于：\n​\t(1).父组件 ==\u0026gt; 子组件 通信\n​\t(2).子组件 ==\u0026gt; 父组件 通信（要求父先给子一个函数）\n使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！\nprops传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。\nwebStorage 存储内容大小一般支持5MB左右（不同浏览器可能还不一样）\n浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。\n相关API：\nxxxxxStorage.setItem('key', 'value'); 该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。\nxxxxxStorage.getItem('person');\n​\t该方法接受一个键名作为参数，返回键名对应的值。\nxxxxxStorage.removeItem('key');\n​\t该方法接受一个键名作为参数，并把该键名从存储中删除。\nxxxxxStorage.clear()\n​\t该方法会清空存储中的所有数据。\n备注：\nSessionStorage存储的内容会随着浏览器窗口关闭而消失。 LocalStorage存储的内容，需要手动清除才会消失。 xxxxxStorage.getItem(xxx)如果xxx对应的value获取不到，那么getItem的返回值是null。 JSON.parse(null)的结果依然是null。 组件的自定义事件 一种组件间通信的方式，适用于：子组件 ===\u0026gt; 父组件\n使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中）。\n绑定自定义事件：\n第一种方式，在父组件中：\u0026lt;Demo @atguigu=\u0026quot;test\u0026quot;/\u0026gt; 或 \u0026lt;Demo v-on:atguigu=\u0026quot;test\u0026quot;/\u0026gt;\n第二种方式，在父组件中：\n1 2 3 4 5 \u0026lt;Demo ref=\u0026#34;demo\u0026#34;/\u0026gt; ...... mounted(){ this.$refs.xxx.$on(\u0026#39;atguigu\u0026#39;,this.test) } 若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法。\n触发自定义事件：this.$emit('atguigu',数据)\n解绑自定义事件this.$off('atguigu')\n组件上也可以绑定原生DOM事件，需要使用native修饰符。\n注意：通过this.$refs.xxx.$on('atguigu',回调)绑定自定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出问题！\n全局事件总线（GlobalEventBus） 一种组件间通信的方式，适用于任意组件间通信。\n安装全局事件总线：\n1 2 3 4 5 6 7 new Vue({ ...... beforeCreate() { Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm }, ...... }) 使用事件总线：\n接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。\n1 2 3 4 5 6 7 methods(){ demo(data){......} } ...... mounted() { this.$bus.$on(\u0026#39;xxxx\u0026#39;,this.demo) } 提供数据：this.$bus.$emit('xxxx',数据)\n最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件。\n消息订阅与发布（pubsub） 一种组件间通信的方式，适用于任意组件间通信。\n使用步骤：\n安装pubsub：npm i pubsub-js\n引入: import pubsub from 'pubsub-js'\n接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身。\n1 2 3 4 5 6 7 methods(){ demo(data){......} } ...... mounted() { this.pid = pubsub.subscribe(\u0026#39;xxx\u0026#39;,this.demo) //订阅消息 } 提供数据：pubsub.publish('xxx',数据)\n最好在beforeDestroy钩子中，用PubSub.unsubscribe(pid)去取消订阅。\nnextTick 语法：this.$nextTick(回调函数) 作用：在下一次 DOM 更新结束后执行其指定的回调。 什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。 Vue封装的过度与动画 作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。\n图示：\n写法：\n准备好样式：\n元素进入的样式： v-enter：进入的起点 v-enter-active：进入过程中 v-enter-to：进入的终点 元素离开的样式： v-leave：离开的起点 v-leave-active：离开过程中 v-leave-to：离开的终点 使用\u0026lt;transition\u0026gt;包裹要过度的元素，并配置name属性：\n1 2 3 \u0026lt;transition name=\u0026#34;hello\u0026#34;\u0026gt; \u0026lt;h1 v-show=\u0026#34;isShow\u0026#34;\u0026gt;你好啊！\u0026lt;/h1\u0026gt; \u0026lt;/transition\u0026gt; 备注：若有多个元素需要过度，则需要使用：\u0026lt;transition-group\u0026gt;，且每个元素都要指定key值。\nvue脚手架配置代理 方法一 ​\t在vue.config.js中添加如下配置：\n1 2 3 devServer:{ proxy:\u0026#34;http://localhost:5000\u0026#34; } 说明：\n优点：配置简单，请求资源时直接发给前端（8080）即可。 缺点：不能配置多个代理，不能灵活的控制请求是否走代理。 工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源） 方法二 ​\t编写vue.config.js配置具体代理规则：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 module.exports = { devServer: { proxy: { \u0026#39;/api1\u0026#39;: {// 匹配所有以 \u0026#39;/api1\u0026#39;开头的请求路径 target: \u0026#39;http://localhost:5000\u0026#39;,// 代理目标的基础路径 changeOrigin: true, pathRewrite: {\u0026#39;^/api1\u0026#39;: \u0026#39;\u0026#39;} }, \u0026#39;/api2\u0026#39;: {// 匹配所有以 \u0026#39;/api2\u0026#39;开头的请求路径 target: \u0026#39;http://localhost:5001\u0026#39;,// 代理目标的基础路径 changeOrigin: true, pathRewrite: {\u0026#39;^/api2\u0026#39;: \u0026#39;\u0026#39;} } } } } /* changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000 changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080 changeOrigin默认值为true */ 说明：\n优点：可以配置多个代理，且可以灵活的控制请求是否走代理。 缺点：配置略微繁琐，请求资源时必须加前缀。 插槽 作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 父组件 ===\u0026gt; 子组件 。\n分类：默认插槽、具名插槽、作用域插槽\n使用方式：\n默认插槽：\n1 2 3 4 5 6 7 8 9 10 11 父组件中： \u0026lt;Category\u0026gt; \u0026lt;div\u0026gt;html结构1\u0026lt;/div\u0026gt; \u0026lt;/Category\u0026gt; 子组件中： \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 定义插槽 --\u0026gt; \u0026lt;slot\u0026gt;插槽默认内容...\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 具名插槽：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 父组件中： \u0026lt;Category\u0026gt; \u0026lt;template slot=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;div\u0026gt;html结构1\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:footer\u0026gt; \u0026lt;div\u0026gt;html结构2\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Category\u0026gt; 子组件中： \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 定义插槽 --\u0026gt; \u0026lt;slot name=\u0026#34;center\u0026#34;\u0026gt;插槽默认内容...\u0026lt;/slot\u0026gt; \u0026lt;slot name=\u0026#34;footer\u0026#34;\u0026gt;插槽默认内容...\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 作用域插槽：\n理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）\n具体编码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 父组件中： \u0026lt;Category\u0026gt; \u0026lt;template scope=\u0026#34;scopeData\u0026#34;\u0026gt; \u0026lt;!-- 生成的是ul列表 --\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;g in scopeData.games\u0026#34; :key=\u0026#34;g\u0026#34;\u0026gt;{{g}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Category\u0026gt; \u0026lt;Category\u0026gt; \u0026lt;template slot-scope=\u0026#34;scopeData\u0026#34;\u0026gt; \u0026lt;!-- 生成的是h4标题 --\u0026gt; \u0026lt;h4 v-for=\u0026#34;g in scopeData.games\u0026#34; :key=\u0026#34;g\u0026#34;\u0026gt;{{g}}\u0026lt;/h4\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Category\u0026gt; 子组件中： \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;slot :games=\u0026#34;games\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name:\u0026#39;Category\u0026#39;, props:[\u0026#39;title\u0026#39;], //数据在子组件自身 data() { return { games:[\u0026#39;红色警戒\u0026#39;,\u0026#39;穿越火线\u0026#39;,\u0026#39;劲舞团\u0026#39;,\u0026#39;超级玛丽\u0026#39;] } }, } \u0026lt;/script\u0026gt; Vuex 概念 ​\t在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。\n何时使用？ ​\t多个组件需要共享数据时\n搭建vuex环境 创建文件：src/store/index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //引入Vue核心库 import Vue from \u0026#39;vue\u0026#39; //引入Vuex import Vuex from \u0026#39;vuex\u0026#39; //应用Vuex插件 Vue.use(Vuex) //准备actions对象——响应组件中用户的动作 const actions = {} //准备mutations对象——修改state中的数据 const mutations = {} //准备state对象——保存具体的数据 const state = {} //创建并暴露store export default new Vuex.Store({ actions, mutations, state }) 在main.js中创建vm时传入store配置项\n1 2 3 4 5 6 7 8 9 10 11 ...... //引入store import store from \u0026#39;./store\u0026#39; ...... //创建vm new Vue({ el:\u0026#39;#app\u0026#39;, render: h =\u0026gt; h(App), store }) 基本使用 初始化数据、配置actions、配置mutations，操作文件store.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 //引入Vue核心库 import Vue from \u0026#39;vue\u0026#39; //引入Vuex import Vuex from \u0026#39;vuex\u0026#39; //引用Vuex Vue.use(Vuex) const actions = { //响应组件中加的动作 jia(context,value){ // console.log(\u0026#39;actions中的jia被调用了\u0026#39;,miniStore,value) context.commit(\u0026#39;JIA\u0026#39;,value) }, } const mutations = { //执行加 JIA(state,value){ // console.log(\u0026#39;mutations中的JIA被调用了\u0026#39;,state,value) state.sum += value } } //初始化数据 const state = { sum:0 } //创建并暴露store export default new Vuex.Store({ actions, mutations, state, }) 组件中读取vuex中的数据：$store.state.sum\n组件中修改vuex中的数据：$store.dispatch('action中的方法名',数据) 或 $store.commit('mutations中的方法名',数据)\n备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写dispatch，直接编写commit\ngetters的使用 概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。\n在store.js中追加getters配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 ...... const getters = { bigSum(state){ return state.sum * 10 } } //创建并暴露store export default new Vuex.Store({ ...... getters }) 组件中读取数据：$store.getters.bigSum\n四个map方法的使用 mapState方法：用于帮助我们映射state中的数据为计算属性\n1 2 3 4 5 6 7 computed: { //借助mapState生成计算属性：sum、school、subject（对象写法） ...mapState({sum:\u0026#39;sum\u0026#39;,school:\u0026#39;school\u0026#39;,subject:\u0026#39;subject\u0026#39;}), //借助mapState生成计算属性：sum、school、subject（数组写法） ...mapState([\u0026#39;sum\u0026#39;,\u0026#39;school\u0026#39;,\u0026#39;subject\u0026#39;]), }, mapGetters方法：用于帮助我们映射getters中的数据为计算属性\n1 2 3 4 5 6 7 computed: { //借助mapGetters生成计算属性：bigSum（对象写法） ...mapGetters({bigSum:\u0026#39;bigSum\u0026#39;}), //借助mapGetters生成计算属性：bigSum（数组写法） ...mapGetters([\u0026#39;bigSum\u0026#39;]) }, mapActions方法：用于帮助我们生成与actions对话的方法，即：包含$store.dispatch(xxx)的函数\n1 2 3 4 5 6 7 methods:{ //靠mapActions生成：incrementOdd、incrementWait（对象形式） ...mapActions({incrementOdd:\u0026#39;jiaOdd\u0026#39;,incrementWait:\u0026#39;jiaWait\u0026#39;}) //靠mapActions生成：incrementOdd、incrementWait（数组形式） ...mapActions([\u0026#39;jiaOdd\u0026#39;,\u0026#39;jiaWait\u0026#39;]) } mapMutations方法：用于帮助我们生成与mutations对话的方法，即：包含$store.commit(xxx)的函数\n1 2 3 4 5 6 7 methods:{ //靠mapActions生成：increment、decrement（对象形式） ...mapMutations({increment:\u0026#39;JIA\u0026#39;,decrement:\u0026#39;JIAN\u0026#39;}), //靠mapMutations生成：JIA、JIAN（对象形式） ...mapMutations([\u0026#39;JIA\u0026#39;,\u0026#39;JIAN\u0026#39;]), } 备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。\n模块化+命名空间 目的：让代码更好维护，让多种数据分类更加明确。\n修改store.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 const countAbout = { namespaced:true,//开启命名空间 state:{x:1}, mutations: { ... }, actions: { ... }, getters: { bigSum(state){ return state.sum * 10 } } } const personAbout = { namespaced:true,//开启命名空间 state:{ ... }, mutations: { ... }, actions: { ... } } const store = new Vuex.Store({ modules: { countAbout, personAbout } }) 开启命名空间后，组件中读取state数据：\n1 2 3 4 //方式一：自己直接读取 this.$store.state.personAbout.list //方式二：借助mapState读取： ...mapState(\u0026#39;countAbout\u0026#39;,[\u0026#39;sum\u0026#39;,\u0026#39;school\u0026#39;,\u0026#39;subject\u0026#39;]), 开启命名空间后，组件中读取getters数据：\n1 2 3 4 //方式一：自己直接读取 this.$store.getters[\u0026#39;personAbout/firstPersonName\u0026#39;] //方式二：借助mapGetters读取： ...mapGetters(\u0026#39;countAbout\u0026#39;,[\u0026#39;bigSum\u0026#39;]) 开启命名空间后，组件中调用dispatch\n1 2 3 4 //方式一：自己直接dispatch this.$store.dispatch(\u0026#39;personAbout/addPersonWang\u0026#39;,person) //方式二：借助mapActions： ...mapActions(\u0026#39;countAbout\u0026#39;,{incrementOdd:\u0026#39;jiaOdd\u0026#39;,incrementWait:\u0026#39;jiaWait\u0026#39;}) 开启命名空间后，组件中调用commit\n1 2 3 4 //方式一：自己直接commit this.$store.commit(\u0026#39;personAbout/ADD_PERSON\u0026#39;,person) //方式二：借助mapMutations： ...mapMutations(\u0026#39;countAbout\u0026#39;,{increment:\u0026#39;JIA\u0026#39;,decrement:\u0026#39;JIAN\u0026#39;}), 路由 理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。 前端路由：key是路径，value是组件。 基本使用 安装vue-router，命令：npm i vue-router\n应用插件：Vue.use(VueRouter)\n编写router配置项:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //引入VueRouter import VueRouter from \u0026#39;vue-router\u0026#39; //引入Luyou 组件 import About from \u0026#39;../components/About\u0026#39; import Home from \u0026#39;../components/Home\u0026#39; //创建router实例对象，去管理一组一组的路由规则 const router = new VueRouter({ routes:[ { path:\u0026#39;/about\u0026#39;, component:About }, { path:\u0026#39;/home\u0026#39;, component:Home } ] }) //暴露router export default router 实现切换（active-class可配置高亮样式）\n1 \u0026lt;router-link active-class=\u0026#34;active\u0026#34; to=\u0026#34;/about\u0026#34;\u0026gt;About\u0026lt;/router-link\u0026gt; 指定展示位置\n1 \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; 几个注意点 路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹。 通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。 每个组件都有自己的$route属性，里面存储着自己的路由信息。 整个应用只有一个router，可以通过组件的$router属性获取到。 多级路由（多级路由） 配置路由规则，使用children配置项：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 routes:[ { path:\u0026#39;/about\u0026#39;, component:About, }, { path:\u0026#39;/home\u0026#39;, component:Home, children:[ //通过children配置子级路由 { path:\u0026#39;news\u0026#39;, //此处一定不要写：/news component:News }, { path:\u0026#39;message\u0026#39;,//此处一定不要写：/message component:Message } ] } ] 跳转（要写完整路径）：\n1 \u0026lt;router-link to=\u0026#34;/home/news\u0026#34;\u0026gt;News\u0026lt;/router-link\u0026gt; 路由的query参数 传递参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!-- 跳转并携带query参数，to的字符串写法 --\u0026gt; \u0026lt;router-link :to=\u0026#34;/home/message/detail?id=666\u0026amp;title=你好\u0026#34;\u0026gt;跳转\u0026lt;/router-link\u0026gt; \u0026lt;!-- 跳转并携带query参数，to的对象写法 --\u0026gt; \u0026lt;router-link :to=\u0026#34;{ path:\u0026#39;/home/message/detail\u0026#39;, query:{ id:666, title:\u0026#39;你好\u0026#39; } }\u0026#34; \u0026gt;跳转\u0026lt;/router-link\u0026gt; 接收参数：\n1 2 $route.query.id $route.query.title 命名路由 作用：可以简化路由的跳转。\n如何使用\n给路由命名：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { path:\u0026#39;/demo\u0026#39;, component:Demo, children:[ { path:\u0026#39;test\u0026#39;, component:Test, children:[ { name:\u0026#39;hello\u0026#39; //给路由命名 path:\u0026#39;welcome\u0026#39;, component:Hello, } ] } ] } 简化跳转：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!--简化前，需要写完整的路径 --\u0026gt; \u0026lt;router-link to=\u0026#34;/demo/test/welcome\u0026#34;\u0026gt;跳转\u0026lt;/router-link\u0026gt; \u0026lt;!--简化后，直接通过名字跳转 --\u0026gt; \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;hello\u0026#39;}\u0026#34;\u0026gt;跳转\u0026lt;/router-link\u0026gt; \u0026lt;!--简化写法配合传递参数 --\u0026gt; \u0026lt;router-link :to=\u0026#34;{ name:\u0026#39;hello\u0026#39;, query:{ id:666, title:\u0026#39;你好\u0026#39; } }\u0026#34; \u0026gt;跳转\u0026lt;/router-link\u0026gt; 路由的params参数 配置路由，声明接收params参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { path:\u0026#39;/home\u0026#39;, component:Home, children:[ { path:\u0026#39;news\u0026#39;, component:News }, { component:Message, children:[ { name:\u0026#39;xiangqing\u0026#39;, path:\u0026#39;detail/:id/:title\u0026#39;, //使用占位符声明接收params参数 component:Detail } ] } ] } 传递参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!-- 跳转并携带params参数，to的字符串写法 --\u0026gt; \u0026lt;router-link :to=\u0026#34;/home/message/detail/666/你好\u0026#34;\u0026gt;跳转\u0026lt;/router-link\u0026gt; \u0026lt;!-- 跳转并携带params参数，to的对象写法 --\u0026gt; \u0026lt;router-link :to=\u0026#34;{ name:\u0026#39;xiangqing\u0026#39;, params:{ id:666, title:\u0026#39;你好\u0026#39; } }\u0026#34; \u0026gt;跳转\u0026lt;/router-link\u0026gt; 特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！\n接收参数：\n1 2 $route.params.id $route.params.title 路由的props配置 ​\t作用：让路由组件更方便的收到参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { name:\u0026#39;xiangqing\u0026#39;, path:\u0026#39;detail/:id\u0026#39;, component:Detail, //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件 // props:{a:900} //第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件 // props:true //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件 props(route){ return { id:route.query.id, title:route.query.title } } } \u0026lt;router-link\u0026gt;的replace属性 作用：控制路由跳转时操作浏览器历史记录的模式 浏览器的历史记录有两种写入方式：分别为push和replace，push是追加历史记录，replace是替换当前记录。路由跳转时候默认为push 如何开启replace模式：\u0026lt;router-link replace .......\u0026gt;News\u0026lt;/router-link\u0026gt; 编程式路由导航 作用：不借助\u0026lt;router-link\u0026gt; 实现路由跳转，让路由跳转更加灵活\n具体编码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //$router的两个API this.$router.push({ name:\u0026#39;xiangqing\u0026#39;, params:{ id:xxx, title:xxx } }) this.$router.replace({ name:\u0026#39;xiangqing\u0026#39;, params:{ id:xxx, title:xxx } }) this.$router.forward() //前进 this.$router.back() //后退 this.$router.go() //可前进也可后退 缓存路由组件 作用：让不展示的路由组件保持挂载，不被销毁。\n具体编码：\n1 2 3 \u0026lt;keep-alive include=\u0026#34;News\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/keep-alive\u0026gt; 两个新的生命周期钩子 作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。 具体名字： activated路由组件被激活时触发。 deactivated路由组件失活时触发。 路由守卫 作用：对路由进行权限控制\n分类：全局守卫、独享守卫、组件内守卫\n全局守卫:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //全局前置守卫：初始化时执行、每次路由切换前执行 router.beforeEach((to,from,next)=\u0026gt;{ console.log(\u0026#39;beforeEach\u0026#39;,to,from) if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制 if(localStorage.getItem(\u0026#39;school\u0026#39;) === \u0026#39;atguigu\u0026#39;){ //权限控制的具体规则 next() //放行 }else{ alert(\u0026#39;暂无权限查看\u0026#39;) // next({name:\u0026#39;guanyu\u0026#39;}) } }else{ next() //放行 } }) //全局后置守卫：初始化时执行、每次路由切换后执行 router.afterEach((to,from)=\u0026gt;{ console.log(\u0026#39;afterEach\u0026#39;,to,from) if(to.meta.title){ document.title = to.meta.title //修改网页的title }else{ document.title = \u0026#39;vue_test\u0026#39; } }) 独享守卫:\n1 2 3 4 5 6 7 8 9 10 11 12 13 beforeEnter(to,from,next){ console.log(\u0026#39;beforeEnter\u0026#39;,to,from) if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制 if(localStorage.getItem(\u0026#39;school\u0026#39;) === \u0026#39;atguigu\u0026#39;){ next() }else{ alert(\u0026#39;暂无权限查看\u0026#39;) // next({name:\u0026#39;guanyu\u0026#39;}) } }else{ next() } } 组件内守卫：\n1 2 3 4 5 6 //进入守卫：通过路由规则，进入该组件时被调用 beforeRouteEnter (to, from, next) { }, //离开守卫：通过路由规则，离开该组件时被调用 beforeRouteLeave (to, from, next) { } 路由器的两种工作模式 对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。\nhash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。\nhash模式：\n地址中永远带着#号，不美观 。 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。 兼容性较好。 history模式：\n地址干净，美观 。 兼容性和hash模式相比略差。 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。 ","date":"2021-09-22T08:21:14+08:00","image":"https://lbqaq.top/p/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/88417243.webp","permalink":"https://lbqaq.top/p/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Vue学习笔记"},{"content":"最近做项目需要前后端分离，所以需要接口文档给前端方便联调。手写文档是不可能的，这时就需要使用Swagger了。网上的教程大部分版本都在2.x甚至是1.x，很少有3.0的教程，我个人就是喜欢用最新版，所以我就来分享一下我使用Swagger3的体验和坑吧。\n配置 这里就分享springboot版本的方法了，现在的项目应该都用springboot创建了吧。\n导入Maven依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在启动类上加上@EnableOpenApi就行了。\n当然，这样只是默认的，我们要用肯定要配置一下，我们去创建一个Config类，在里面建立一个函数返回Docket类，我们所有的配置就在这个Docket类里配置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Configuration @EnableOpenApi public class SwaggerConfig { @Bean public Docket docket(){ return new Docket(DocumentationType.OAS_30)\t//3.0版本用OAS_30这个标准 .apiInfo(getApiInfo()) .select() //扫描指定包下的接口 .apis(RequestHandlerSelectors.basePackage(\u0026#34;top.lbqaq.controller\u0026#34;)) .build(); } /** * 配置swagger信息 */ private ApiInfo getApiInfo(){ //这里是作者信息，分别为姓名、个人主页、邮箱 Contact contact = new Contact(\u0026#34;luoboQAQ\u0026#34;,\u0026#34;https://lbqaq.top\u0026#34;,\u0026#34;123@xx.com\u0026#34;); return new ApiInfo( \u0026#34;项目名\u0026#34;, \u0026#34;项目描述\u0026#34;, \u0026#34;版本\u0026#34;, \u0026#34;项目主页\u0026#34;, contact, \u0026#34;Apache 2.0\u0026#34;, \u0026#34;https://www.apache.org/licenses/LICENSE-2.0\u0026#34;, new ArrayList()); } } 这样一个带有个人信息的配置页就做好了。\n注解 首先是2.0版本的注解，当然新版本也同样通用。\nSwagger注解 简单说明 @Api(tags = \u0026ldquo;xxx模块说明\u0026rdquo;) 作用在模块类上 @ApiOperation(\u0026ldquo;xxx接口说明\u0026rdquo;) 作用在接口方法上 @ApiModel(\u0026ldquo;xxxPOJO说明\u0026rdquo;) 作用在模型类上：如VO、BO @ApiModelProperty(value = \u0026ldquo;xxx属性说明\u0026rdquo;,hidden = true) 作用在类方法和属性上，hidden设置为true可以隐藏该属性 @ApiParam(\u0026ldquo;xxx参数说明\u0026rdquo;) 作用在参数、方法和字段上，类似@ApiModelProperty 既然用了3.0，也就可以使用3.0的新注释。\n先放上官网链接：\nSwagger注解 SpringFox文档 Swagger是底层，实现是由SpringFox来完成的，所以有些在Swagger文档里的注解放到SpringFox里就无法实现，比如@RequestBody这个注解就无法实现。下面就列举我测试过可以成功的注解：\n在方法上进行注释\n1 2 3 @Operation(summary = \u0026#34;这会显示在主页上\u0026#34;, description = \u0026#34;这显示在内页里\u0026#34;, tags = {\u0026#34;test\u0026#34;})\t//会将接口分类出去 在参数上注释\n1 @Parameter(description = \u0026#34;这里是描述\u0026#34;, required = true) 只测了这么多，之前为了测试@RequestBody花了太多时间，结果一无所获。因为2.0的注解还能用，这里就挖个坑，等之后有时间再来完善吧。\n","date":"2021-09-09T15:09:04+08:00","image":"https://lbqaq.top/p/swagger/92079701.webp","permalink":"https://lbqaq.top/p/swagger/","title":"Swagger3初体验"},{"content":"每次写完博客，需要在本地编译，然后再手动通过WinSCP送到服务器上。作为一个懒人，这上面几步下来还是觉得麻烦，而且每次编译又会生成一顿不需要的文件，于是便决定整点自动化的流程，直接解放双手。\n因为我的博客在没买服务器之前都是托管在Github上的，于是自然而然地就想到了Webhook，在每次Push后自动发送消息给服务器，让其自动拉取代码。\n网上的教程大多都是在本地编译，然而我觉得既然要懒，就一懒到底吧，编译也直接通过Github Actions来完成就行了。\n流程 需要2个Github仓库（1个应该也可以），一个存放网站的源码，一个是存放编译好的html文件。整个工作流程就如下图所示：\n步骤 设置脚本 首先要写一个shell脚本，功能很简单就是自动拉取代码。\n1 2 3 #!/bin/bash cd /home/luobo/Blog git pull 创建webhook服务后端 这里就直接使用NodeJS来创建，使用的原因很简单，因为已经有现成的插件可以使用了。\n首先安装依赖\n1 2 npm i -S github-webhook-handler npm i -g pm2 然后创建webhook.js作为后端\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 var http = require(\u0026#39;http\u0026#39;); var spawn = require(\u0026#39;child_process\u0026#39;).spawn; var createHandler = require(\u0026#39;github-webhook-handler\u0026#39;); //注意要将 secret 修改你自己的 var handler = createHandler({ path: \u0026#39;/webhook\u0026#39;, secret: \u0026#39;xxxxx\u0026#39; }); http.createServer(function (req, res) { handler(req, res, function (err) { res.statusCode = 404; res.end(\u0026#39;no such location\u0026#39;); }) }).listen(6666); handler.on(\u0026#39;error\u0026#39;, function (err) { console.error(\u0026#39;Error:\u0026#39;, err.message) }); handler.on(\u0026#39;push\u0026#39;, function (event) { console.log(\u0026#39;Received a push event for %s to %s\u0026#39;, event.payload.repository.name, event.payload.ref); runCommand(\u0026#39;sh\u0026#39;, [\u0026#39;./deploy.sh\u0026#39;], function( txt ){ console.log(txt); }); }); function runCommand( cmd, args, callback ){ var child = spawn( cmd, args ); var resp = \u0026#39;Deploy OK\u0026#39;; child.stdout.on(\u0026#39;data\u0026#39;, function( buffer ){ resp += buffer.toString(); }); child.stdout.on(\u0026#39;end\u0026#39;, function(){ callback( resp ) }); } 最后启动服务即可\n1 pm2 start webhook.js Nginx设置反代 1 2 3 location /webhook { proxy_pass http://127.0.0.1:6666; } 配置Github Webhook 在 html仓库的 Settings - webhooks 设置中创建一个新的 webhook。\n将Content Type 设置为 application/json，secret 设置成与 webhook.js 中的相同。\ntrigeer选择Just the push event. 。\n完成后Github会自动发起一个测试请求，如果返回为200说明配置完成，\n配置自动编译 在源代码仓库的.github/workflows目录下创建deploy.yml，并填入以下内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 name: Build and Deploy on: [push] # 任务 jobs: build-and-deploy: # 服务器环境：最新版 Ubuntu runs-on: ubuntu-latest steps: # 拉取代码 - name: Checkout uses: actions/checkout@v2 # 安装Hugo - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: latest extended: true - name: Build run: hugo # 部署到 GitHub Pages - name: Deploy to GitHub Pages uses: JamesIves/github-pages-deploy-action@4.1.4 with: BRANCH: main FOLDER: public token: ${{ secrets.GP_TOKEN }} repository-name: luoboQAQ/luoboQAQ.github.io 注意要将最后的repository-name换为你自己的仓库，同时需要申请和配置Github Token，这里我就不展开了。\n参考 使用 GitHub Webhook 实现静态网站自动化部署 ","date":"2021-08-23T15:44:59+08:00","image":"https://lbqaq.top/p/%E4%BD%BF%E7%94%A8webhooks%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/90550307.webp","permalink":"https://lbqaq.top/p/%E4%BD%BF%E7%94%A8webhooks%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/","title":"使用Webhooks实现自动部署"},{"content":"一个完整的博客，怎么能少的了评论系统呢。评论的实现已经有许许多多的方法了，挑来挑去，还是选择了Waline。\n一开始我是采用官方推荐的LeanCloud+Vercel的方式进行部署的，结果步骤全部走完后才发现Vercel已经在国内被墙了，不科学根本上不去😇。总不能要求用户还要开梯子才能评论吧，所幸官方提供了其他的部署方式，因为我才买了自己的服务器~~（不榨干怎么行呢）~~，所以就选择本地部署+SQLlite的方式了。\n部署步骤 安装node.js 由于Waline的服务端是由js写的，所以需要安装node.js\n在nodejs中文网找到需要的版本，选择阿里云镜像，将下载链接复制下来\n连接服务器，选择nodejs的安装目录，这里我安装在/usr/local/bin/\n1 cd /usr/local/bin/ 下载安装包到本地\n1 wget https://npm.taobao.org/mirrors/node/v14.17.5/node-v14.17.5-linux-x64.tar.gz 解压\n1 tar -xvf node-v14.17.5-linux-x64.tar.gz 重命名目录\n1 mv node-v14.17.5-linux-x64 nodejs 添加目录到系统变量\n1 2 cd /etc/profile.d vim custom.sh 在文件末尾添加export PATH=$PATH:/usr/local/bin/nodejs/bin\n测试，输入下面3条命令，如果不报错则安装成功。\n1 2 3 node -v npm version npx -v （可选）安装cnpm\n1 npm install -g cnpm --registry=https://registry.npm.taobao.org 安装Waline服务端 安装waline的服务端\n1 npm install -g @waline/vercel 配置数据库。这里我采用的是SQLite，只需要下载 waline.sqlite 文件至合适的位置。\n其他的数据库可以看官方文档来配置。\n配置环境变量。\n这里我选择新建waline.sh，方便日后维护。\n1 2 3 4 cd /etc/profile.d vim waline.sh export SQLITE_PATH=/home/luobo export JWT_TOKEN=eqdVMaEwd SQLITE_PATH：表示SQLite文件的位置。 JWT_TOKEN：随机一串字符串就行。 启动模块\n1 2 cd /usr/local/bin/nodejs/lib node node_modules/@waline/vercel/vanilla.js 配置nginx反代 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #waline server { listen 80; listen 443 ssl http2; server_name waline.lbqaq.top; if ($server_port !~ 443){ rewrite ^(/.*)$ https://$host$1 permanent; } ssl_certificate cert/waline.lbqaq.top.pem; ssl_certificate_key cert/waline.lbqaq.top.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { proxy_pass http://127.0.0.1:8360; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header REMOTE-HOST $remote_addr; add_header X-Cache $upstream_cache_status; # cache add_header Cache-Control no-cache; expires 12h; } } 在hugo中启用Waline 由于我用的主题已经支持Waline评论，所以只需要填入serverURL就行了。\n添加QQ推送（可选） 官方提供了四种通知方法，分别为邮箱、微信、QQ、Telegram。\n邮箱基本不会去看，Telegram没科学也上不去，微信由于是走的Server酱，没有捐赠一天就支持5条消息。\n最终还是决定采用Qmsg 酱。\n注册就不在这展开了，具体写一下环境变量的配置。\n1 2 3 4 5 6 7 cd /etc/profile.d vim waline.sh export QMSG_KEY=xxxxxx export QQ_ID=xxxxxx export AUTHOR_EMAIL=xxxxxxx export SITE_NAME=Blog export SITE_URL=lbqaq.top 踩坑 本以为启用评论是一件很简单的事，结果花了整个下午加晚上，踩了好多好多坑。在这里就把我踩的坑记录下来，避免之后出现一样的问题。\nnpm install -g @waline/vercel报错\n使用cnpm进行安装\n2021/10/21更新：\n更新系统后再尝试安装无论是npm还是cnpm都无法安装，故使用Docker进行安装和运行\n1 2 3 4 5 6 7 8 9 10 11 12 docker run -d \\ -e SQLITE_PATH=/data \\ -e JWT_TOKEN=xxx \\ -e QMSG_KEY=xxxx \\ -e QQ_ID=123 \\ -e AUTHOR_EMAIL=xxx@xx.com \\ -e SITE_NAME=Blog \\ -e SITE_URL=lbqaq.top \\ -p 8360:8360 \\ -v /home/admin/waline:/data \\ --name=waline \\ lizheming/waline 想使用lbqaq.top/waline/这样的链接来设置服务端\n直接报404错误，还是选择上文中的子域名方法\nnginx提示没找到http2模块\n在安装nginx时加上--with-http_v2_module如果已经安装好了，可以重新安装一遍\n设置了server_name waline.lbqaq.top还是跳转首页\n增加一个默认的server，将所有不匹配的链接阻止\n1 2 3 4 5 server { listen 80 default_server; server_name _; return 444; } nginx配置不生效\n如果配置没有问题，除了nginx -s reload还可以尝试重启nginx\n参考链接 Waline官方文档 nginx中文文档 ","date":"2021-08-21T15:37:44+08:00","image":"https://lbqaq.top/p/waline/78502982.webp","permalink":"https://lbqaq.top/p/waline/","title":"为博客添加评论系统"},{"content":"SpringMVC也告一段落了，终于要到SpringBoot了。\n还是和之前一样，笔记是基于遇见狂神说的SpringMVC视频教程而来，在此感谢能提供这么优秀的教程。\n回顾MVC 什么是MVC MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 将业务逻辑、数据、显示分离的方法来组织代码。 **Model（模型）：**数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。\n拓展：在前端数据传输给后端时，有些字段是不需要的，这是可能会细分出Vo层（视图）\n比如：用户有账号、密码、年龄等一系列字段\n这时前端登录只传了账号密码\n此时可以用UserVo来表示，里面只有账号和密码\n**View（视图）：**负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。\n**Controller（控制器）：**接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。\n最典型的MVC就是JSP + servlet + javabean的模式。\n用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面 职责分析：\nController：控制器\n取得表单数据 调用业务逻辑 转向指定的页面 Model：模型\n业务逻辑 保存数据的状态 View：视图\n显示页面 复习Servlet 父工程添加依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.13\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet.jsp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsp-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jstl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 编写Servlet\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取前端操作 String method = req.getParameter(\u0026#34;method\u0026#34;); if (method.equals(\u0026#34;add\u0026#34;)){ req.getSession().setAttribute(\u0026#34;msg\u0026#34;,\u0026#34;执行了add方法\u0026#34;); } if (method.equals(\u0026#34;delete\u0026#34;)){ req.getSession().setAttribute(\u0026#34;msg\u0026#34;,\u0026#34;执行了delete方法\u0026#34;); } //调用业务层 //视图转发或重定向 req.getRequestDispatcher(\u0026#34;/WEB-INF/jsp/test.jsp\u0026#34;).forward(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 编写test.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建test.jsp\n1 2 3 4 5 6 7 8 9 \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ${msg} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在web.xml中注册Servlet\n1 2 3 4 5 6 7 8 9 \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;hello\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;top.lbqaq.servlet.HelloServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;hello\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/hello\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; 配置TomCat，进行测试\nMVC框架要做哪些事情\n将url映射到java类或java类的方法 . 封装用户提交的数据 . 处理请求\u0026ndash;调用相关的业务处理\u0026ndash;封装响应数据 . 将响应的数据进行渲染 . jsp / html 等表示层数据 . 说明：\n​\t常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等\u0026hellip;.\n什么是SpringMVC 概述 Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。\n中文文档\n我们为什么要学习SpringMVC呢?\nSpring MVC的特点：\n轻量级，简单易学 高效 , 基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 功能强大：RESTful、数据验证、格式化、本地化、主题等 简洁灵活 中心控制器 ​\tSpring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。\n​\tSpring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。\nSpringMVC的原理如下图所示：\n​\t当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。\nSpringMVC执行原理 图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。\n简要分析执行流程\nDispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。\n我们假设请求的url为 : http://localhost:8080/SpringMVC/hello\n如上url拆分成三部分：\nhttp://localhost:8080服务器域名\nSpringMVC部署在服务器上的web站点\nhello表示控制器\n通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。\nHandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。\nHandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。\nHandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。\nHandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。\nHandler让具体的Controller执行。\nController将具体的执行信息返回给HandlerAdapter,如ModelAndView。\nHandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。\nDispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。\n视图解析器将解析的逻辑视图名传给DispatcherServlet。\nDispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。\n最终视图呈现给用户。\n这里比较绕，所以直接把原文搬来了，之后等理解加深了再来补充自己的看法。\n第一个SpringMVC程序 由于我们是采用子模块的方式，那么需要去IDEA里设置一下让lib会打包出去。否则就会提示404错误。\n在点击IDEA右上角的小齿轮，选择项目结构，在工件下看WEB-INF里是否有lib目录，没有的话就创建一个，然后点击+号，选择库文件将所有的包导入进去。\n配置版 准备要看的视图。在WEB-INF目录下创建jsp目录，在里面创建test.jsp，填入${msg}\n配置SpringMVC。在web.xml里添加下面的代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;!--配置DispatchServlet：这是SpringMVC的核心：请求分发器、前端控制器--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--DispatchServlet要绑定Spring的配置文件--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--启动级别1：随服务器一起启动--\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 备注：/和/*的区别：/匹配所有请求，不匹配jsp页面；/*会匹配jsp页面，这样会导致嵌套，一般不会用\n编写SpringMVC的配置文件springmvc-servlet.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--处理器映射器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\u0026#34;/\u0026gt; \u0026lt;!--处理器适配器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\u0026#34;/\u0026gt; \u0026lt;!--视图解析器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;!--前缀--\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34;/\u0026gt; \u0026lt;!--后缀--\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 实现Controller接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package top.lbqaq.Controller; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class HelloController implements Controller { @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { ModelAndView mv = new ModelAndView(); //业务代码 String result = \u0026#34;HelloSpringMVC\u0026#34;; mv.addObject(\u0026#34;msg\u0026#34;,result); //视图跳转 mv.setViewName(\u0026#34;test\u0026#34;); return mv; } } 将Controller在Spring中注册(springmvc-servlet.xml)\n1 2 \u0026lt;!--BeanNameUrlHandlerMapping:按BeanName匹配--\u0026gt; \u0026lt;bean id=\u0026#34;/hello\u0026#34; class=\u0026#34;top.lbqaq.Controller.HelloController\u0026#34;/\u0026gt; 运行TomCat查看结果\n然而正常开发并不会使用这样的方式，这样做只是为了理解底层的操作。_(:з)∠)_\n注解版 配置Web.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;!--配置DispatchServlet：这是SpringMVC的核心：请求分发器、前端控制器--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--DispatchServlet要绑定Spring的配置文件--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--启动级别1：随服务器一起启动；越小级别越高--\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; 还是老样子，这里没有什么需要改动的。\n在resources目录下添加SpringMVC配置文件springmvc-servlet.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\u0026#34;\u0026gt; \u0026lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;top.lbqaq.controller\u0026#34;/\u0026gt; \u0026lt;!-- 让Spring MVC不处理静态资源 --\u0026gt; \u0026lt;mvc:default-servlet-handler /\u0026gt; \u0026lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --\u0026gt; \u0026lt;mvc:annotation-driven /\u0026gt; \u0026lt;!-- 视图解析器 --\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;!-- 前缀 --\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34; /\u0026gt; \u0026lt;!-- 后缀 --\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 创建Controller\n1 2 3 4 5 6 7 8 9 @Controller public class HelloController { @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(Model model){ //封装数据 model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;Hello,SpringMVCAnnotation!\u0026#34;); return \u0026#34;hello\u0026#34;; //会被视图解析器处理 } } @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。 创建视图层，在WEB-INF/jsp目录中创建hello.jsp\n1 2 3 4 5 6 7 8 9 \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ${msg} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 运行TomCat查看结果\n小结 实现步骤其实非常的简单：\n新建一个web项目 导入相关jar包 编写web.xml , 注册DispatcherServlet 编写springmvc配置文件 接下来就是去创建对应的控制类 , controller 最后完善前端视图和controller之间的对应 测试运行调试. 使用springMVC必须配置的三大件：\n处理器映射器、处理器适配器、视图解析器\n通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置\nRestFul风格 概念\nRestful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。\n功能\n资源：互联网所有的事物都可以被抽象为资源\n资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。\n分别对应 添加、 删除、修改、查询。\n传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get\n​\thttp://127.0.0.1/item/queryItem.action?id=1 查询,GET\n​\thttp://127.0.0.1/item/saveItem.action 新增,POST\n​\thttp://127.0.0.1/item/updateItem.action 更新,POST\n​\thttp://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST\n使用RESTful操作资源 ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！\n​\thttp://127.0.0.1/item/1 查询,GET\n​\thttp://127.0.0.1/item 新增,POST\n​\thttp://127.0.0.1/item 更新,PUT\n​\thttp://127.0.0.1/item/1 删除,DELETE\n使用方法\n创建一个类RestFulController\n1 2 3 4 5 6 7 8 9 10 11 12 @Controller public class RestFulController { //原来的：localhost:8085/add?a=1\u0026amp;b=2 //Restful:localhost:8085/add/1/2 @RequestMapping(\u0026#34;/add/{a}/{b}\u0026#34;) public String test1(@PathVariable int a,@PathVariable int b, Model model){ int res = a+b; model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;结果为\u0026#34;+res); return \u0026#34;test\u0026#34;; } } @RequestMapping里面的{a}就代表这里是传给a变量的值；下面的a变量前要加@PathVariable\n使用路径变量的好处？\n使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。 我们也可以进行方法约束，让其只响应某一种请求\n1 2 3 4 5 @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping 拿@GetMapping来说，就是@RequestMapping(method =RequestMethod.GET)意思，如果使用其他的方法，将会报405错误。\n重定向和转发 重定向不需要视图解析器，本质就是重新请求一个新地方。\n可以重定向到另外一个请求实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Controller public class ResultSpringMVC2 { @RequestMapping(\u0026#34;/rsm2/t1\u0026#34;) public String test1(){ //转发 return \u0026#34;test\u0026#34;; } @RequestMapping(\u0026#34;/rsm2/t2\u0026#34;) public String test2(){ //重定向 return \u0026#34;redirect:/index.jsp\u0026#34;; //return \u0026#34;redirect:hello.do\u0026#34;; //hello.do为另一个请求/ } } 数据处理 处理提交数据 1、提交的域名称和处理方法的参数名一致\n提交数据 : http://localhost:8080/hello?name=lbqaq\n处理方法 :\n1 2 3 4 5 @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(String name){ System.out.println(name); return \u0026#34;hello\u0026#34;; } 后台输出 : lbqaq\n2、提交的域名称和处理方法的参数名不一致\n提交数据 : http://localhost:8080/hello?username=lbqaq\n处理方法 :\n1 2 3 4 5 6 //@RequestParam(\u0026#34;username\u0026#34;) : username提交的域的名称 . @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(@RequestParam(\u0026#34;username\u0026#34;) String name){ System.out.println(name); return \u0026#34;hello\u0026#34;; } 后台输出 : lbqaq\n3、提交的是一个对象\n要求提交的表单域和对象的属性名一致 , 参数使用对象即可\n1、实体类\n1 2 3 4 5 6 7 8 public class User { private int id; private String name; private int age; //构造 //get/set //tostring() } 2、提交数据 : http://localhost:8080/mvc04/user?name=lbqaq\u0026amp;id=1\u0026amp;age=15\n3、处理方法 :\n1 2 3 4 5 @RequestMapping(\u0026#34;/user\u0026#34;) public String user(User user){ System.out.println(user); return \u0026#34;hello\u0026#34;; } 后台输出 : User { id=1, name=\u0026lsquo;lbqaq\u0026rsquo;, age=15 }\n说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。\n数据显示到前端 第一种 : 通过ModelAndView\n我们前面一直都是如此 . 就不过多解释\n1 2 3 4 5 6 7 8 9 10 public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\u0026#34;msg\u0026#34;,\u0026#34;ControllerTest1\u0026#34;); mv.setViewName(\u0026#34;test\u0026#34;); return mv; } } 第二种 : 通过ModelMap\nModelMap\n1 2 3 4 5 6 7 8 @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(@RequestParam(\u0026#34;username\u0026#34;) String name, ModelMap model){ //封装要显示到视图中的数据 //相当于req.setAttribute(\u0026#34;name\u0026#34;,name); model.addAttribute(\u0026#34;name\u0026#34;,name); System.out.println(name); return \u0026#34;hello\u0026#34;; } 第三种 : 通过Model\nModel\n1 2 3 4 5 6 7 8 @RequestMapping(\u0026#34;/ct2/hello\u0026#34;) public String hello(@RequestParam(\u0026#34;username\u0026#34;) String name, Model model){ //封装要显示到视图中的数据 //相当于req.setAttribute(\u0026#34;name\u0026#34;,name); model.addAttribute(\u0026#34;msg\u0026#34;,name); System.out.println(name); return \u0026#34;test\u0026#34;; } 对比 就对于新手而言简单来说使用区别就是：\nModel 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解； ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性； ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。 当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。\n这里都是概念性的内容，所以就直接复制笔记了😌\n解决乱码 直接把Spring的乱码处理器放入web.xml里\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; JSON JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 使用Jackson 导入依赖\n1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.12.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 编写Controller\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Controller public class UserController { @RequestMapping(\u0026#34;/json1\u0026#34;) @ResponseBody public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\u0026#34;小明\u0026#34;, 3, \u0026#34;男\u0026#34;); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; } 如果出现乱码，可以指定编码格式为UTF8来解决\n@RequestMapping(value = \u0026quot;/json1\u0026quot;,produces = \u0026quot;application/json;charset=utf-8\u0026quot;)\n这样处理乱码还是太麻烦了，可以让Spring统一管理，在SpringMVC的配置文件里加上下面的代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;mvc:annotation-driven\u0026gt; \u0026lt;mvc:message-converters register-defaults=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.StringHttpMessageConverter\u0026#34;\u0026gt; \u0026lt;constructor-arg value=\u0026#34;UTF-8\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;objectMapper\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;failOnEmptyBeans\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt; 在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @RestController public class UserController { //produces:指定响应体返回类型和编码 @RequestMapping(value = \u0026#34;/json1\u0026#34;) public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\u0026#34;小明\u0026#34;, 3, \u0026#34;男\u0026#34;); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; } } 自定义工具类，可以是JSON转换变得更简单\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class JsonUtils { public static String getJson(Object object) { return getJson(object,\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); } public static String getJson(Object object,String dateFormat) { ObjectMapper mapper = new ObjectMapper(); //不使用时间差的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //指定日期格式 mapper.setDateFormat(sdf); try { return mapper.writeValueAsString(object); } catch (JsonProcessingException e) { e.printStackTrace(); } return null; } } 使用FastJson 1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.78\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 为了使@RestController有效，需要在Spring配置里加上下面的内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;mvc:annotation-driven\u0026gt; \u0026lt;mvc:message-converters register-defaults=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;!-- 配置Fastjson支持 --\u0026gt; \u0026lt;bean class=\u0026#34;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;supportedMediaTypes\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;application/json\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;text/html;charset=UTF-8\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt; fastjson 三个主要的类：\nJSONObject 代表 json 对象\nJSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。 JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取\u0026quot;键：值\u0026quot;对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。 JSONArray 代表 json 对象数组\n内部是有List接口中的方法来完成操作的。 JSON代表 JSONObject和JSONArray的转化\nJSON类源码分析与使用 仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。 测试代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class FastJsonDemo { public static void main(String[] args) { //创建一个对象 User user1 = new User(\u0026#34;1号\u0026#34;, 3, \u0026#34;男\u0026#34;); User user2 = new User(\u0026#34;2号\u0026#34;, 3, \u0026#34;男\u0026#34;); User user3 = new User(\u0026#34;3号\u0026#34;, 3, \u0026#34;男\u0026#34;); User user4 = new User(\u0026#34;4号\u0026#34;, 3, \u0026#34;男\u0026#34;); List\u0026lt;User\u0026gt; list = new ArrayList\u0026lt;User\u0026gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); System.out.println(\u0026#34;*******Java对象 转 JSON字符串*******\u0026#34;); String str1 = JSON.toJSONString(list); System.out.println(\u0026#34;JSON.toJSONString(list)==\u0026gt;\u0026#34;+str1); String str2 = JSON.toJSONString(user1); System.out.println(\u0026#34;JSON.toJSONString(user1)==\u0026gt;\u0026#34;+str2); System.out.println(\u0026#34;\\n****** JSON字符串 转 Java对象*******\u0026#34;); User jp_user1=JSON.parseObject(str2,User.class); System.out.println(\u0026#34;JSON.parseObject(str2,User.class)==\u0026gt;\u0026#34;+jp_user1); System.out.println(\u0026#34;\\n****** Java对象 转 JSON对象 ******\u0026#34;); JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2); System.out.println(\u0026#34;(JSONObject) JSON.toJSON(user2)==\u0026gt;\u0026#34;+jsonObject1.getString(\u0026#34;name\u0026#34;)); System.out.println(\u0026#34;\\n****** JSON对象 转 Java对象 ******\u0026#34;); User to_java_user = JSON.toJavaObject(jsonObject1, User.class); System.out.println(\u0026#34;JSON.toJavaObject(jsonObject1, User.class)==\u0026gt;\u0026#34;+to_java_user); } } Jackson刚刚测试没成功，还是选择FastJson吧😇。\n拦截器 概述 SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。\n**过滤器与拦截器的区别：**拦截器是AOP思想的具体应用。\n过滤器\nservlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截 拦截器\n拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的 使用方法 自定义拦截器需要实现接口HandlerInterceptor\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class MyInterceptor implements HandlerInterceptor { //在请求处理的方法之前执行 //如果返回true执行下一个拦截器 //如果返回false就不执行下一个拦截器 public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception { System.out.println(\u0026#34;------------处理前------------\u0026#34;); return true; } //在请求处理方法执行之后执行 public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;------------处理后------------\u0026#34;); } //在dispatcherServlet处理后执行,做清理工作. public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception { System.out.println(\u0026#34;------------清理------------\u0026#34;); } } 在springmvc的配置文件中配置拦截器\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!--关于拦截器的配置--\u0026gt; \u0026lt;mvc:interceptors\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;!--/** 包括路径及其子路径--\u0026gt; \u0026lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--\u0026gt; \u0026lt;!--/admin/** 拦截的是/admin/下的所有--\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/**\u0026#34;/\u0026gt; \u0026lt;!--bean配置的就是拦截器--\u0026gt; \u0026lt;bean class=\u0026#34;top.lbqaq.interceptor.MyInterceptor\u0026#34;/\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;/mvc:interceptors\u0026gt; 执行顺序如下：\n1 2 3 4 ------------处理前------------ Controller方法 ------------处理后------------ ------------清理------------ 拦截器可以用来做登录验证等等内容，这里就不展开了（才不是懒得写）\n文件传输 文件上传是项目开发中最常见的功能之一 ,springMVC 可以很好的支持文件上传，但是SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。\n前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器；\n对表单中的 enctype 属性做个详细的说明：\napplication/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。 multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。 text/plain：除了把空格转换为 \u0026ldquo;+\u0026rdquo; 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。 1 2 3 4 \u0026lt;form action=\u0026#34;\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 文件上传 导入依赖包\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!--文件上传--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-fileupload\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-fileupload\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--servlet-api导入高版本的--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 配置multipartResolver\n这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！\n1 2 3 4 5 6 7 8 \u0026lt;!--文件上传配置--\u0026gt; \u0026lt;bean id=\u0026#34;multipartResolver\u0026#34; class=\u0026#34;org.springframework.web.multipart.commons.CommonsMultipartResolver\u0026#34;\u0026gt; \u0026lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --\u0026gt; \u0026lt;property name=\u0026#34;defaultEncoding\u0026#34; value=\u0026#34;utf-8\u0026#34;/\u0026gt; \u0026lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --\u0026gt; \u0026lt;property name=\u0026#34;maxUploadSize\u0026#34; value=\u0026#34;10485760\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;maxInMemorySize\u0026#34; value=\u0026#34;40960\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 编写前端页面\n1 2 3 4 \u0026lt;form action=\u0026#34;/upload\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;upload\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 配置Controller\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.multipart.commons.CommonsMultipartFile; import javax.servlet.http.HttpServletRequest; import java.io.*; @Controller public class FileController { //@RequestParam(\u0026#34;file\u0026#34;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象 //批量上传CommonsMultipartFile则为数组即可 @RequestMapping(\u0026#34;/upload\u0026#34;) public String fileUpload(@RequestParam(\u0026#34;file\u0026#34;) CommonsMultipartFile file , HttpServletRequest request) throws IOException { //获取文件名 : file.getOriginalFilename(); String uploadFileName = file.getOriginalFilename(); //如果文件名为空，直接回到首页！ if (\u0026#34;\u0026#34;.equals(uploadFileName)){ return \u0026#34;redirect:/index.jsp\u0026#34;; } System.out.println(\u0026#34;上传文件名 : \u0026#34;+uploadFileName); //上传路径保存设置 String path = request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;); //如果路径不存在，创建一个 File realPath = new File(path); if (!realPath.exists()){ realPath.mkdir(); } System.out.println(\u0026#34;上传文件保存地址：\u0026#34;+realPath); InputStream is = file.getInputStream(); //文件输入流 OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流 //读取写出 int len=0; byte[] buffer = new byte[1024]; while ((len=is.read(buffer))!=-1){ os.write(buffer,0,len); os.flush(); } os.close(); is.close(); return \u0026#34;redirect:/index.jsp\u0026#34;; } } 方法二：使用file.Transto 来保存上传的文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* * 采用file.Transto 来保存上传的文件 */ @RequestMapping(\u0026#34;/upload2\u0026#34;) public String fileUpload2(@RequestParam(\u0026#34;file\u0026#34;) CommonsMultipartFile file, HttpServletRequest request) throws IOException { //上传路径保存设置 String path = request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;); File realPath = new File(path); if (!realPath.exists()){ realPath.mkdir(); } //上传文件地址 System.out.println(\u0026#34;上传文件保存地址：\u0026#34;+realPath); //通过CommonsMultipartFile的方法直接写文件（注意这个时候） file.transferTo(new File(realPath +\u0026#34;/\u0026#34;+ file.getOriginalFilename())); return \u0026#34;redirect:/index.jsp\u0026#34;; } 文件下载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @RequestMapping(value=\u0026#34;/download\u0026#34;) public String downloads(HttpServletResponse response ,HttpServletRequest request) throws Exception{ //要下载的图片地址 String path = request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;); String fileName = \u0026#34;基础语法.jpg\u0026#34;; //1、设置response 响应头 response.reset(); //设置页面不缓存,清空buffer response.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); //字符编码 response.setContentType(\u0026#34;multipart/form-data\u0026#34;); //二进制传输数据 //设置响应头 response.setHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment;fileName=\u0026#34;+URLEncoder.encode(fileName, \u0026#34;UTF-8\u0026#34;)); File file = new File(path,fileName); //2、 读取文件--输入流 InputStream input=new FileInputStream(file); //3、 写出文件--输出流 OutputStream out = response.getOutputStream(); byte[] buff =new byte[1024]; int index=0; //4、执行 写出操作 while((index= input.read(buff))!= -1){ out.write(buff, 0, index); out.flush(); } out.close(); input.close(); return null; } 或者直接用a标签\n\u0026lt;a href=\u0026quot;/1.jpg\u0026quot;\u0026gt;点击下载\u0026lt;/a\u0026gt;\n","date":"2021-08-15T09:06:00+08:00","image":"https://lbqaq.top/p/springmvc/65411813.webp","permalink":"https://lbqaq.top/p/springmvc/","title":"SpringMVC学习笔记"},{"content":"花了3天时间，Spring也终于看完了,SSM已经干完了两个了，感觉人都要没了😇。还是老样子，留下笔记以免遗忘。\n下面的内容都是基于遇见狂神说的Spring5视频教程而来，在此感谢能提供这么优秀的教程。\nSpring 简介 Spring就是用来简化Java开发的，只能说学Java不学Spring，就像读四大名著不读红楼梦\u0026hellip;\u0026hellip;\n2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。\n2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。\n很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。\nSpring理念 : 使现有技术更加实用。 本身就是一个大杂烩 , 整合现有的框架技术。\nSSM：SpringMVC+Spring+MyBatis\n几个常用的网址：\n官网\n官方文档（英文）\n中文文档\nGitHub\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 优点 Spring是一个开源免费的框架 , 容器\nSpring是一个轻量级的框架 , 非侵入式的\n控制反转（IoC）,面向切面（Aop）\n对事务的支持 , 对框架的支持\n一句话概括：\nSpring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。\n拓展 Spring Boot 一套快速配置脚手架 可以基于Spring Boot 快速开发单个微服务 Spring Cloud Spring Cloud是基于Spring Boot实现的 学习路线：Spring -\u0026gt; SpringMVC -\u0026gt; Spring Boot -\u0026gt; Spring Cloud\nIOC理论推导 原先的开发模式：\n先写一个UserDao接口\n1 2 3 public interface UserDao { public void getUser(); } 再去写Dao的实现类\n1 2 3 4 5 6 public class UserDaoImpl implements UserDao { @Override public void getUser() { System.out.println(\u0026#34;获取用户数据\u0026#34;); } } 然后去写UserService的接口\n1 2 3 public interface UserService { public void getUser(); } 最后写Service的实现类\n1 2 3 4 5 6 7 8 public class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoImpl(); @Override public void getUser() { userDao.getUser(); } } 测试一下\n1 2 3 4 5 6 @Test public void test(){ //用户实际调用的是业务层，dao层他们并不需要接触！ UserService service = new UserServiceImpl(); service.getUser(); } 如果需要更换Dao层的实现方法，每次都需要在UserServiceImpl里手动修改new的对象，这样做十分麻烦。\n现在可以使用set接口实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class UserServiceImpl implements UserService { private UserDao userDao; // 利用set进行动态实现值的注入 public void setUserDao(UserDao userDao) { this.userDao = userDao; } @Override public void getUser() { userDao.getUser(); } } 以前所有东西都是由程序去进行控制创建。 而现在是由我们自行控制创建对象，把主动权交给了调用者。程序不用去管怎么创建,怎么实现了，它只负责提供一个接口。 这种思想，从本质上解决了问题，我们程序员不再去管理对象的创建了，更多的去关注业务的实现。耦合性大大降低， 这也就是IOC的原型！\nIOC本质 控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。\nSpring的工作原理：\n控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。\n第一个Spring程序 添加Maven依赖\n1 2 3 4 5 6 7 8 \u0026lt;dependencies\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 在pojo包下创建实体类Hello\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package top.lbqaq.pojo; /** * @author luoboQAQ * @Date 2021/8/12 上午 10:49 */ public class Hello { private String str; public String getStr() { return str; } public void setStr(String str) { this.str = str; } @Override public String toString() { return \u0026#34;Hello{\u0026#34; + \u0026#34;str=\u0026#39;\u0026#34; + str + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } 在resources目录下编写Spring的配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--bean就是java对象 , 由Spring创建和管理 原来是 类型 变量名 = new 类型(); Hello hello = new Hello(); 现在 id=变量名 class=new的对象 property是给变量赋的初值 --\u0026gt; \u0026lt;bean id=\u0026#34;hello\u0026#34; class=\u0026#34;top.lbqaq.pojo.Hello\u0026#34;\u0026gt; \u0026lt;!--引用另外一个bean , 不是用value 而是用 ref--\u0026gt; \u0026lt;property name=\u0026#34;str\u0026#34; value=\u0026#34;Spring\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 进行测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import top.lbqaq.pojo.Hello; /** * @author luoboQAQ * @Date 2021/8/12 上午 10:53 */ public class MyTest { public static void main(String[] args) { //获取Spring的上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); //我们的对象都在Spring中管理了，我们要使用直接从中取即可 Hello hello = (Hello) context.getBean(\u0026#34;hello\u0026#34;); System.out.println(hello); } } 现在Hello对象由Spring来创建和管理，这个过程就叫控制反转\n控制：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring后，对象是由Spring来创建的。\n反转：程序本身不创建对象，而变成被动的接收对象。\n依赖注入：就是利用set方法来进行注入的。\nIOC是一种编程思想，由主动的编程变成被动的接收。\nIOC创建对象方式 通过无参构造函数（默认）\n通过有参构造函数，有三种方式\n下标赋值\n1 2 3 \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 用类型赋值（不推荐）\n1 2 3 \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg type=\u0026#34;java.lang.String\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 通过参数名创建\n1 2 3 \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 在配置文件加载的时候，其中管理的对象都已经初始化了！\nSpring配置 别名（alias） 1 2 \u0026lt;!--设置别名：在获取Bean的时候可以使用别名获取--\u0026gt; \u0026lt;alias name=\u0026#34;user\u0026#34; alias=\u0026#34;userNew\u0026#34;/\u0026gt; Bean的配置 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!--bean就是java对象,由Spring创建和管理--\u0026gt; \u0026lt;!-- id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符 如果配置id,又配置了name,那么name是别名 name可以设置多个别名,可以用逗号,分号,空格隔开 如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象; class是bean的全限定名=包名+类名 --\u0026gt; \u0026lt;bean id=\u0026#34;hello\u0026#34; name=\u0026#34;hello2 h2,h3;h4\u0026#34; class=\u0026#34;top.lbqaq.pojo.Hello\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Spring\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; import 一般用于团队开发，将多个配置文件合为一个配置文件applicationContext.xml\n1 \u0026lt;import resource=\u0026#34;{path}/beans.xml\u0026#34;/\u0026gt; 依赖注入 概念 依赖注入（Dependency Injection,DI）。 依赖 : 指Bean对象的创建依赖于容器，Bean对象的依赖资源。 注入 : 指Bean对象所依赖的资源，由容器来设置和装配。 构造器注入 见前面的IOC创建对象方式\nset注入【重点】 测试环境 1 2 3 4 5 6 7 8 9 10 11 public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } 1 2 3 4 5 6 7 8 9 10 public class Student { private String name; private Address address; private String[] books; private List\u0026lt;String\u0026gt; hobbys; private Map\u0026lt;String,String\u0026gt; card; private Set\u0026lt;String\u0026gt; games; private String wife; private Properties info; } xml编写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;address\u0026#34; class=\u0026#34;top.lbqaq.pojo.Address\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; value=\u0026#34;西安\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;student\u0026#34; class=\u0026#34;top.lbqaq.pojo.Student\u0026#34;\u0026gt; \u0026lt;!--普通值注入，value--\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;!--Bean注入，ref--\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; ref=\u0026#34;address\u0026#34;/\u0026gt; \u0026lt;!--数组注入--\u0026gt; \u0026lt;property name=\u0026#34;books\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;红楼梦\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;西游记\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;水浒传\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;三国演义\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--list--\u0026gt; \u0026lt;property name=\u0026#34;hobbys\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;听歌\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;看电影\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;打游戏\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--map--\u0026gt; \u0026lt;property name=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;身份证\u0026#34; value=\u0026#34;112233445566778899\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;银行卡\u0026#34; value=\u0026#34;123987879172197\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Set--\u0026gt; \u0026lt;property name=\u0026#34;games\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;LOL\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;CSGO\u0026lt;/value\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--null--\u0026gt; \u0026lt;property name=\u0026#34;wife\u0026#34;\u0026gt; \u0026lt;null/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Properties--\u0026gt; \u0026lt;property name=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;driver\u0026#34;\u0026gt;20211213\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;url\u0026#34;\u0026gt;女\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;username\u0026#34;\u0026gt;root\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;password\u0026#34;\u0026gt;123456\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 具体用法见上面的代码就行了。\n扩展方式注入 p命名空间 导入命名空间\n1 xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; 在bean标签里直接使用\n1 \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34; p:age=\u0026#34;18\u0026#34; p:name=\u0026#34;小明\u0026#34;/\u0026gt; 相当于set注入\nc命名空间 导入命名空间\n1 xmlns:c=\u0026#34;http://www.springframework.org/schema/c\u0026#34; 在bean标签里直接使用\n1 \u0026lt;bean id=\u0026#34;user2\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34; c:age=\u0026#34;20\u0026#34; c:name=\u0026#34;小红\u0026#34;/\u0026gt; 相当于有参构造函数注入\nBean的作用域 类别 说明 singleton (默认)将每个 Spring IoC 容器的单个 bean 定义范围限定为单个对象实例。 prototype 将单个 bean 定义的作用域限定为任意数量的对象实例。 request 将单个 bean 定义的范围限定为单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有一个在单个 bean 定义后面创建的 bean 实例。仅在可感知网络的 Spring ApplicationContext中有效。 session 将单个 bean 定义的范围限定为 HTTP Session的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。 application 将单个 bean 定义的范围限定为ServletContext的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。 websocket 将单个 bean 定义的范围限定为WebSocket的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。 单例模式（默认）：每次获取的都是同一个对象\n1 \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34; p:age=\u0026#34;18\u0026#34; p:name=\u0026#34;小明\u0026#34; scope=\u0026#34;singleton\u0026#34;/\u0026gt; 原型模式：每次get都是从容器中产生一个新对象\n1 \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34; p:age=\u0026#34;18\u0026#34; p:name=\u0026#34;小明\u0026#34; scope=\u0026#34;prototype\u0026#34;/\u0026gt; 其余request、session、application、websocket这些只在web开发中使用。\nBean的自动装配 自动装配是使用spring满足bean依赖的一种方法 spring会在应用上下文中为某个bean寻找其依赖的bean。 Spring中bean有三种装配机制，分别是：\n在xml中显式配置 在java中显式配置 隐式的bean发现机制和自动装配【重要】 环境搭建 1 2 3 4 5 public class Cat { public void shout(){ System.out.println(\u0026#34;miao~\u0026#34;); } } 1 2 3 4 5 public class Dog { public void shout(){ System.out.println(\u0026#34;wang~\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class People { private Cat cat; private Dog dog; private String name; public Cat getCat() { return cat; } public void setCat(Cat cat) { this.cat = cat; } public Dog getDog() { return dog; } public void setDog(Dog dog) { this.dog = dog; } public String getName() { return name; } public void setName(String name) { this.name = name; } } ByName自动装配 1 2 3 4 5 6 \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;top.lbqaq.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;top.lbqaq.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;people\u0026#34; class=\u0026#34;top.lbqaq.pojo.People\u0026#34; autowire=\u0026#34;byName\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 会自动在容器上下文中查找，和自己对象set方法后面的值相对应的beanid\nByType自动装配 1 2 3 4 5 6 \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;top.lbqaq.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;top.lbqaq.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;people\u0026#34; class=\u0026#34;top.lbqaq.pojo.People\u0026#34; autowire=\u0026#34;byType\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 自动在容器上下文中查找，和自己对象属性类型相同的Bean\n小结：\nbyname要保证所有的bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致 bytype的时候，需要保证bean的class唯一，并且这个bean需要和自动注入的属性的类型一致 使用注解自动装配 准备工作 导入aop包\n导入约束\n1 2 3 4 xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd 配置注解支持\u0026lt;context:annotation-config/\u0026gt;\n@Autowired 在属性或在set方法上使用。\n使用Autowired可以不需要set方法。\n@Autowired是按类型自动转配的。\n@Autowired(required=false) 说明对象可以为null\n@Qualifier 如果环境比较复杂，自动装配无法通过一个@Autowired完成，可以通过@Qualifier(value=\u0026quot;xxx\u0026quot;)来实现。\n@Qualifier相当于byName\n1 2 3 4 5 6 @Autowired @Qualifier(value = \u0026#34;cat2\u0026#34;) private Cat cat; @Autowired @Qualifier(value = \u0026#34;dog2\u0026#34;) private Dog dog; @Resource @Resource如有指定的name属性，先按该属性进行byName方式查找装配； 其次再进行默认的byName方式进行装配； 如果以上都不成功，则按byType的方式自动装配。 都不成功，则报异常。 1 2 3 4 5 6 7 8 public class User { //如果允许对象为null，设置required = false,默认为true @Resource(name = \u0026#34;cat2\u0026#34;) private Cat cat; @Resource private Dog dog; private String str; } 小结 @Autowired与@Resource异同：\n@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。\n@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用\n@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。\n它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。\n使用注解开发 使用注解开发需要导入aop的包，导入约束和配置注解支持\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--指定要扫描的包，这个包下的注解就会生效--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;top.lbqaq.pojo\u0026#34;/\u0026gt; \u0026lt;context:annotation-config/\u0026gt; \u0026lt;/beans\u0026gt; Bean的实现 1 2 3 4 @Component public class User { public String name = \u0026#34;小明\u0026#34;; } 使用@Component注解，相当于配置文件中的\u0026lt;bean id=\u0026quot;user\u0026quot; class=\u0026quot;当前注解的类\u0026quot;/\u0026gt;\n注意需要在配置文件中指定要扫描的包\u0026lt;context:component-scan base-package=\u0026quot;top.lbqaq.pojo\u0026quot;/\u0026gt;\n属性注入 使用@Value注解，相当于配置文件中的\u0026lt;property name=\u0026quot;name\u0026quot; value=\u0026quot;小明\u0026quot;/\u0026gt;\n可以在声明上加，也可以在set方法上加\n1 2 3 4 5 @Component public class User { @Value(\u0026#34;小明\u0026#34;) public String name; } 1 2 3 4 5 6 7 8 9 10 @Component public class User { public String name; @Value(\u0026#34;小明\u0026#34;) public void setName(String name) { this.name = name; } } 衍生注解 对于@Component注解，有三个衍生注解，分别对应MVC的三层。\nDao层：@Repository Service层：@Service Web层：@Controller 这四个注解的作用都是代表将某个类注册到Spring中，装配Bean\n自动装配注解 @Autowired：按类型自动转配 @Qualifier(value=\u0026quot;xxx\u0026quot;)：按name自动装配 @Resource：Java提供的，先name再type，比较复杂 详细的解释可以看上面\n作用域 @Scope\nsingleton：单例模式 prototype：多例模式 1 2 3 4 5 6 @Component @Scope(\u0026#34;prototype\u0026#34;) public class User { @Value(\u0026#34;小明\u0026#34;) public String name; } 小结 XML与注解比较\nXML可以适用任何场景 ，结构清晰，维护方便 注解不是自己提供的类使用不了，开发简单方便 推荐用法\nxml管理Bean 注解完成属性注入 使用Java类进行配置 实体类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class User { private String name; @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } public String getName() { return name; } @Value(\u0026#34;小明\u0026#34;) public void setName(String name) { this.name = name; } } 配置类\n1 2 3 4 5 6 7 @Configuration public class LbqaqConfig { @Bean public User getUser(){ return new User(); } } 这里的@Configuration表明这是Spring的配置\n@Bean是用来注册bean，这里的返回值就Bean的类型，方法名就是bean的id\n测试\n1 2 3 4 5 6 7 8 public class MyTest { @Test public void test1(){ ApplicationContext context = new AnnotationConfigApplicationContext(LbqaqConfig.class); User user = (User) context.getBean(\u0026#34;getUser\u0026#34;); System.out.println(user.getName()); } } 代理模式 AOP的底层机制就是动态代理。\n静态代理 角色分析\n抽象角色：一般使用接口或者抽象类来实现 真实角色：被代理的角色 代理角色：代理真实角色。代理真实角色后 , 一般会做一些附属的操作。 客户：使用代理角色来进行一些操作。 举例：\nRent.java即抽象角色\n1 2 3 4 //抽象角色：租房 public interface Rent { public void rent(); } Host.java即真实角色\n1 2 3 4 5 6 //真实角色: 房东，房东要出租房子 public class Host implements Rent{ public void rent() { System.out.println(\u0026#34;房屋出租\u0026#34;); } } Proxy.java即代理角色\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //代理角色：中介 public class Proxy implements Rent { private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } //租房 public void rent(){ seeHouse(); host.rent(); fare(); } //看房 public void seeHouse(){ System.out.println(\u0026#34;带房客看房\u0026#34;); } //收中介费 public void fare(){ System.out.println(\u0026#34;收中介费\u0026#34;); } } Client.java即客户\n1 2 3 4 5 6 7 8 9 10 11 12 //客户类，一般客户都会去找代理！ public class Client { public static void main(String[] args) { //房东要租房 Host host = new Host(); //中介帮助房东 Proxy proxy = new Proxy(host); //你去找中介！ proxy.rent(); } } 分析：\n在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式。\n静态代理的好处:\n可以使得我们的真实角色更加纯粹，不再去关注一些公共的事情。 公共的业务由代理来完成，实现了业务的分工。 公共业务发生扩展时变得更加集中和方便。 缺点：\n类多了，多了代理类，工作量变大了，开发效率降低。 我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想。\n动态代理 动态代理的角色和静态代理的一样。\n动态代理的代理类是动态生成的，静态代理的代理类是我们提前写好的\n动态代理分为两类：一类是基于接口动态代理，一类是基于类的动态代理\n基于接口的动态代理\u0026mdash;-JDK动态代理 基于类的动态代理\u0026ndash;cglib 现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist 我们这里使用JDK的原生代码来实现，其余的道理都是一样的！ JDK的动态代理需要了解两个类\n核心 : InvocationHandler、Proxy\n代码实现：\n1 2 3 4 //租房 public interface Rent { void rent(); } 1 2 3 4 5 6 7 8 //房东 public class Host implements Rent { @Override public void rent() { System.out.println(\u0026#34;房东要出租\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class ProxyInvocationHandler implements InvocationHandler { //被代理的接口 private Rent rent; public void setRent(Rent rent) { this.rent = rent; } //生成得到的代理类 public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(),rent.getClass().getInterfaces(),this); } @Override //处理代理实例，并返回结果 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //动态代理就是依赖反射实现 Object result = method.invoke(rent, args); return result; } } 1 2 3 4 5 6 7 8 9 10 11 public class Client { public static void main(String[] args) { //真实角色 Host host=new Host(); ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setRent(host); Rent proxy = (Rent) pih.getProxy(); proxy.rent(); } } 动态代理代理接口\n通用的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class ProxyInvocationHandler implements InvocationHandler { private Object target; public void setTarget(Object target) { this.target = target; } //生成代理类 public Object getProxy() { return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); } // proxy : 代理类 // method : 代理类的调用处理程序的方法对象. public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { log(method.getName()); Object result = method.invoke(target, args); return result; } public void log(String methodName) { System.out.println(\u0026#34;执行了\u0026#34; + methodName + \u0026#34;方法\u0026#34;); } } AOP 什么是AOP AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n通俗点说，就是在不改变原有代码的情况下去增加新的功能。\nAOP在Spring中 提供声明式事务；允许用户自定义切面\n横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 \u0026hellip;. 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 目标（Target）：被通知对象。 代理（Proxy）：向目标对象应用通知之后创建的对象。 切入点（PointCut）：切面通知 执行的 “地点”的定义。 连接点（JointPoint）：与切入点匹配的执行点。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice：\n使用Spring实现AOP 导入依赖包\n1 2 3 4 5 6 7 \u0026lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.7\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 方式一：使用Spring的方法 业务接口和实现类\n1 2 3 4 5 6 public interface UserService { void add(); void delete(); void update(); void select(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class UserServiceImpl implements UserService{ @Override public void add() { System.out.println(\u0026#34;增加一个用户\u0026#34;); } @Override public void delete() { System.out.println(\u0026#34;删除一个用户\u0026#34;); } @Override public void update() { System.out.println(\u0026#34;更新一个用户\u0026#34;); } @Override public void select() { System.out.println(\u0026#34;查询一个用户\u0026#34;); } } 写两个增强类\n1 2 3 4 5 6 7 8 9 public class Log implements MethodBeforeAdvice { //method : 要执行的目标对象的方法 //objects : 被调用的方法的参数 //o : 目标对象 @Override public void before(Method method, Object[] objects, Object o) throws Throwable { System.out.println(o.getClass().getName()+\u0026#34;的\u0026#34;+method.getName()+\u0026#34;被执行了\u0026#34;); } } 1 2 3 4 5 6 7 public class AfterLog implements AfterReturningAdvice { //o:返回值 @Override public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable { System.out.println(\u0026#34;执行了\u0026#34;+method.getName()+\u0026#34;方法，返回结果为\u0026#34;+o); } } 配置xml，这里需要引入aop命名空间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;!--注册Bean--\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;top.lbqaq.service.UserServiceImpl\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;log\u0026#34; class=\u0026#34;top.lbqaq.log.Log\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;afterLog\u0026#34; class=\u0026#34;top.lbqaq.log.AfterLog\u0026#34;/\u0026gt; \u0026lt;!--配置aop：需要导入aop约束--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--切入点：expression：表达式 execution()--\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;pointcut\u0026#34; expression=\u0026#34;execution(* top.lbqaq.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt; \u0026lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;log\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;afterLog\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt; execution表达式解析：\nexecution(修饰符 返回值 包名.类名/接口名.方法名(参数列表)) 修饰符可以忽略 (..)可以代表所有参数,(*)代表一个参数,(*,String)代表第一个参数为任何值,第二个参数为String类型 最后测试\n1 2 3 4 5 6 7 8 public class MyTest { @Test public void test(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); UserService userService = (UserService) context.getBean(\u0026#34;userService\u0026#34;); userService.select(); } } 方法二：使用自定义类来实现 创建自定义类\n1 2 3 4 5 6 7 8 9 public class DiyPointCut { public void before(){ System.out.println(\u0026#34;==========方法执行前==========\u0026#34;); } public void after(){ System.out.println(\u0026#34;==========方法执行后==========\u0026#34;); } } 配置xml\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;bean id=\u0026#34;diy\u0026#34; class=\u0026#34;top.lbqaq.diy.DiyPointCut\u0026#34;/\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--自定义切面，ref为要引用的类--\u0026gt; \u0026lt;aop:aspect ref=\u0026#34;diy\u0026#34;\u0026gt; \u0026lt;!--切入点--\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;point\u0026#34; expression=\u0026#34;execution(* top.lbqaq.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt; \u0026lt;!--通知--\u0026gt; \u0026lt;aop:before method=\u0026#34;before\u0026#34; pointcut-ref=\u0026#34;point\u0026#34;/\u0026gt; \u0026lt;aop:after method=\u0026#34;after\u0026#34; pointcut-ref=\u0026#34;point\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; 方式三：使用注解来实现AOP 在类上标注注解@Aspect，如果没有该注解，就在maven配置里把\u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt;去掉\n在方法前加上@Before()或@After()注解，并在括号中填入表达式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //使用注解实现AOP @Aspect public class AnnotationPointCut { @Before(\u0026#34;execution(* top.lbqaq.service.UserServiceImpl.*(..))\u0026#34;) public void before(){ System.out.println(\u0026#34;=====方法执行前=====\u0026#34;); } @After(\u0026#34;execution(* top.lbqaq.service.UserServiceImpl.*(..))\u0026#34;) public void after(){ System.out.println(\u0026#34;=====方法执行后=====\u0026#34;); } //在环绕增强中，我们可以给定一个参数，代表我们要获取处理切入的点 @Around(\u0026#34;execution(* top.lbqaq.service.UserServiceImpl.*(..))\u0026#34;) public void around(ProceedingJoinPoint jp) throws Throwable { System.out.println(\u0026#34;环绕前\u0026#34;); //执行方法 Object proceed = jp.proceed(); System.out.println(\u0026#34;环绕后\u0026#34;); } } 在Spring配置文件注册Bean并开启注解支持\n1 2 3 \u0026lt;bean id=\u0026#34;annotationPointCut\u0026#34; class=\u0026#34;top.lbqaq.diy.AnnotationPointCut\u0026#34;/\u0026gt; \u0026lt;!--开启注解支持--\u0026gt; \u0026lt;aop:aspectj-autoproxy/\u0026gt; 整合MyBatis 首先要导入相关jar包\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;dependencies\u0026gt; \u0026lt;!-- junit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.13\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mysql驱动 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.25\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis-spring --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- spring框架 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- spring-jdbc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- AOP 织入器 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 回顾MyBatis 编写实体类\n1 2 3 4 5 6 7 public class User { private int id; private String name; private String pwd; //setter,getter //toString,构造 } 编写Mybatis配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;!--核心配置文件--\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;top.lbqaq.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!--每一个mapper都需要注册--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026#34;top.lbqaq.mapper.UserMapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; 编写接口\n1 2 3 public interface UserMapper { List\u0026lt;User\u0026gt; selectUser(); } 编写接口对应的xml文件\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;top.lbqaq.mapper.UserMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;selectUser\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 解决Maven静态资源过滤问题\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt; 测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class MyTest { @Test public void test() throws IOException { String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u0026lt;User\u0026gt; userList = mapper.selectUser(); for (User user: userList){ System.out.println(user); } sqlSession.close(); } } MyBatis-Spring MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。官方文档\n整合实现一 引入Spring配置文件spring-dao.xml\n1 2 3 4 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; 配置数据源\n1 2 3 4 5 6 7 8 9 \u0026lt;!--DataSource:使用Spring的数据源替换MyBatis的配置 这里使用Spring提供的JDBC --\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 配置SqlSessionFactory,关联MyBatis\n1 2 3 4 5 6 \u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34; /\u0026gt; \u0026lt;!--绑定Mybatis配置文件--\u0026gt; \u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;classpath:mybatis-config.xml\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;mapperLocations\u0026#34; value=\u0026#34;classpath:top/lbqaq/mapper/*.xml\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 注册sqlSessionTemplate，关联sqlSessionFactory\n1 2 3 4 \u0026lt;bean id=\u0026#34;sqlSession\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionTemplate\u0026#34;\u0026gt; \u0026lt;!--使用构造器注入，因为它没有set方法--\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; ref=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 增加Mapper接口的实现类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class UserMapperImpl implements UserMapper{ //原来我们的所有操作，都使用sqlSession来执行；现在都使用SqlSessionTemplate private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } @Override public List\u0026lt;User\u0026gt; selectUser() { UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); } } 将实现类注册到Spring中\n1 2 3 \u0026lt;bean id=\u0026#34;userMapper\u0026#34; class=\u0026#34;top.lbqaq.mapper.UserMapperImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sqlSession\u0026#34; ref=\u0026#34;sqlSession\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 测试\n1 2 3 4 5 6 7 8 @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;spring-dao.xml\u0026#34;); UserMapper userMapper = context.getBean(\u0026#34;userMapper\u0026#34;, UserMapper.class); for (User user : userMapper.selectUser()) { System.out.println(user); } } 此时再去看MyBatis的配置文件，里面大部分配置都被Spring整合了\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;top.lbqaq.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;/configuration\u0026gt; 这里建议将typeAliases和settings留在MyBatis的配置文件中。\n以后可以将Spring配置文件拆开，spring-dao.xml用来处理数据库相关代码，applicationContext.xml作为总配置文件。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;import resource=\u0026#34;spring-dao.xml\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;userMapper\u0026#34; class=\u0026#34;top.lbqaq.mapper.UserMapperImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sqlSession\u0026#34; ref=\u0026#34;sqlSession\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 整合方式二 使用SqlSessionDaoSupport\n修改实现类，继承SqlSessionDaoSupport\n1 2 3 4 5 6 public class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper{ @Override public List\u0026lt;User\u0026gt; selectUser() { return getSqlSession().getMapper(UserMapper.class).selectUser(); } } 配置Bean\n1 2 3 \u0026lt;bean id=\u0026#34;userMapper2\u0026#34; class=\u0026#34;top.lbqaq.mapper.UserMapperImpl2\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sqlSessionFactory\u0026#34; ref=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 测试\n1 2 3 4 5 6 7 8 @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); UserMapper userMapper = context.getBean(\u0026#34;userMapper2\u0026#34;, UserMapper.class); for (User user : userMapper.selectUser()) { System.out.println(user); } } 使用这种方法，就不需要上面的第4步了，步骤就更加简洁了。\n声明式事务 spring中的事务：\n编程式事务：在代码中进行事务的管理 声明式事务：AOP 一般我们都采用声明式事务，将事务管理作为横切关注点，通过aop方法模块化。\n使用方法：\n引入头文件约束tx\n1 2 3 4 xmlns:tx=\u0026#34;http://www.springframework.org/schema/tx\u0026#34; http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\u0026#34; 配置事务管理器\n1 2 3 4 \u0026lt;!--配置声明式事务--\u0026gt; \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 配置事务通知\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!--配置事务通知--\u0026gt; \u0026lt;tx:advice id=\u0026#34;txAdvice\u0026#34; transaction-manager=\u0026#34;transactionManager\u0026#34;\u0026gt; \u0026lt;!--给那些方法配置事务--\u0026gt; \u0026lt;tx:attributes\u0026gt; \u0026lt;!--配置事务的传播特性 propagation--\u0026gt; \u0026lt;tx:method name=\u0026#34;add\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;delete\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;update\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;query\u0026#34; read-only=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;*\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;/tx:attributes\u0026gt; \u0026lt;/tx:advice\u0026gt; Spring的事务的传播特性一共有7种：\npropagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。 propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。 propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。 propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作 一般第一种就够用了。\n配置AOP\n注意要导入头文件依赖aop，详细的内容在上面，或者IDEA也会自动补全\n1 2 3 4 5 \u0026lt;!--配置事务切入--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;txPointCut\u0026#34; expression=\u0026#34;execution(* top.lbqaq.mapper.*(..))\u0026#34;/\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;txAdvice\u0026#34; pointcut-ref=\u0026#34;txPointCut\u0026#34;/\u0026gt; \u0026lt;/aop:config\u0026gt; ","date":"2021-08-12T09:38:02+08:00","image":"https://lbqaq.top/p/spring/82968220.webp","permalink":"https://lbqaq.top/p/spring/","title":"Spring学习笔记"},{"content":"因为买了一台云服务器，不拿来干点啥实在是太亏了，于是便想到了可以使用云服务器来挂卡。\n步骤 安装.net环境 ASF是基于.netcore开发的程序，所以需要安装环境。这里建议看微软官方的安装文档，里面有不同系统的安装方法。\n我们需要安装的只是ASP.NET Core 运行时。\n我的系统是centos7，这里就只列举我系统上的命令了。\n1 2 sudo rpm -Uvh https://packages.microsoft.com/config/centos/7/packages-microsoft-prod.rpm sudo yum install aspnetcore-runtime-5.0 安装ASF 在ASF的发布页面上下载系统对应的版本解压即可。\n我这里是在本地先下载好后用WinSCP直接传上服务器。\n配置ASF 这里就采用官方的**在线配置文件生成器**自动生成即可。\n我们这里选择机器人，将steam的账号和密码填入，并将Enabled设置为True就行了。\n详细的配置内容可以在官方Wiki上看到，这里就不再赘述了。\n下面放上我的配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;SteamLogin\u0026#34;: \u0026#34;xxx\u0026#34;, \u0026#34;SteamPassword\u0026#34;: \u0026#34;xxx\u0026#34;, \u0026#34;Enabled\u0026#34;: true, \u0026#34;CustomGamePlayedWhileFarming\u0026#34;: \u0026#34;挂卡中...\u0026#34;, \u0026#34;CustomGamePlayedWhileIdle\u0026#34;: \u0026#34;空闲中...\u0026#34;, \u0026#34;FarmingOrders\u0026#34;: [ 15, 12 ], \u0026#34;HoursUntilCardDrops\u0026#34;: 0, \u0026#34;OnlineStatus\u0026#34;: 1 } CustomGamePlayedWhileFarming：表示挂卡时显示的游戏名 CustomGamePlayedWhileIdle：表示空闲时显示的游戏名 HoursUntilCardDrops：表示至少将游戏挂到几小时，如果是非限制账户，调到0是最好的。 我们也可以配置ASF本身的设置，这里也同样贴上我的配置：\n1 2 3 4 5 { \u0026#34;s_SteamOwnerID\u0026#34;: \u0026#34;xxx\u0026#34;, \u0026#34;CurrentCulture\u0026#34;: \u0026#34;zh-CN\u0026#34;, \u0026#34;IPCPassword\u0026#34;: \u0026#34;xxx\u0026#34; } s_SteamOwnerID：该属性定义 ASF 进程所有者的 64 位 Steam ID，直接设置成自己的大号就行 CurrentCulture：ASF的语言 IPCPassword：由于ASF默认会开启IPC服务，为了安全起见建议设置密码或关闭IPC服务。 将配置文件放入config目录里就行了。\n启动ASF 首先将ASF的主程序设置为可执行：\n1 sudo chmod 755 ./ArchiSteamFarm 然后运行即可：\n1 ./ArchiSteamFarm 附加步骤 使用ASCF 由于服务器在大陆境内，由于众所周知的原因是无法访问steam社区的，这时就需要使用大佬开发的转发工具了。\n【更新2.0】另一个SteamCommunityFix | 支持Win/Linux/MacOS 【2018-08-29】\n下载地址：https://pan.baidu.com/s/1nvBW8qP\n使用步骤：\n下载并解压缩\n打开终端（Terminal），进入到ascf程序目录： 如ascf程序在 /Users/Makazeu/Downloads/文件夹中，那么在终端中输入\n1 cd /Users/Makazeu/Downloads 赋予程序可执行权限，在终端中输入命令：\n1 chmod +x ./ascf 使用root用户（管理员用户）运行程序，在终端中输入\n1 sudo ./ascf 输入root用户密码后，看程序是否运行 因为程序涉及到hosts文件修改，需要高权限，所以你需要输入root密码\n若程序已经成功运行，此时就不要关闭终端窗口了，否则程序就会退出！试下Steam社区能否正常打开\n使用Tmux 由于我们在服务器上使用，不可能一直开着ssh，这时就需要将终端窗口和会话解绑，Tmux就是做这个工作的。\n安装：\n1 2 3 4 5 6 7 8 # Ubuntu 或 Debian $ sudo apt-get install tmux # CentOS 或 Fedora $ sudo yum install tmux # Mac $ brew install tmux 常用命令/快捷键：\n新建会话：Tmux 窗口默认是以0、1、2\u0026hellip;\u0026hellip;来编号的，为了便于区分，可以为每个会话起名\n1 tmux new -s \u0026lt;session-name\u0026gt; 分离当前会话：Ctrl+b d\n列出所有会话：Ctrl+b s或tmux ls\n重命名当前会话：Ctrl+b $或tmux rename-session -t 0 \u0026lt;new-name\u0026gt;\n接入到某个会话：\n1 2 3 4 5 # 使用会话编号 $ tmux attach -t 0 # 使用会话名称 $ tmux attach -t \u0026lt;session-name\u0026gt; 切换到某个会话：\n1 2 3 4 5 # 使用会话编号 $ tmux switch -t 0 # 使用会话名称 $ tmux switch -t \u0026lt;session-name\u0026gt; 参考链接 Tmux 使用教程 - 阮一峰的网络日志 ASF官方Wiki NET开发文档 ","date":"2021-08-11T21:46:24+08:00","image":"https://lbqaq.top/p/asf/82970659.webp","permalink":"https://lbqaq.top/p/asf/","title":"从零开始ASF挂卡"},{"content":"花了四天的时间，终于把MyBatis的视频教程全部看完了，为了以后不要那么快的遗忘掉，还是来写一下笔记比较好。\n下面的内容都是基于遇见狂神说的MyBatis视频教程而来，在此感谢能提供这么优秀的教程。\n简介 MyBatis的作用用我自己的话说，就是不用自己手动搞JDBC了，省事，行！ MyBatis作用于持久层——DAO层 【DAO (Data Access Object) 数据访问对象】，通俗点说就是用来操作数据库的层 选择MyBatis的最大原因还是用的人多，为后面的Spring打基础_(:з)∠)_ 第一个MyBatis程序 思路流程：搭建环境\u0026ndash;\u0026gt;导入MyBatis\u0026mdash;\u0026gt;编写代码\u0026mdash;\u0026gt;测试\n具体代码 创建Maven项目\n引入依赖包\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!-- 导入依赖 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- mysql驱动 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.25\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- junit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 在resources目录下创建mybatis-config.xml，作为MyBatis的配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;!--核心配置文件--\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!--每一个mapper都需要注册--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;UserMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; 编写MyBatis工具类，在utils的包下面创建MybatisUtils类，填入以下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; //SqlSessionFactory /** * @author luoboQAQ */ public class MybatisUtils { private static SqlSessionFactory sqlSessionFactory; static { try { //使用Mybatis第一步：获取SqlSessionFactory String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。 //SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。 public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(); } } 在pojo包下创建实体类\n1 2 3 4 5 6 7 8 9 public class User { private int id; //id private String name; //姓名 private String pwd; //密码 //构造,有参,无参 //set/get //toString() } 在dao包下创建接口类，我们需要的功能就填入到这里面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import top.lbqaq.pojo.User; import java.util.List; import java.util.Map; public interface UserMapper { //模糊查询 List\u0026lt;User\u0026gt; getUserLike(String value); //查询全部用户 List\u0026lt;User\u0026gt; getUserList(); //根据ID查询用户 User getUserById(int id); //插入用户 int addUser(User user); int addUser2(Map\u0026lt;String,Object\u0026gt; map); //修改用户 int updateUser(User user); //删除用户 int deleteUser(int id); } 编写Mapper.xml配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!--namespace绑定一个对应的Dao/Mapper接口--\u0026gt; \u0026lt;mapper namespace=\u0026#34;top.lbqaq.dao.UserMapper\u0026#34;\u0026gt; \u0026lt;!--id就是namespace中对应的方法名，resultType：sql语句的返回值--\u0026gt; \u0026lt;select id=\u0026#34;getUserList\u0026#34; resultType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;getUserLike\u0026#34; resultType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; select * from user where name like #{value} \u0026lt;/select\u0026gt; \u0026lt;!--parameterType：传入参数类型--\u0026gt; \u0026lt;select id=\u0026#34;getUserById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; select * from user where id=#{id} \u0026lt;/select\u0026gt; \u0026lt;insert id=\u0026#34;addUser\u0026#34; parameterType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; insert into user (id,name,pwd) values (#{id},#{name},#{pwd}) \u0026lt;/insert\u0026gt; \u0026lt;!--传递map的key--\u0026gt; \u0026lt;insert id=\u0026#34;addUser2\u0026#34; parameterType=\u0026#34;map\u0026#34;\u0026gt; insert into user (id,name,pwd) values (#{userid},#{userName},#{passWord}) \u0026lt;/insert\u0026gt; \u0026lt;update id=\u0026#34;updateUser\u0026#34; parameterType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; update user set name =#{name},pwd=#{pwd} where id=#{id} \u0026lt;/update\u0026gt; \u0026lt;delete id=\u0026#34;deleteUser\u0026#34; parameterType=\u0026#34;int\u0026#34;\u0026gt; delete from user where id=#{id} \u0026lt;/delete\u0026gt; \u0026lt;/mapper\u0026gt; 进行测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 import org.apache.ibatis.session.SqlSession; import org.junit.Test; import top.lbqaq.pojo.User; import top.lbqaq.utils.MybatisUtils; import java.util.HashMap; import java.util.List; public class UserMapperTest { @Test public void test() { //获得sqlSession对象 try (SqlSession sqlSession = MybatisUtils.getSqlSession()) { //执行SQL UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u0026lt;User\u0026gt; userList = mapper.getUserList(); for (User user : userList) { System.out.println(user); } } } @Test public void getUserLike() { //获得sqlSession对象 try (SqlSession sqlSession = MybatisUtils.getSqlSession()) { //执行SQL UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u0026lt;User\u0026gt; userList = mapper.getUserLike(\u0026#34;%李%\u0026#34;); for (User user : userList) { System.out.println(user); } } } @Test public void getUserById() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); sqlSession.close(); } @Test public void addUser(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); int res = mapper.addUser(new User(4, \u0026#34;小明\u0026#34;, \u0026#34;123\u0026#34;)); if(res\u0026gt;0){ System.out.println(\u0026#34;提交成功\u0026#34;); //提交事务 sqlSession.commit(); } sqlSession.close(); } @Test public void addUser2(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap\u0026lt;String,Object\u0026gt; map= new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;userid\u0026#34;,5); map.put(\u0026#34;userName\u0026#34;,\u0026#34;小绿\u0026#34;); map.put(\u0026#34;passWord\u0026#34;,\u0026#34;1234\u0026#34;); int res = mapper.addUser2(map); if(res\u0026gt;0){ System.out.println(\u0026#34;提交成功\u0026#34;); //提交事务 sqlSession.commit(); } sqlSession.close(); } @Test public void updateUser(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); int res = mapper.updateUser(new User(4, \u0026#34;小明\u0026#34;, \u0026#34;123456\u0026#34;)); if(res\u0026gt;0){ System.out.println(\u0026#34;提交成功\u0026#34;); //提交事务 sqlSession.commit(); } sqlSession.close(); } @Test public void deleteUser(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); int res = mapper.deleteUser(4); if(res\u0026gt;0){ System.out.println(\u0026#34;提交成功\u0026#34;); //提交事务 sqlSession.commit(); } sqlSession.close(); } } 注意事项 如果Mapper.xml创建在java目录里而不是resouces里，需要在Maven配置里配置过滤，否则会保错\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; 当需要传入参数进行查询而不是传入实体类，有两种方法\n第一种：直接在方法中传递参数。\n在接口方法的参数前加@Param属性，sql语句编写的时候，直接取@Param中设置的值即可，不需要单独设置参数类型\n1 2 3 4 5 6 7 User selectUserByNP(@Param(\u0026#34;username\u0026#34;) String username,@Param(\u0026#34;pwd\u0026#34;) String pwd); /* \u0026lt;select id=\u0026#34;selectUserByNP\u0026#34; resultType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; select * from user where name = #{username} and pwd = #{pwd} \u0026lt;/select\u0026gt; */ 第二种：通过map来传递参数。（推荐）\n在接口创建时就直接使用map作为参数\n1 int addUser2(Map\u0026lt;String,Object\u0026gt; map); 在写sql时直接设置入参为map即可\n1 2 3 4 \u0026lt;!--传递map的key--\u0026gt; \u0026lt;insert id=\u0026#34;addUser2\u0026#34; parameterType=\u0026#34;map\u0026#34;\u0026gt; insert into user (id,name,pwd) values (#{userid},#{userName},#{passWord}) \u0026lt;/insert\u0026gt; 配置解析 官方文档\n核心配置 MyBatis官方给出的配置项有以下这么多：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） \u0026lt;!-- 注意元素节点的顺序！顺序不对会报错 --\u0026gt; 我们需要关注的就是properties（属性）、settings（设置）、typeAliases（类型别名）、plugins（插件）、environments（环境配置）、mappers（映射器）这几项配置，其余的可以忽略（基本用不到）\nproperties 数据库这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。\n说白了，就是能将数据库那些配置项从核心配置中剥离出来，降低耦合。\n用法 在resources目录下创建db.properties，填入下面的内容\n1 2 3 4 driver=com.mysql.cj.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis username=root password=root 在配置xml中导入\n1 2 3 4 5 6 \u0026lt;!--引用外部配置文件--\u0026gt; \u0026lt;properties resource=\u0026#34;db.properties\u0026#34;\u0026gt; \u0026lt;!--外部文件优先级大于内部（下面）--\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123\u0026#34;/\u0026gt; \u0026lt;/properties\u0026gt; 正常情况下，只需要用\u0026lt;properties resource=\u0026quot;db.properties\u0026quot;/\u0026gt;这短短一句就行了，上面的代码是用来测试优先级的\nsettings 这里存放的是MyBatis的一些设置项，具体的内容在官方文档上可以查看\n常用的设置项有以下几个：\n设置名 描述 有效值 默认值 cacheEnabled 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。 true | false true mapUnderscoreToCamelCase 是否开启驼峰命名自动映射，即从经典数据库列名A_COLUMN 映射到经典 Java 属性名 aColumn。 true | false False logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 未设置 typeAliases 类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。\n也就是在resultType和parameterType中不需要写那么长的类名了\n用法 1 2 3 4 5 6 7 \u0026lt;!--可以给实体类起别名--\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;!--手动指定--\u0026gt; \u0026lt;typeAlias type=\u0026#34;top.lbqaq.pojo.User\u0026#34; alias=\u0026#34;User\u0026#34;/\u0026gt; \u0026lt;!--自动扫描包下所有类，别名为类名全小写--\u0026gt; \u0026lt;package name=\u0026#34;top.lbqaq.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; 有两种方法，第一种就是手动指定别名，第二种就是通过package标签自动扫描包下所有的类\n在第二种方法下，默认别名是类名全小写（当然首字母大写也同样可用）\n如果在类前加上@Alias注解，则别名就为手动设定的内容。\nplugins 这里是配置mybatis的插件的地方，常用的插件有以下几个：\nPageHelper MyBatis-Plus \u0026hellip; \u0026hellip; 这里是就不展开这些插件了，以后有需要再看\nenvironments 配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定）。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; transactionManager： 事务管理器 。有两个选项： JDBC：正常的 MANAGED：几乎啥都不干 dataSource：如何使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。有三个选项： unpooled：这个数据源的实现只是每次被请求时打开和关闭连接。 pooled：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。 jndi：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 mappers 用于告诉MyBatis我们写的xml文件到底在哪，每个xml文件都需要绑定！\n常用的有以下几种方法：\n1 2 3 4 \u0026lt;!-- 使用相对于类路径的资源引用 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;top/lbqaq/dao/UserMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 1 2 3 4 5 6 7 \u0026lt;!-- 使用映射器接口实现类的完全限定类名 需要配置文件名称和接口名称一致，并且位于同一目录下 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026#34;top.lbqaq.dao.UserMapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 1 2 3 4 5 6 7 \u0026lt;!-- 将包内的映射器接口实现全部注册为映射器 但是需要配置文件名称和接口名称一致，并且位于同一目录下 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;package name=\u0026#34;org.mybatis.builder\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; ResultMap 属性名和字段名不一致 在实际开发中，会遇到类的属性名和数据库的字段名不一致，这时MyBatis的自动匹配将无法产生作用，这时可以使用ResultMap来解决这个问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;mapper namespace=\u0026#34;top.lbqaq.dao.UserMapper\u0026#34;\u0026gt; \u0026lt;!--结果集映射--\u0026gt; \u0026lt;resultMap id=\u0026#34;UserMap\u0026#34; type=\u0026#34;User\u0026#34;\u0026gt; \u0026lt;!--column:数据库中的字段；property：实体类的属性--\u0026gt; \u0026lt;!-- \u0026lt;result column=\u0026#34;id\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;result column=\u0026#34;name\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;result column=\u0026#34;pwd\u0026#34; property=\u0026#34;password\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getUserById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultMap=\u0026#34;UserMap\u0026#34;\u0026gt; select * from user where id=#{id} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 多对一 在开发时常常会有这样的需求，比如多个学生都被一个老师教，下面将对该实例具体展开来了解多对一如何处理。\n环境搭建 添加Lombok插件\n引入Maven依赖\n1 2 3 4 5 6 7 8 9 \u0026lt;dependencies\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.20\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 编写实体类\n1 2 3 4 5 6 7 8 9 10 @Data public class Student { private int id; private String name; /** * 学生需要关联一个老师 */ private Teacher teacher; } 1 2 3 4 5 @Data public class Teacher { private int id; private String name; } 按查询嵌套处理 思路：\n获取所有学生的信息\n根据获取的学生信息的老师ID-\u0026gt;获取该老师的信息\n思考问题，这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般使用关联查询？\n做一个结果集映射：StudentTeacher StudentTeacher结果集的类型为 Student 学生中老师的属性为teacher，对应数据库中为tid。 多个 [1,\u0026hellip;）学生关联一个老师=\u0026gt; 一对一，一对多 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;select id=\u0026#34;getStudent\u0026#34; resultMap=\u0026#34;StudentTeacher\u0026#34;\u0026gt; select * from student \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;StudentTeacher\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;id\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;name\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;!--复杂的属性需要单独处理 对象：association 集合：collection--\u0026gt; \u0026lt;association column=\u0026#34;tid\u0026#34; property=\u0026#34;teacher\u0026#34; javaType=\u0026#34;Teacher\u0026#34; select=\u0026#34;getTeacher\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultType=\u0026#34;Teacher\u0026#34;\u0026gt; select * from teacher where id=#{tid} \u0026lt;/select\u0026gt; 注意点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;resultMap id=\u0026#34;StudentTeacher\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--\u0026gt; \u0026lt;association property=\u0026#34;teacher\u0026#34; column=\u0026#34;{id=tid,name=tid}\u0026#34; javaType=\u0026#34;Teacher\u0026#34; select=\u0026#34;getTeacher\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!-- 这里传递过来的id，只有一个属性的时候，下面可以写任何值 association中column多参数配置： column=\u0026#34;{key=value,key=value}\u0026#34; 其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。 --\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultType=\u0026#34;teacher\u0026#34;\u0026gt; select * from teacher where id = #{id} and name = #{name} \u0026lt;/select\u0026gt; 这个还是比较难以理解的，一般我选择用第二种方法\n按结果嵌套处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!--按照结果嵌套处理--\u0026gt; \u0026lt;select id=\u0026#34;getStudent2\u0026#34; resultMap=\u0026#34;StudentTeacher2\u0026#34;\u0026gt; select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid=t.id \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;StudentTeacher2\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;sid\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;sname\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;association property=\u0026#34;teacher\u0026#34; javaType=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;tname\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; 这种就比较好理解了，难度主要在sql部分，好在之前数据库学的还行，这种方法还是比较适合我。\n一对多 一个老师会教多个学生。\n环境搭建 1 2 3 4 5 6 @Data public class Student { private int id; private String name; private int tid; } 1 2 3 4 5 6 7 8 9 10 @Data public class Teacher { private int id; private String name; /** * 一个老师有多个学生 */ private List\u0026lt;Student\u0026gt; students; } 按结果嵌套查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;!--按结果嵌套查询--\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultMap=\u0026#34;TeacherStudent\u0026#34;\u0026gt; select s.id sid,s.name sname,t.name tname,t.id tid from student s,teacher t where s.tid=t.id and t.id=#{tid} \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;TeacherStudent\u0026#34; type=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;tid\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;tname\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;!--集合中的泛型信息用ofType获取--\u0026gt; \u0026lt;collection property=\u0026#34;students\u0026#34; ofType=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;sid\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;sname\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;tid\u0026#34; property=\u0026#34;tid\u0026#34;/\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt; JavaType和ofType都是用来指定对象类型的。\nJavaType是用来指定pojo中属性的类型。\nofType指定的是映射到list集合属性中pojo的类型。\n按查询嵌套 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!--按查询嵌套--\u0026gt; \u0026lt;select id=\u0026#34;getTeacher2\u0026#34; resultMap=\u0026#34;TeacherStudent2\u0026#34;\u0026gt; select * from teacher where id=#{tid} \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;TeacherStudent2\u0026#34; type=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;collection property=\u0026#34;students\u0026#34; javaType=\u0026#34;ArrayList\u0026#34; ofType=\u0026#34;Student\u0026#34; select=\u0026#34;getStudentByTeacherId\u0026#34; column=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getStudentByTeacherId\u0026#34; resultType=\u0026#34;Student\u0026#34;\u0026gt; select * from student where tid = #{tid} \u0026lt;/select\u0026gt; 日志工厂 如果一个数据库相关的操作出现了问题，我们可以根据输出的SQL语句快速排查问题。可见打印出SQL语句是十分重要的。（还记得之前项目综合实践为了搞日志忙了半天，结果还是没搞出来😭）\n标准日志 在MyBatis里自带了通过控制台打印的日志功能，如果项目并不是很复杂，用它就足够了。\n只需要在设置里设置启用就可以了。\n1 2 3 \u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;STDOUT_LOGGING\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; log4j log4j相比标准日志，那不知道高到哪里去了，具体的功能我就不写了，毕竟一百度就能出来了。\n使用步骤：\n导入log4j的包\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在resources目录下新建log4j.properties，并填入以下配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码 log4j.rootLogger=DEBUG,console,file #控制台输出的相关设置 log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n #文件输出的相关设置 log4j.appender.file = org.apache.log4j.RollingFileAppender log4j.appender.file.File=./log/log.log log4j.appender.file.MaxFileSize=10mb log4j.appender.file.Threshold=DEBUG log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n #日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG 在MyBatis里启用\n1 2 3 \u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;LOG4J\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; 在程序中使用Log4j进行输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 import org.apache.log4j.Logger; import org.junit.Test; public class UserMapperTest { static Logger logger = Logger.getLogger(UserMapperTest.class); @Test public void testLog4j(){ logger.info(\u0026#34;info:进入了testLog4j\u0026#34;); logger.debug(\u0026#34;debug:进入了testLog4j\u0026#34;); logger.error(\u0026#34;error:进入了testLog4j\u0026#34;); } } 使用注解开发 MyBatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。\n而到MyBatis 3提供了新的基于注解的配置。不幸的是，Java 注解的的表达力和灵活性十分有限。最强大的 MyBatis 映射并不能用注解来构建。\n在注解开发中，主要使用这几个注解：@select ()、@update ()、@Insert ()、@delete ()\n举例：\n1 2 3 4 5 6 7 8 9 10 11 public interface UserMapper { @Select(\u0026#34;select * from user\u0026#34;) List\u0026lt;User\u0026gt; getUser(); @Select(\u0026#34;select * from user where id=#{id}\u0026#34;) User getUserByID(@Param(\u0026#34;id\u0026#34;) int id); @Insert(\u0026#34;insert into user(id,name,pwd) values(#{id},#{name},#{pwd})\u0026#34;) int addUser(User user); } 改造MybatisUtils工具类的getSession() 方法，重载实现。\n1 2 3 4 5 6 7 8 //获取SqlSession连接 public static SqlSession getSession(){ return getSession(true); //事务自动提交 } public static SqlSession getSession(boolean flag){ return sqlSessionFactory.openSession(flag); } @Param注解用于给方法参数起一个名字。以下是总结的使用原则：\n在方法只接受一个参数的情况下，可以不使用@Param。 在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。 如果参数是 JavaBean ， 则不能使用@Param。 不使用@Param注解时，参数只能有一个，并且是JavaBean。 动态SQL 动态SQL指的是根据不同的查询条件 , 生成不同的sql语句。\n主要使用这几个标签：if、choose、where、set、foreach\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;top.lbqaq.dao.BlogMapper\u0026#34;\u0026gt; \u0026lt;insert id=\u0026#34;addBook\u0026#34; parameterType=\u0026#34;Blog\u0026#34;\u0026gt; insert into blog(id, title, author, create_time, views) values (#{id}, #{title}, #{author}, #{createTime}, #{views}) \u0026lt;/insert\u0026gt; \u0026lt;select id=\u0026#34;queryBlogIF\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;queryBlogChoose\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; and views = #{view} \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;update id=\u0026#34;updateBlog\u0026#34; parameterType=\u0026#34;map\u0026#34;\u0026gt; update blog \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id = #{id} \u0026lt;/update\u0026gt; \u0026lt;select id=\u0026#34;queryBlogForeach\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;!--collection:指定输入对象中的集合属性 item:每次遍历生成的对象 open:开始遍历时的拼接字符串 close:结束时拼接的字符串 separator:遍历对象之间需要拼接的字符串--\u0026gt; \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34; separator=\u0026#34;or\u0026#34;\u0026gt; id = #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; SQL片段 有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。\n提取SQL片段：\n1 2 3 4 5 6 7 8 \u0026lt;sql id=\u0026#34;if-title-author\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/sql\u0026gt; 引用SQL片段：\n1 2 3 4 5 6 7 8 \u0026lt;select id=\u0026#34;queryBlogIf\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --\u0026gt; \u0026lt;include refid=\u0026#34;if-title-author\u0026#34;\u0026gt;\u0026lt;/include\u0026gt; \u0026lt;!-- 在这里还可以引用其他的 sql 片段 --\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 注意：\n①、最好基于 单表来定义 sql 片段，提高片段的可重用性\n②、在 sql 片段中不要包括 where\n缓存 简介 1、什么是缓存 [ Cache ]？\n存在内存中的临时数据。 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。 2、为什么使用缓存？\n减少和数据库的交互次数，减少系统开销，提高系统效率。 3、什么样的数据能使用缓存？\n经常查询并且不经常改变的数据。 MyBatis缓存 MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。\nMyBatis系统中默认定义了两级缓存：一级缓存和二级缓存\n默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 一级缓存 一级缓存也叫本地缓存：\n与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库； 一级缓存失效的四种情况 sqlSession不同 sqlSession相同，查询条件不同 sqlSession相同，两次查询之间执行了增删改操作！ sqlSession相同，手动清除一级缓存 二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存\n基于namespace级别的缓存，一个名称空间，对应一个二级缓存；\n工作机制\n一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存（map）中； 使用方法 开启全局缓存 mybatis-config.xml\n1 \u0026lt;setting name=\u0026#34;cacheEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; 去每个mapper.xml中配置使用二级缓存，这个配置非常简单。\n1 2 3 4 5 6 7 8 9 \u0026lt;cache/\u0026gt; 官方示例 \u0026lt;cache eviction=\u0026#34;FIFO\u0026#34; flushInterval=\u0026#34;60000\u0026#34; size=\u0026#34;512\u0026#34; readOnly=\u0026#34;true\u0026#34;/\u0026gt; 这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。 ","date":"2021-08-11T11:11:10+08:00","image":"https://lbqaq.top/p/mybatis/86164137.webp","permalink":"https://lbqaq.top/p/mybatis/","title":"MyBatis学习笔记"},{"content":"这篇文章我打算来介绍一下如何构建qsqlmysql.dll，由于版权原因，在新版的Qt里是不自带该dll的，这样对我们编写数据库程序会很麻烦。（你用ODBC？那没事了）\n我在网上也查了很多资料，但根据步骤来总是会报错，提示没有mysql.h这个头文件。下面就记录一下我成功编译的过程。\n基于cmake的步骤 在6.1之后的Qt版本中，Qt公司删除了qmake而更换成了cmake的方式来构建项目文件，下面就是我总结的使用cmake生成的方法。\n注意： 路径的前段部分(软件的安装位置)每个人可能都不一样，但是路径的后段部分应该是一样的，请自行修改。\n1.准备好Qt的源代码，如果没有可以在Qt的安装目录打开MaintenanceTool.exe启动Qt组件管理，在里面勾选Src把源码下载下来。\n2.打开cmake-gui，选择目标文件夹为D:\\Qt\\6.1.1\\Src\\qtbase\\src\\plugins\\sqldrivers，并设置生成文件夹为D:/Qt/6.1.1/Src/qtbase/src/plugins/sqldrivers/build\n3.点击左下角的Configure，会提示生成的目录不存在是否创建，直接点是就可以了。\n4.编译器这里选择MinGW Makefiles,然后点击Finish\n5.等待生成完成后，把FEATURE_sql_mysql后面的勾勾上，然后把其余的FEATURE_sql后面的勾取消。\n6.再次点击左下角的Configure，可以发现上面的红框已经消失了，说明配置成功了。然后点击Generate，生成Makefiles。\n7.这时配置文件已经构建完成了，接下来就是生成dll了，打开PowerShell切换目录至D:/Qt/6.1.1/Src/qtbase/src/plugins/sqldrivers/build，输入mingw32-make开始编译生成dll。\n没有报错，说明生成成功。\n8.最后打开目录D:\\Qt\\6.1.1\\Src\\qtbase\\src\\plugins\\sqldrivers\\build\\plugins\\sqldrivers，就可以看到生成好的qsqlmysql.dll了。\n基于qmake的步骤 注意： 路径的前段部分(软件的安装位置)每个人可能都不一样，但是路径的后段部分应该是一样的，请自行修改。\n1.准备好Qt的源代码，如果没有可以在Qt的安装目录打开MaintenanceTool.exe启动Qt组件管理，在里面勾选Src把源码下载下来。\n2.进入D:\\Qt\\6.0.3\\Src\\qtbase\\src\\plugins\\sqldrivers目录下，打开sqldrivers.pro这个文件。\n3.在左侧文件树中打开mysql文件夹，选择mysql.pro打开。\n4.修改里面的内容：\n注释掉QMAKE_USE += mysql这一句\n增加下面三行代码(注意把D:/MySQL/改为你MySQL的安装路径)：\n1 2 3 LIBS +=-LD:/MySQL/lib -llibmysql INCLUDEPATH += D:/MySQL/include DEPENDPATH += D:/MySQL/include 5.点击Qt左下角的小锤子进行构建，不出意外的话就可以在D:\\Qt\\6.0.3\\Src\\qtbase\\src\\plugins这个路径下看到build开头的文件夹，在.\\plugins\\sqldrivers目录下就能看到编译好的dll了。\n6.最后将qsqlmysql.dll放入D:\\Qt\\6.0.3\\mingw81_64\\plugins\\sqldrivers\\里就行了。如果链接数据库时还报错，就把libmysql.dll复制到Qt的编译器的D:\\Qt\\6.0.3\\mingw81_64\\bin\\目录。\n","date":"2021-06-03T15:44:17+08:00","image":"https://lbqaq.top/p/qt%E6%9E%84%E5%BB%BAqsqlmysql.dll/89217963.webp","permalink":"https://lbqaq.top/p/qt%E6%9E%84%E5%BB%BAqsqlmysql.dll/","title":"Qt构建qsqlmysql.dll"},{"content":"1202年了，是时候抛弃老旧的cmd窗口和臃肿的VM虚拟机了，来试试巨硬推出的WSL2+Windows Terminal(～￣▽￣)～。\n起因 在知乎上刷到了一篇回答，是关于Windows编程的体验的。在这篇文章中提到了WSL2和Windows Terminal，我一下就被那精美的界面吸引了（管他好不好用，好看就完事了）。正好现在在上操作系统这门课，需要使用Linux进行实验，这还说什么，直接开冲。\nWSL2安装 安装其实很简单，按照微软的教程一步一步做就完事了。\n0.前置条件 想要用WSL2，首先你得是 Windows 10，而且还有版本号要求。\n对于 x64 系统：版本 1903 或更高版本，采用 内部版本 18362 或更高版本。 对于 ARM64 系统：版本 2004 或更高版本，采用 内部版本 19041 或更高版本。 1. 开启WSL服务 在Powershell(管理员)中输入下面的命令：\n1 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 2. 启用虚拟机服务 在Powershell(管理员)中输入下面的命令：\n1 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 重新启动 计算机，以完成 WSL 安装并更新到 WSL 2。\n3. 下载 Linux 内核更新包 下载最新包并安装：\n适用于 x64 计算机的 WSL2 Linux 内核更新包 4. 将 WSL 2 设置为默认版本 在Powershell中输入下面的命令：\n1 wsl --set-default-version 2 5.安装 Linux 打开 Microsoft Store，并选择你偏好的 Linux 分发版并点击获取进行安装。 等安装好后，打开并设置用户名和密码。 到此WSL2就安装完事了。\nWindows Terminal安装 1. 下载和安装 从Microsoft Store中下载\n从Github上下载\n2. 配置 为了让Windows Terminal看起来更好看一些，我们还要对其进行一些配置。\n打开Windows Terminal的设置选项，然后选打开JSON文件，把我配好的配置文件粘贴进去\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 { \u0026#34;$schema\u0026#34;: \u0026#34;https://aka.ms/terminal-profiles-schema\u0026#34;, // Add custom actions and keybindings to this array. // To unbind a key combination from your defaults.json, set the command to \u0026#34;unbound\u0026#34;. // To learn more about actions and keybindings, visit https://aka.ms/terminal-keybindings \u0026#34;actions\u0026#34;: [ // Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json. // These two lines additionally bind them to Ctrl+C and Ctrl+V. // To learn more about selection, visit https://aka.ms/terminal-selection { \u0026#34;command\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;copy\u0026#34;, \u0026#34;singleLine\u0026#34;: false }, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+c\u0026#34; }, { \u0026#34;command\u0026#34;: \u0026#34;paste\u0026#34;, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+v\u0026#34; }, // Press Ctrl+Shift+F to open the search box { \u0026#34;command\u0026#34;: \u0026#34;find\u0026#34;, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+shift+f\u0026#34; }, // Press Alt+Shift+D to open a new pane. // - \u0026#34;split\u0026#34;: \u0026#34;auto\u0026#34; makes this pane open in the direction that provides the most surface area. // - \u0026#34;splitMode\u0026#34;: \u0026#34;duplicate\u0026#34; makes the new pane use the focused pane\u0026#39;s profile. // To learn more about panes, visit https://aka.ms/terminal-panes { \u0026#34;command\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;splitPane\u0026#34;, \u0026#34;split\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;splitMode\u0026#34;: \u0026#34;duplicate\u0026#34; }, \u0026#34;keys\u0026#34;: \u0026#34;alt+shift+d\u0026#34; } ], \u0026#34;copyFormatting\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;copyOnSelect\u0026#34;: false, \u0026#34;defaultProfile\u0026#34;: \u0026#34;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\u0026#34;, \u0026#34;initialCols\u0026#34;: 120, \u0026#34;initialRows\u0026#34;: 30, \u0026#34;profiles\u0026#34;: { \u0026#34;defaults\u0026#34;: { \u0026#34;acrylicOpacity\u0026#34;: 0.75, \u0026#34;closeOnExit\u0026#34;: \u0026#34;graceful\u0026#34;, \u0026#34;colorScheme\u0026#34;: \u0026#34;Campbell\u0026#34;, \u0026#34;cursorColor\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, \u0026#34;cursorShape\u0026#34;: \u0026#34;bar\u0026#34;, \u0026#34;fontFace\u0026#34;: \u0026#34;Consolas\u0026#34;, \u0026#34;fontSize\u0026#34;: 13, \u0026#34;historySize\u0026#34;: 9001, \u0026#34;padding\u0026#34;: \u0026#34;0, 0, 0, 0\u0026#34;, \u0026#34;snapOnInput\u0026#34;: true, \u0026#34;startingDirectory\u0026#34;: \u0026#34;./\u0026#34;, \u0026#34;useAcrylic\u0026#34;: true }, \u0026#34;list\u0026#34;: [ { \u0026#34;commandline\u0026#34;: \u0026#34;powershell.exe -NoLogo\u0026#34;, \u0026#34;guid\u0026#34;: \u0026#34;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Windows PowerShell\u0026#34; }, { \u0026#34;commandline\u0026#34;: \u0026#34;cmd.exe\u0026#34;, \u0026#34;guid\u0026#34;: \u0026#34;{0caa0dad-35be-5f56-a8ff-afceeeaa6101}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Command Prompt\u0026#34; }, { \u0026#34;guid\u0026#34;: \u0026#34;{b453ae62-4e3d-5e58-b989-0a998ec441b8}\u0026#34;, \u0026#34;hidden\u0026#34;: true, \u0026#34;name\u0026#34;: \u0026#34;Azure Cloud Shell\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;Windows.Terminal.Azure\u0026#34; }, { \u0026#34;guid\u0026#34;: \u0026#34;{2c4de342-38b7-51cf-b940-2309a097f518}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Ubuntu\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;Windows.Terminal.Wsl\u0026#34;, \u0026#34;startingDirectory\u0026#34;: \u0026#34;//wsl$/Ubuntu/home/luobo\u0026#34; } ] } } 一般要修改这几项：\nfontFace - 字体，我的字体为Consolas，适合1080P的屏幕。高分辩率屏建议用monaco或者fira code fontSize - 字体大小，因人而异，因屏幕而异，自己根据视觉效果调整大小 acrylicOpacity - 背景透明度，同样因人而异，因屏幕而异，自己根据视觉效果调整大小 initialCols - 初始窗口宽度，同样因人而异，因屏幕而异，自己根据视觉效果调整大小 initialRows - 初始窗口高度，同样因人而异，因屏幕而异，自己根据视觉效果调整大小 startingDirectory - Ubuntu的默认打开路径，把其中的luobo换成你自己的用户名。 WSL+VSCode 毕竟都是微软家的软件，直接就能通过VSCode来远程编辑Linux里的文件。vim太难上手？我直接在Windows里编程(雾)。\n只要在项目目录里键入code .，就会自动跳到Windows里的VSCode里了。\n小结 WSL+Windows Terminal+VSCode，将三者配合起来，我觉得可以实现1+1+1\u0026gt;3的功能，毕竟，谁不喜欢颜值高的软件呢ヾ(≧▽≦*)o\n参考链接 微软官方WSL2教程 微软官方Windows Terminal教程 Windows Terminal 终端入门 ","date":"2021-04-08T13:14:20+08:00","image":"https://lbqaq.top/p/wsl2-wt%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93/43493473.webp","permalink":"https://lbqaq.top/p/wsl2-wt%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93/","title":"WSL2+WT配置小结"},{"content":"看到zsnmwy大佬的博客，和我使用的是同样的主题，但是人家却多了一些动画，瞬间就高级起来了。于是打开百度搜素一波，发现只要改一下CSS就可以实现了。\n准备工具 hugo的扩展版（extended）\n这里一定要下扩展版，因为我使用的主题都是利用scss来生成css的，如果用普通版是无法利用scss生成对应的css的。之前不知道下的是普通版，结果怎么改scss都没有效果，浪费了很多时间😥。\n相关代码 1.头像转动 在themes/hugo-theme-stack/assets/scss/partials/sidebar.scss中增加以下代码：\n1 2 3 4 5 6 7 .site-logo { transition: all 1.75s ease-out; } .site-logo:hover { transform: rotate(360deg); } 2.文章头图缩放 在themes/hugo-theme-stack/assets/scss/partials/article.scss中增加以下代码：\n1 2 3 4 5 6 7 8 9 10 .article-image { overflow:hidden; } .article-image { img { transition:all .5s ease; } \u0026amp;:hover{ transform:scale(1.2); } 3.Archives页面缩放 在themes/hugo-theme-stack/assets/scss/partials/article.scss中增加以下代码：\n1 2 3 4 5 6 7 8 9 article{ transition:.5s ease; } article { \u0026amp;:hover{ transform:scale(1.05,1.05); background:#f0f8ff; } } 4.菜单缩放 在themes/hugo-theme-stack/assets/scss/partials/menu.scss中增加以下代码：\n1 2 3 4 5 6 7 8 9 overflow-y: visible; //把auto改为visible，为了图标放大溢出时不显示滚动条 li { transition:.5s ease; } li{ \u0026amp;:hover{ transform:scale(1.1,1.1); } } 有了动画后，感觉整个博客都变得高级起来了ヾ(•ω•`)o\n在这感谢zsnmwy大佬，上面有些动画懒得自己写了，就直接从他的css中复制了ヾ(￣▽￣)\n","date":"2021-02-01T13:55:05+08:00","image":"https://lbqaq.top/p/%E7%BB%99blog%E5%A2%9E%E5%8A%A0%E5%8A%A8%E7%94%BB/86589864.webp","permalink":"https://lbqaq.top/p/%E7%BB%99blog%E5%A2%9E%E5%8A%A0%E5%8A%A8%E7%94%BB/","title":"给Blog增加动画"},{"content":"最近刷了好几道关于STL的竞赛题，许多知识点还是不熟练，在继续学习之前，还是来好好整理一下一些常见的STL和容器吧。紫书上介绍的有以下几种：\n线性：vector,list,string 关联：map,set 特殊：stack,queue,priority_queue 算法：sort,lower_bound,find vector vector可以理解为可以自由变换长度的数组(不定长数组)，个人感觉使用频率还是很高的。vector是连续的，意味着可以使用[]或at()。\n声明： vector\u0026lt;int\u0026gt; a\n常用函数 push_back：在尾部添加一个数据\npop_back：删除尾部的一个数据\nsize：当前的大小（就是有多少元素）\nerase：删除指针指向的数据项\nclear：清空\nempty：判断是否为空\ndeque deque可以看作是双向队列，是连续存储结构。vector有的功能它都有，还支持高效的首/尾端插入/删除操作。\n新增函数 push_front：在头部添加一个数据 pop_front：在头部删除一个数据 list list可以看作是双链表，是非连续存储结构。可在两端进行push、pop，同时在内部可以很方便的进行插入和删除操作。不过我没怎么用到这个容器。等我做到相关的题目再来补充一些信息吧。\nstring string就是字符串。相比char[]那可是方便不少，c++的cin/cout就只支持string类型而不支持char型数组。string还支持+、=、+=等运算符。\n常用函数 append：在字符串后添加（相当于+=）\nsubstr(n,m)：返回string的子串，从n处开始，取m个。当m省略或超过了字符串的长度，则一直取到字符串结束。\n查找相关函数：\n如果没有查到，返回string::npos。\nfind：从前往后查找子串或字符出现的位置。\nrfind：从后往前查找子串或字符出现的位置。\nfind_first_of：从前往后查找何处出现另一个字符串中包含的字符。例如：\ns1.find_first_of(\u0026ldquo;abc\u0026rdquo;); //查找s1中第一次出现\u0026quot;abc\u0026quot;中任一字符的位置\nfind_last_of：从后往前查找何处出现另一个字符串中包含的字符。\nfind_first_not_of：从前往后查找何处出现另一个字符串中没有包含的字符。\nfind_last_not_of：从后往前查找何处出现另一个字符串中没有包含的字符。\n流处理 可以通过\u0026lt;sstream\u0026gt;，将string对象作为一个流。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main(){ string line; while(getline(cin,line)){ stringstream ss(line); while(ss\u0026gt;\u0026gt;x){...} } } set set就是数学中的集合，每个元素只能出现一次，set中的元素已经从小到大排好了。\n常用函数 insert：插入一个元素 erase：删除，可以传入定位器，也可直接传入值 count：统计元素出现的个数，因为只有0/1个，所以一般用来判断元素是否存在 find：查找 对于自己定义的结构体，需要重载\u0026lt;运算符。\n常用算法 在\u0026lt;algorithm\u0026gt;中提供了关于set的两种算法（目前只知道两种）\nset_union：取两个集合的并集，例如：\n1 2 3 #define ALL(x) x.begin(),x.end() #define INS(x) inserter(x,x.begin()) set_union(ALL(x1),ALL(x2),INS(x)); //将x1和x2的内容取并集后放入x中 set_intersection：取两个集合的交集，例如：\n1 set_intersection(ALL(x1),ALL(x2),INS(x)); //将x1和x2的内容取交集放入x中 map map是映射，支持[]运算符，还是非常实用的。\nmap的函数和set基本一致，这里就不重复写了。\nstack stack就是数据结构中的栈，数据是“后进先出”。\n基本函数 push：入栈 pop：出栈 top：取栈顶元素 要注意的是，使用pop()出栈并不会返回被删除的元素值，如果想要需要先top()一下\nqueue queue就是数据结构里的队列，数据符合“先进先出”的规则。\n基本函数 push：入队\npop：出队\nfront：取队首\npriority_queue 优先队列，将按照优先级来排序，取队首的front()的函数将换为top()。该容器也定义在头文件\u0026lt;queue\u0026gt;里。\n对于自定义数据类型的队列，需要定义\u0026lt;运算。对于已经定义过的数据类型，我们可以通过定义一个结构体，在其中重载()运算符来看起来像一个函数，例如：\n1 2 3 4 5 6 7 8 struct cmp { bool operator()(const int a, const int b) const { return abs(a) \u0026lt; abs(b); } }; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, cmp\u0026gt; p_queue; 这样就定义了一个绝对值大小优先的队列\n","date":"2021-01-31T20:39:29+08:00","image":"https://lbqaq.top/p/%E7%AB%9E%E8%B5%9B%E7%94%A8stl%E6%95%B4%E7%90%86/85526504.webp","permalink":"https://lbqaq.top/p/%E7%AB%9E%E8%B5%9B%E7%94%A8stl%E6%95%B4%E7%90%86/","title":"竞赛用STL整理"},{"content":"考前整理的算法，也顺便放到博客上吧ヾ(•ω•`)o\n数据结构代码复习 3.单链表逆置 带头结点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int Inverse_Link(LinkList *L) { LinkList *cur, *p; if (L-\u0026gt;next \u0026amp;\u0026amp; L-\u0026gt;next-\u0026gt;next) { p = L-\u0026gt;next-\u0026gt;next; L-\u0026gt;next-\u0026gt;next = NULL; while (p) { cur = L-\u0026gt;next; L-\u0026gt;next = p; p = p-\u0026gt;next; L-\u0026gt;next-\u0026gt;next = cur; } } return 0; } 5.双向链表 双链表定义：\n1 2 3 4 5 6 typedef struct DuLinkList { int data; struct DuLinkList *prior; struct DuLinkList *next; } DuLinkList; 遍历：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void Printlist_DuL(DuLinkList *L) { DuLinkList *s; s = L-\u0026gt;next; if (L-\u0026gt;next != NULL) { printf(\u0026#34;当前的双向链表值为：\u0026#34;); do { printf(\u0026#34;%d \u0026#34;, s-\u0026gt;data); s = s-\u0026gt;next; } while (s != NULL); } printf(\u0026#34;\\n\u0026#34;); } 交换：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int ListSwap_DuL(DuLinkList *L, int i) { //在带头结点的双向链表中交换第i个，i+1个位置的元素 DuLinkList *p = L, *q; int j = 0; while (p \u0026amp;\u0026amp; j \u0026lt; i - 1) { p = p-\u0026gt;next; j += 1; } if (!p || j \u0026gt; i - 1) return -1; p = p-\u0026gt;next; q = p-\u0026gt;next; p-\u0026gt;prior-\u0026gt;next = q; //1 -\u0026gt;q p 2 q-\u0026gt;prior = p-\u0026gt;prior; //1\u0026lt;--\u0026gt;q p 2 p-\u0026gt;next = q-\u0026gt;next; //1\u0026lt;--\u0026gt;q p -\u0026gt;2 q-\u0026gt;next-\u0026gt;prior = p; //1\u0026lt;--\u0026gt;q p\u0026lt;--\u0026gt;2 q-\u0026gt;next = p; //1\u0026lt;--\u0026gt;q -\u0026gt;p\u0026lt;--\u0026gt;2 p-\u0026gt;prior = q; //1\u0026lt;--\u0026gt;q\u0026lt;--\u0026gt;p\u0026lt;--\u0026gt;2 return 0; } 6.链表回文 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 bool isPalindrome(struct ListNode *head) { Lstack *s; int e; struct ListNode *p = head; s = (Lstack *)malloc(sizeof(Lstack)); Initlist_Stack(s); while (p) { push(s, p-\u0026gt;val); p = p-\u0026gt;next; } p = head; while (p) { e = pop(s); if (p-\u0026gt;val != e) break; p = p-\u0026gt;next; } if (p) return false; else return true; } 7-1.链队列 定义：\n1 2 3 4 5 6 7 8 9 10 11 typedef struct QNode //队列 { int data; struct QNode *next; } QNode; typedef struct LinkQueue //对列相关的指针 { QNode *front; //对头指针 QNode *rear; //队尾指针 } LinkQueue; 插入：\n1 2 3 4 5 6 7 8 9 10 11 int EnQueue(LinkQueue *q, int e) { //[入队]将元素e放入队尾，带头结点 QNode *p; p = (QNode *)malloc(sizeof(QNode)); p-\u0026gt;data = e; p-\u0026gt;next = NULL; q-\u0026gt;rear-\u0026gt;next = p; q-\u0026gt;rear = p; return 0; } 7-2.循环链表 插入和普通单链表没区别，这里就列举部分\n1 2 3 4 s = (LinkList *)malloc(sizeof(LinkList)); s-\u0026gt;data = e; s-\u0026gt;next = p-\u0026gt;next; p-\u0026gt;next = s; 8.求二叉树各种数的算法 （1）求高度 高度很简单，来个递归就完事了\n1 2 3 4 5 6 7 8 9 10 11 12 13 int BiTreeHeight(BiTNode *T) { //求二叉树的高度 int treeHeight = 0; if (T != NULL) { int leftHeight = BiTreeHeight(T-\u0026gt;lchild); int rightHeight = BiTreeHeight(T-\u0026gt;rchild); treeHeight = leftHeight \u0026gt;= rightHeight ? leftHeight + 1 : rightHeight + 1; } return treeHeight; } （2）求叶子数 叶子数也一样，递归永远滴神\n1 2 3 4 5 6 7 8 9 10 void BiTreeLeafCount(BiTNode *T, int *count) { //求二叉树叶子结点数 if (!T) return; if (T-\u0026gt;lchild == NULL \u0026amp;\u0026amp; T-\u0026gt;rchild == NULL) *count += 1; BiTreeLeafCount(T-\u0026gt;lchild, count); BiTreeLeafCount(T-\u0026gt;rchild, count); } （3）求结点数 这不就遍历嘛，直接看下面吧=￣ω￣=\n9.二叉树的中序遍历 递归：\n1 2 3 4 5 6 7 8 9 int InOrderTraverse(BiTNode *T) { //中序遍历二叉树T的递归算法 if (T == NULL) return 0; InOrderTraverse(T-\u0026gt;lchild); printf(\u0026#34;%c \u0026#34;, T-\u0026gt;data); InOrderTraverse(T-\u0026gt;rchild); } 非递归（重要）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int inorder(BiTNode *T) { //中序遍历二叉树T的非递归算法 BiTNode *s[MAXSIZE + 1]; int top = 0; while (T != NULL || top != 0) { while (T != NULL) { s[++top] = T; T = T-\u0026gt;lchild; } if (top != 0) { T = s[top--]; printf(\u0026#34;%c \u0026#34;, T-\u0026gt;data); T = T-\u0026gt;rchild; } } return 0; } 10.二叉排序树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 int Search_BST(BSTree t, int key, BSTree f, BSTree *p) { //在指针t所指的二叉排序树上查找key，成功则p指向该元素数据结点并返回0 //否则p指向查找路径上最后一个结点并返回1，f指向T的双亲，初始值为NULL if (!t) { *p = f; return 1; } else if (key == t-\u0026gt;data) { *p = t; return 0; } else if (key \u0026lt; t-\u0026gt;data) { return Search_BST(t-\u0026gt;lchild, key, t, p); } else return Search_BST(t-\u0026gt;rchild, key, t, p); } int Insert_BST(BSTree *t, int key) { //二叉排序树的插入，当不存在key时插入并返回0，否则返回1 BSTree p, s; p = NULL; if (Search_BST(*t, key, NULL, \u0026amp;p)) { s = (BSTree)malloc(sizeof(BSTNode)); s-\u0026gt;data = key; s-\u0026gt;lchild = s-\u0026gt;rchild = NULL; if (!p) *t = s; else if (key \u0026lt; p-\u0026gt;data) p-\u0026gt;lchild = s; else p-\u0026gt;rchild = s; return 0; } else return 1; } 14.图的遍历 （1）深度优先 入栈时打印结点信息\n递归：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void DFS(ALGraph *G, int v, int visited[]) { ArcNode *p; int w, i; visited[v] = 1; printf(\u0026#34;%d \u0026#34;, v); p = G-\u0026gt;vertices[v].firstarc; while (p != NULL) { w = p-\u0026gt;adjvex; if (visited[w] == 0) DFS(G, w, visited); p = p-\u0026gt;nextarc; } } 非递归：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 void DFS1(ALGraph *G, int v) { ArcNode *p; int w, i; int visited[MAX_VERTEX_NUM]; ArcNode *s[MAX_VERTEX_NUM]; //顺序栈 int top = 0; for (i = 1; i \u0026lt;= G-\u0026gt;vexnum; i++) visited[i] = 0; //访问标志数组初始化 visited[v] = 1; printf(\u0026#34;%2d\u0026#34;, v); p = G-\u0026gt;vertices[v].firstarc; while (p != NULL || top != 0) { while (p != NULL) { w = p-\u0026gt;adjvex; if (visited[w] == 0) { printf(\u0026#34;%2d\u0026#34;, w); visited[w] = 1; s[++top] = p; p = G-\u0026gt;vertices[w].firstarc; } else p = p-\u0026gt;nextarc; } if (top != 0) { p = s[top--]; p = p-\u0026gt;nextarc; } } } （2）广度优先 出队列时打印结点信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void BFS(ALGraph *G, int v) { ArcNode *p; int w, i; int queue[MAX_VERTEX_NUM], front = 0, rear = 0; // 定义循环队列 int visited[MAX_VERTEX_NUM]; for (i = 1; i \u0026lt;= G-\u0026gt;vexnum; i++) visited[i] = 0; //访问标志数组初始化 printf(\u0026#34;%2d\u0026#34;, v); //输出被访问顶点的编号 visited[v] = 1; //置已访问标记 rear = (rear + 1) % MAX_VERTEX_NUM; queue[rear] = v; //v进队 while (front != rear) // 队列不空时循环 { front = (front + 1) % MAX_VERTEX_NUM; w = queue[front]; //出队并赋给w p = G-\u0026gt;vertices[w].firstarc; //找w的第一个的邻接点 while (p != NULL) { if (visited[p-\u0026gt;adjvex] == 0) { printf(\u0026#34;%2d\u0026#34;, p-\u0026gt;adjvex); //访问之 visited[p-\u0026gt;adjvex] = 1; rear = (rear + 1) % MAX_VERTEX_NUM; //相邻顶点进队 queue[rear] = p-\u0026gt;adjvex; } p = p-\u0026gt;nextarc; //找下一个邻接顶点 } } } 15.双向冒泡 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void BubbleSort1(int R[], int n) { //双向冒泡 int i, j, lastExchange, lastExchange1, i1, temp; i = n; //i 指示无序序列中最后一个记录的位置 i1 = 1; while (i \u0026gt; i1) { lastExchange = 1; //记录正序最后一次交换发生的位置 lastExchange1 = n; //记录逆序最后一次交换发生的位置 for (j = i1; j \u0026lt; i; j++) if (R[j] \u0026gt; R[j + 1]) { temp = R[j]; R[j] = R[j + 1]; R[j + 1] = temp; //逆序时交换 lastExchange = j; } for (j = lastExchange; j \u0026gt; i1; j--) if (R[j] \u0026lt; R[j - 1]) { temp = R[j]; R[j] = R[j - 1]; R[j - 1] = temp; //逆序时交换 lastExchange1 = j; } i = lastExchange; i1 = lastExchange1; } } ","date":"2021-01-10T15:06:20+08:00","image":"https://lbqaq.top/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/83667969.webp","permalink":"https://lbqaq.top/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/","title":"数据结构算法复习"},{"content":"生成随机数 在C语言中，生成随机数可以使用stdlib.h头文件里的rand()来生成，例如：\n1 2 3 4 5 6 7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(){ int a = rand(); printf(\u0026#34;%d\\n\u0026#34;,a); return 0; } rand() 会随机生成一个位于 0 ~ RAND_MAX 之间的整数。\n但是这样生成的随机数每次开启程序都是一样的，则需要使用srand()来重新播种，一般常与\u0026lt;time.h\u0026gt;里的time()函数一起使用。\n1 srand((unsigned)time(NULL)); 连续生成多个随机数 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main() { int a, i; srand((unsigned)time(NULL)); //使用for循环生成10个随机数 for (i = 0; i \u0026lt; 10; i++) { a = rand(); printf(\u0026#34;%d \u0026#34;, a); } return 0; } 生成指定范围的随机数 想要生成指定范围的随机数，只要进行%运算就好了\n1 2 int a = rand() % 10; //产生0~9的随机数 int a = rand() % 10 + 1; //产生1~10的随机数 连续生成不重复的随机数 这就是本文的重点了ヾ(•ω•`)o （其实就是为了记下这个算法才水了一篇文章）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int *GetRandom(int m) { //根据给定的m生成随机不重复的数组a int i, n, w, t; int *a; n = 2 * m; srand((unsigned int)time(0)); a = (int *)malloc(n * sizeof(int)); for (i = 0; i \u0026lt; n; i++) a[i] = i + 1; for (i = 1; i \u0026lt;= m; i++) { w = rand() % (n - i) + i; t = a[i]; a[i] = a[w]; a[w] = t; } return a; } ","date":"2020-12-22T19:36:53+08:00","image":"https://lbqaq.top/p/c%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/84444030.webp","permalink":"https://lbqaq.top/p/c%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/","title":"C语言生成随机数"},{"content":"基本操作 建立版本库：git init\n查看结果：git status\n查看不同：git diff\n版本回退 查看提交日记：git log\n回退：git reset --hard HEAD^\nHEAD^表示上一个版本，HEAD^^表示前两个版本，HEAD~100表示前100个版本\n恢复：git reflog查看命令历史，确定回到未来的哪个版本\n撤销修改 直接丢弃工作区的修改时，用命令git checkout -- file 已经添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD \u0026lt;file\u0026gt;，第二步按1操作。 上传 1 2 3 4 git remote add origin 仓库链接 #将远程仓库和本地仓库绑定 git add . git commit -m \u0026#34;提交信息\u0026#34; git push -u origin 自己当前的分支名 #-u将本地库和远程库的分支关联，之后可以不加 下载 1 git clone 仓库链接 git clone到当前文件夹\n1 git clone 仓库链接 . 分支管理 创建与合并分支 查看分支：git branch\n创建分支：git branch \u0026lt;name\u0026gt;\n切换分支：git checkout \u0026lt;name\u0026gt;或者git switch \u0026lt;name\u0026gt;\n创建+切换分支：git checkout -b \u0026lt;name\u0026gt;或者git switch -c \u0026lt;name\u0026gt;\n删除分支：git branch -d \u0026lt;name\u0026gt;\n合并某分支到当前分支：git merge \u0026lt;name\u0026gt;\n当Git无法自动合并分支时，就必须首先解决冲突，自己手动修改冲突文件再合并即可。 查看分支合并图：git log --graph 使用非快速模式合并，有commit：git merge --no-ff -m \u0026quot;merge with no-ff\u0026quot; dev Bug分支 需要紧急处理Bug时，可以使用git stash将现在的工作区暂存\n恢复原来的工作区\n恢复但不删除stash内容：git stash apply 手动删除stash内容：git stash drop 恢复且删除stash内容：git stash pop 可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，如：\n1 git stash apply stash@{0} 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick \u0026lt;commit\u0026gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。\n多人协作 查看远程库信息，使用git remote -v\n从本地推送分支，使用git push origin branch-name\n如果冲突，先git pull抓取远程的新提交，处理好后再push\n在本地创建和远程分支对应的分支：git checkout -b branch-name origin/branch-name\n建立本地分支和远程分支的关联：git branch --set-upstream branch-name origin/branch-name\n将非直线的提交日记变为直线：git rebase\n标签管理 创建标签 新建一个标签：git tag \u0026lt;name\u0026gt;,默认为HEAD，也可以指定一个commit id\n指定标签信息：git tag -a \u0026lt;tagname\u0026gt; -m \u0026quot;blablabla...\u0026quot;\n查看所有标签：git tag\n标签管理 推送一个本地标签：git push origin \u0026lt;tagname\u0026gt; 推送全部未推送过的本地标签：git push origin --tags 删除一个本地标签：git tag -d \u0026lt;tagname\u0026gt; 删除一个远程标签：git push origin :refs/tags/\u0026lt;tagname\u0026gt; ","date":"2020-12-16T13:16:45+08:00","image":"https://lbqaq.top/p/git/79008828.webp","permalink":"https://lbqaq.top/p/git/","title":"Git的常用命令"},{"content":"主题相关 FrontMatter 字段含义\n1 2 3 4 5 6 7 8 9 10 11 12 title: 标题 description: 描述 image: 显示的特色图片 comments: 显示 / 隐藏评论区(T/F) license: 文章协议 输入 false 可以隐藏 hidden: 隐藏文章（不在首页，归档等页面显示，但是可以直接通过链接访问） math: 是否加载 KaTeX 脚本 slug: 固定链接 draft: 是否为草稿 categories: 分类 tags: 标签 lastmod: 上次更新时间 MarkDown相关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 我是一级标题 ## 我是二级标题 可对应1-6级标题 *斜体文本* **粗体文本** ***粗斜体文本*** 一行中用三个以上的星号*、减号-、底线_来建立一个分隔线 ~~删除线~~ \u0026lt;u\u0026gt;带下划线文本\u0026lt;/u\u0026gt; 创建脚注格式类似这样 [^JiaoZhu]。 [^JiaoZhu]: 脚注的内容 列表：*、+、-、1. \u0026gt; 区块 [链接文本](网址) 图片在前加! | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 ","date":"2020-12-15T18:02:14+08:00","image":"https://lbqaq.top/p/blog%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/80228475.webp","permalink":"https://lbqaq.top/p/blog%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/","title":"Blog常用的命令"}]