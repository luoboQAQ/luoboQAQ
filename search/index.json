[{"content":"每次写完博客，需要在本地编译，然后再手动通过WinSCP送到服务器上。作为一个懒人，这上面几步下来还是觉得麻烦，而且每次编译又会生成一顿不需要的文件，于是便决定整点自动化的流程，直接解放双手。\n因为我的博客在没买服务器之前都是托管在Github上的，于是自然而然地就想到了Webhook，在每次Push后自动发送消息给服务器，让其自动拉取代码。\n网上的教程大多都是在本地编译，然而我觉得既然要懒，就一懒到底吧，编译也直接通过Github Actions来完成就行了。\n流程 需要2个Github仓库（1个应该也可以），一个存放网站的源码，一个是存放编译好的html文件。整个工作流程就如下图所示：\n 流程图 \n步骤 设置脚本 首先要写一个shell脚本，功能很简单就是自动拉取代码。\n#!/bin/bash cd /home/luobo/Blog git pull 创建webhook服务后端 这里就直接使用NodeJS来创建，使用的原因很简单，因为已经有现成的插件可以使用了。\n首先安装依赖\nnpm i -S github-webhook-handler npm i -g pm2 然后创建webhook.js作为后端\nvar http = require(\u0026#39;http\u0026#39;); var spawn = require(\u0026#39;child_process\u0026#39;).spawn; var createHandler = require(\u0026#39;github-webhook-handler\u0026#39;); //注意要将 secret 修改你自己的 var handler = createHandler({ path: \u0026#39;/webhook\u0026#39;, secret: \u0026#39;xxxxx\u0026#39; }); http.createServer(function (req, res) { handler(req, res, function (err) { res.statusCode = 404; res.end(\u0026#39;no such location\u0026#39;); }) }).listen(6666); handler.on(\u0026#39;error\u0026#39;, function (err) { console.error(\u0026#39;Error:\u0026#39;, err.message) }); handler.on(\u0026#39;push\u0026#39;, function (event) { console.log(\u0026#39;Received a push event for %s to %s\u0026#39;, event.payload.repository.name, event.payload.ref); runCommand(\u0026#39;sh\u0026#39;, [\u0026#39;./deploy.sh\u0026#39;], function( txt ){ console.log(txt); }); }); function runCommand( cmd, args, callback ){ var child = spawn( cmd, args ); var resp = \u0026#39;Deploy OK\u0026#39;; child.stdout.on(\u0026#39;data\u0026#39;, function( buffer ){ resp += buffer.toString(); }); child.stdout.on(\u0026#39;end\u0026#39;, function(){ callback( resp ) }); } 最后启动服务即可\npm2 start webhook.js Nginx设置反代 location /webhook { proxy_pass http://127.0.0.1:6666; } 配置Github Webhook 在 html仓库的 Settings - webhooks 设置中创建一个新的 webhook。\n将Content Type 设置为 application/json，secret 设置成与 webhook.js 中的相同。\ntrigeer选择Just the push event. 。\n完成后Github会自动发起一个测试请求，如果返回为200说明配置完成，\n配置自动编译 在源代码仓库的.github/workflows目录下创建deploy.yml，并填入以下内容。\nname:Build and Deployon:[push]# 任务jobs:build-and-deploy:# 服务器环境：最新版 Ubunturuns-on:ubuntu-lateststeps:# 拉取代码- name:Checkoutuses:actions/checkout@v2# 安装Hugo- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:latestextended:true- name:Build run:hugo# 部署到 GitHub Pages- name:Deploy to GitHub Pagesuses:JamesIves/github-pages-deploy-action@4.1.4with:BRANCH:mainFOLDER:publictoken:${{ secrets.GP_TOKEN }}repository-name:luoboQAQ/luoboQAQ.github.io注意要将最后的repository-name换为你自己的仓库，同时需要申请和配置Github Token，这里我就不展开了。\n参考  使用 GitHub Webhook 实现静态网站自动化部署  ","date":"2021-08-23T15:44:59+08:00","image":"https://lbqaq.top/p/%E4%BD%BF%E7%94%A8webhooks%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/90550307_hu21d577faae26e3bf07e8b4590cabf640_189496_120x120_fill_q75_h2_box_smart1_2.webp","permalink":"https://lbqaq.top/p/%E4%BD%BF%E7%94%A8webhooks%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/","title":"使用Webhooks实现自动部署"},{"content":"一个完整的博客，怎么能少的了评论系统呢。评论的实现已经有许许多多的方法了，挑来挑去，还是选择了Waline。\n一开始我是采用官方推荐的LeanCloud+Vercel的方式进行部署的，结果步骤全部走完后才发现Vercel已经在国内被墙了，不科学根本上不去😇。总不能要求用户还要开梯子才能评论吧，所幸官方提供了其他的部署方式，因为我才买了自己的服务器~~（不榨干怎么行呢）~~，所以就选择本地部署+SQLlite的方式了。\n部署步骤 安装node.js 由于Waline的服务端是由js写的，所以需要安装node.js\n  在nodejs中文网找到需要的版本，选择阿里云镜像，将下载链接复制下来\n  连接服务器，选择nodejs的安装目录，这里我安装在/usr/local/bin/\ncd /usr/local/bin/   下载安装包到本地\nwget https://npm.taobao.org/mirrors/node/v14.17.5/node-v14.17.5-linux-x64.tar.gz   解压\ntar -xvf node-v14.17.5-linux-x64.tar.gz   重命名目录\nmv node-v14.17.5-linux-x64 nodejs   添加目录到系统变量\ncd /etc/profile.d vim custom.sh 在文件末尾添加export PATH=$PATH:/usr/local/bin/nodejs/bin\n  测试，输入下面3条命令，如果不报错则安装成功。\nnode -v npm version npx -v   （可选）安装cnpm\nnpm install -g cnpm --registry=https://registry.npm.taobao.org   安装Waline服务端   安装waline的服务端\nnpm install -g @waline/vercel   配置数据库。这里我采用的是SQLite，只需要下载 waline.sqlite 文件至合适的位置。\n其他的数据库可以看官方文档来配置。\n  配置环境变量。\n这里我选择新建waline.sh，方便日后维护。\ncd /etc/profile.d vim waline.sh export SQLITE_PATH=/home/luobo export JWT_TOKEN=eqdVMaEwd  SQLITE_PATH：表示SQLite文件的位置。 JWT_TOKEN：随机一串字符串就行。    启动模块\ncd /usr/local/bin/nodejs/lib node node_modules/@waline/vercel/vanilla.js   配置nginx反代 #waline server { listen 80; listen 443 ssl http2; server_name waline.lbqaq.top; if ($server_port !~ 443){ rewrite ^(/.*)$ https://$host$1 permanent; } ssl_certificate cert/waline.lbqaq.top.pem; ssl_certificate_key cert/waline.lbqaq.top.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { proxy_pass http://127.0.0.1:8360; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header REMOTE-HOST $remote_addr; add_header X-Cache $upstream_cache_status; # cache  add_header Cache-Control no-cache; expires 12h; } } 在hugo中启用Waline 由于我用的主题已经支持Waline评论，所以只需要填入serverURL就行了。\n添加QQ推送（可选） 官方提供了四种通知方法，分别为邮箱、微信、QQ、Telegram。\n邮箱基本不会去看，Telegram没科学也上不去，微信由于是走的Server酱，没有捐赠一天就支持5条消息。\n最终还是决定采用Qmsg 酱。\n注册就不在这展开了，具体写一下环境变量的配置。\ncd /etc/profile.d vim waline.sh export QMSG_KEY=cc1a964be75aa64e12a0313e0beb54bc export QQ_ID=756495338 export AUTHOR_EMAIL=luobo110@163.com export SITE_NAME=B export SITE_URL=lbqaq.top 踩坑 本以为启用评论是一件很简单的事，结果花了整个下午加晚上，踩了好多好多坑。在这里就把我踩的坑记录下来，避免之后出现一样的问题。\n  npm install -g @waline/vercel报错\n使用cnpm进行安装\n  想使用lbqaq.top/waline/这样的链接来设置服务端\n直接报404错误，还是选择上文中的子域名方法\n  nginx提示没找到http2模块\n在安装nginx时加上--with-http_v2_module如果已经安装好了，可以重新安装一遍\n  设置了server_name waline.lbqaq.top还是跳转首页\n增加一个默认的server，将所有不匹配的链接阻止\nserver { listen 80 default_server; server_name _; return 444; }   nginx配置不生效\n如果配置没有问题，除了nginx -s reload还可以尝试重启nginx\n  参考链接  Waline官方文档 nginx中文文档  ","date":"2021-08-21T15:37:44+08:00","image":"https://lbqaq.top/p/waline/78502982_huf2e268671a68175140c81a47a2157b88_156914_120x120_fill_q75_box_smart1.jpg","permalink":"https://lbqaq.top/p/waline/","title":"为博客添加评论系统"},{"content":"SpringMVC也告一段落了，终于要到SpringBoot了。\n还是和之前一样，笔记是基于遇见狂神说的SpringMVC视频教程而来，在此感谢能提供这么优秀的教程。\n回顾MVC 什么是MVC  MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 将业务逻辑、数据、显示分离的方法来组织代码。  **Model（模型）：**数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。\n拓展：在前端数据传输给后端时，有些字段是不需要的，这是可能会细分出Vo层（视图）\n比如：用户有账号、密码、年龄等一系列字段\n这时前端登录只传了账号密码\n此时可以用UserVo来表示，里面只有账号和密码\n**View（视图）：**负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。\n**Controller（控制器）：**接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。\n最典型的MVC就是JSP + servlet + javabean的模式。\n 用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面  职责分析：\nController：控制器\n 取得表单数据 调用业务逻辑 转向指定的页面  Model：模型\n 业务逻辑 保存数据的状态  View：视图\n 显示页面  复习Servlet   父工程添加依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.13\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet.jsp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsp-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jstl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   编写Servlet\npublic class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取前端操作  String method = req.getParameter(\u0026#34;method\u0026#34;); if (method.equals(\u0026#34;add\u0026#34;)){ req.getSession().setAttribute(\u0026#34;msg\u0026#34;,\u0026#34;执行了add方法\u0026#34;); } if (method.equals(\u0026#34;delete\u0026#34;)){ req.getSession().setAttribute(\u0026#34;msg\u0026#34;,\u0026#34;执行了delete方法\u0026#34;); } //调用业务层  //视图转发或重定向  req.getRequestDispatcher(\u0026#34;/WEB-INF/jsp/test.jsp\u0026#34;).forward(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } }   编写test.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建test.jsp\n\u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ${msg} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   在web.xml中注册Servlet\n\u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;hello\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;top.lbqaq.servlet.HelloServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;hello\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/hello\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt;   配置TomCat，进行测试\n  MVC框架要做哪些事情\n 将url映射到java类或java类的方法 . 封装用户提交的数据 . 处理请求\u0026ndash;调用相关的业务处理\u0026ndash;封装响应数据 . 将响应的数据进行渲染 . jsp / html 等表示层数据 .  说明：\n​\t常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等\u0026hellip;.\n什么是SpringMVC 概述 Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。\n中文文档\n我们为什么要学习SpringMVC呢?\nSpring MVC的特点：\n 轻量级，简单易学 高效 , 基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 功能强大：RESTful、数据验证、格式化、本地化、主题等 简洁灵活  中心控制器 ​\tSpring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。\n​\tSpring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。\n DispatcherServlet \nSpringMVC的原理如下图所示：\n​\t当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。\n SpringMVC流程 \nSpringMVC执行原理  执行流程 \n图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。\n简要分析执行流程\n  DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。\n我们假设请求的url为 : http://localhost:8080/SpringMVC/hello\n如上url拆分成三部分：\nhttp://localhost:8080服务器域名\nSpringMVC部署在服务器上的web站点\nhello表示控制器\n通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。\n  HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。\n  HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。\n  HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。\n  HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。\n  Handler让具体的Controller执行。\n  Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。\n  HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。\n  DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。\n  视图解析器将解析的逻辑视图名传给DispatcherServlet。\n  DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。\n  最终视图呈现给用户。\n  这里比较绕，所以直接把原文搬来了，之后等理解加深了再来补充自己的看法。\n第一个SpringMVC程序 由于我们是采用子模块的方式，那么需要去IDEA里设置一下让lib会打包出去。否则就会提示404错误。\n在点击IDEA右上角的小齿轮，选择项目结构，在工件下看WEB-INF里是否有lib目录，没有的话就创建一个，然后点击+号，选择库文件将所有的包导入进去。\n配置版   准备要看的视图。在WEB-INF目录下创建jsp目录，在里面创建test.jsp，填入${msg}\n  配置SpringMVC。在web.xml里添加下面的代码。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;!--配置DispatchServlet：这是SpringMVC的核心：请求分发器、前端控制器--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--DispatchServlet要绑定Spring的配置文件--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--启动级别1：随服务器一起启动--\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 备注：/和/*的区别：/匹配所有请求，不匹配jsp页面；/*会匹配jsp页面，这样会导致嵌套，一般不会用\n  编写SpringMVC的配置文件springmvc-servlet.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--处理器映射器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\u0026#34;/\u0026gt; \u0026lt;!--处理器适配器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\u0026#34;/\u0026gt; \u0026lt;!--视图解析器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;!--前缀--\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34;/\u0026gt; \u0026lt;!--后缀--\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   实现Controller接口\npackage top.lbqaq.Controller; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class HelloController implements Controller { @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { ModelAndView mv = new ModelAndView(); //业务代码  String result = \u0026#34;HelloSpringMVC\u0026#34;; mv.addObject(\u0026#34;msg\u0026#34;,result); //视图跳转  mv.setViewName(\u0026#34;test\u0026#34;); return mv; } }   将Controller在Spring中注册(springmvc-servlet.xml)\n\u0026lt;!--BeanNameUrlHandlerMapping:按BeanName匹配--\u0026gt; \u0026lt;bean id=\u0026#34;/hello\u0026#34; class=\u0026#34;top.lbqaq.Controller.HelloController\u0026#34;/\u0026gt;   运行TomCat查看结果\n  然而正常开发并不会使用这样的方式，这样做只是为了理解底层的操作。_(:з)∠)_\n注解版   配置Web.xml\n\u0026lt;!--配置DispatchServlet：这是SpringMVC的核心：请求分发器、前端控制器--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--DispatchServlet要绑定Spring的配置文件--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--启动级别1：随服务器一起启动；越小级别越高--\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; 还是老样子，这里没有什么需要改动的。\n  在resources目录下添加SpringMVC配置文件springmvc-servlet.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\u0026#34;\u0026gt; \u0026lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;top.lbqaq.controller\u0026#34;/\u0026gt; \u0026lt;!-- 让Spring MVC不处理静态资源 --\u0026gt; \u0026lt;mvc:default-servlet-handler /\u0026gt; \u0026lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --\u0026gt; \u0026lt;mvc:annotation-driven /\u0026gt; \u0026lt;!-- 视图解析器 --\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;!-- 前缀 --\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34; /\u0026gt; \u0026lt;!-- 后缀 --\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   创建Controller\n@Controller public class HelloController { @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(Model model){ //封装数据  model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;Hello,SpringMVCAnnotation!\u0026#34;); return \u0026#34;hello\u0026#34;; //会被视图解析器处理  } }  @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。    创建视图层，在WEB-INF/jsp目录中创建hello.jsp\n\u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ${msg} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   运行TomCat查看结果\n  小结 实现步骤其实非常的简单：\n 新建一个web项目 导入相关jar包 编写web.xml , 注册DispatcherServlet 编写springmvc配置文件 接下来就是去创建对应的控制类 , controller 最后完善前端视图和controller之间的对应 测试运行调试.  使用springMVC必须配置的三大件：\n处理器映射器、处理器适配器、视图解析器\n通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置\nRestFul风格 概念\nRestful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。\n功能\n资源：互联网所有的事物都可以被抽象为资源\n资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。\n分别对应 添加、 删除、修改、查询。\n传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get\n​\thttp://127.0.0.1/item/queryItem.action?id=1 查询,GET\n​\thttp://127.0.0.1/item/saveItem.action 新增,POST\n​\thttp://127.0.0.1/item/updateItem.action 更新,POST\n​\thttp://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST\n使用RESTful操作资源 ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！\n​\thttp://127.0.0.1/item/1 查询,GET\n​\thttp://127.0.0.1/item 新增,POST\n​\thttp://127.0.0.1/item 更新,PUT\n​\thttp://127.0.0.1/item/1 删除,DELETE\n使用方法\n创建一个类RestFulController\n@Controller public class RestFulController { //原来的：localhost:8085/add?a=1\u0026amp;b=2  //Restful:localhost:8085/add/1/2  @RequestMapping(\u0026#34;/add/{a}/{b}\u0026#34;) public String test1(@PathVariable int a,@PathVariable int b, Model model){ int res = a+b; model.addAttribute(\u0026#34;msg\u0026#34;,\u0026#34;结果为\u0026#34;+res); return \u0026#34;test\u0026#34;; } } @RequestMapping里面的{a}就代表这里是传给a变量的值；下面的a变量前要加@PathVariable\n使用路径变量的好处？\n 使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。  我们也可以进行方法约束，让其只响应某一种请求\n@GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping 拿@GetMapping来说，就是@RequestMapping(method =RequestMethod.GET)意思，如果使用其他的方法，将会报405错误。\n重定向和转发 重定向不需要视图解析器，本质就是重新请求一个新地方。\n可以重定向到另外一个请求实现。\n@Controller public class ResultSpringMVC2 { @RequestMapping(\u0026#34;/rsm2/t1\u0026#34;) public String test1(){ //转发  return \u0026#34;test\u0026#34;; } @RequestMapping(\u0026#34;/rsm2/t2\u0026#34;) public String test2(){ //重定向  return \u0026#34;redirect:/index.jsp\u0026#34;; //return \u0026#34;redirect:hello.do\u0026#34;; //hello.do为另一个请求/  } } 数据处理 处理提交数据 1、提交的域名称和处理方法的参数名一致\n提交数据 : http://localhost:8080/hello?name=lbqaq\n处理方法 :\n@RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(String name){ System.out.println(name); return \u0026#34;hello\u0026#34;; } 后台输出 : lbqaq\n2、提交的域名称和处理方法的参数名不一致\n提交数据 : http://localhost:8080/hello?username=lbqaq\n处理方法 :\n//@RequestParam(\u0026#34;username\u0026#34;) : username提交的域的名称 . @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(@RequestParam(\u0026#34;username\u0026#34;) String name){ System.out.println(name); return \u0026#34;hello\u0026#34;; } 后台输出 : lbqaq\n3、提交的是一个对象\n要求提交的表单域和对象的属性名一致 , 参数使用对象即可\n1、实体类\npublic class User { private int id; private String name; private int age; //构造  //get/set  //tostring() } 2、提交数据 : http://localhost:8080/mvc04/user?name=lbqaq\u0026amp;id=1\u0026amp;age=15\n3、处理方法 :\n@RequestMapping(\u0026#34;/user\u0026#34;) public String user(User user){ System.out.println(user); return \u0026#34;hello\u0026#34;; } 后台输出 : User { id=1, name=\u0026lsquo;lbqaq\u0026rsquo;, age=15 }\n说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。\n数据显示到前端 第一种 : 通过ModelAndView\n我们前面一直都是如此 . 就不过多解释\npublic class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象  ModelAndView mv = new ModelAndView(); mv.addObject(\u0026#34;msg\u0026#34;,\u0026#34;ControllerTest1\u0026#34;); mv.setViewName(\u0026#34;test\u0026#34;); return mv; } } 第二种 : 通过ModelMap\nModelMap\n@RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(@RequestParam(\u0026#34;username\u0026#34;) String name, ModelMap model){ //封装要显示到视图中的数据  //相当于req.setAttribute(\u0026#34;name\u0026#34;,name);  model.addAttribute(\u0026#34;name\u0026#34;,name); System.out.println(name); return \u0026#34;hello\u0026#34;; } 第三种 : 通过Model\nModel\n@RequestMapping(\u0026#34;/ct2/hello\u0026#34;) public String hello(@RequestParam(\u0026#34;username\u0026#34;) String name, Model model){ //封装要显示到视图中的数据  //相当于req.setAttribute(\u0026#34;name\u0026#34;,name);  model.addAttribute(\u0026#34;msg\u0026#34;,name); System.out.println(name); return \u0026#34;test\u0026#34;; } 对比 就对于新手而言简单来说使用区别就是：\n Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解； ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性； ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。  当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。\n这里都是概念性的内容，所以就直接复制笔记了😌\n解决乱码 直接把Spring的乱码处理器放入web.xml里\n\u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; JSON  JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。  使用Jackson   导入依赖\n\u0026lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.12.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   编写Controller\n@Controller public class UserController { @RequestMapping(\u0026#34;/json1\u0026#34;) @ResponseBody public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据  ObjectMapper mapper = new ObjectMapper(); //创建一个对象  User user = new User(\u0026#34;小明\u0026#34;, 3, \u0026#34;男\u0026#34;); //将我们的对象解析成为json格式  String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便  return str; } 如果出现乱码，可以指定编码格式为UTF8来解决\n@RequestMapping(value = \u0026quot;/json1\u0026quot;,produces = \u0026quot;application/json;charset=utf-8\u0026quot;)\n  这样处理乱码还是太麻烦了，可以让Spring统一管理，在SpringMVC的配置文件里加上下面的代码。\n\u0026lt;mvc:annotation-driven\u0026gt; \u0026lt;mvc:message-converters register-defaults=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.StringHttpMessageConverter\u0026#34;\u0026gt; \u0026lt;constructor-arg value=\u0026#34;UTF-8\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;objectMapper\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;failOnEmptyBeans\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt; 在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！\n@RestController public class UserController { //produces:指定响应体返回类型和编码  @RequestMapping(value = \u0026#34;/json1\u0026#34;) public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据  ObjectMapper mapper = new ObjectMapper(); //创建一个对象  User user = new User(\u0026#34;小明\u0026#34;, 3, \u0026#34;男\u0026#34;); //将我们的对象解析成为json格式  String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便  return str; } } 自定义工具类，可以是JSON转换变得更简单\npublic class JsonUtils { public static String getJson(Object object) { return getJson(object,\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); } public static String getJson(Object object,String dateFormat) { ObjectMapper mapper = new ObjectMapper(); //不使用时间差的方式  mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象  SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //指定日期格式  mapper.setDateFormat(sdf); try { return mapper.writeValueAsString(object); } catch (JsonProcessingException e) { e.printStackTrace(); } return null; } } 使用FastJson \u0026lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.78\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 为了使@RestController有效，需要在Spring配置里加上下面的内容\n\u0026lt;mvc:annotation-driven\u0026gt; \u0026lt;mvc:message-converters register-defaults=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;!-- 配置Fastjson支持 --\u0026gt; \u0026lt;bean class=\u0026#34;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;supportedMediaTypes\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;application/json\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;text/html;charset=UTF-8\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt; fastjson 三个主要的类：\nJSONObject 代表 json 对象\n JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。 JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取\u0026quot;键：值\u0026quot;对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。  JSONArray 代表 json 对象数组\n 内部是有List接口中的方法来完成操作的。  JSON代表 JSONObject和JSONArray的转化\n JSON类源码分析与使用 仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。  测试代码\npublic class FastJsonDemo { public static void main(String[] args) { //创建一个对象  User user1 = new User(\u0026#34;1号\u0026#34;, 3, \u0026#34;男\u0026#34;); User user2 = new User(\u0026#34;2号\u0026#34;, 3, \u0026#34;男\u0026#34;); User user3 = new User(\u0026#34;3号\u0026#34;, 3, \u0026#34;男\u0026#34;); User user4 = new User(\u0026#34;4号\u0026#34;, 3, \u0026#34;男\u0026#34;); List\u0026lt;User\u0026gt; list = new ArrayList\u0026lt;User\u0026gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); System.out.println(\u0026#34;*******Java对象 转 JSON字符串*******\u0026#34;); String str1 = JSON.toJSONString(list); System.out.println(\u0026#34;JSON.toJSONString(list)==\u0026gt;\u0026#34;+str1); String str2 = JSON.toJSONString(user1); System.out.println(\u0026#34;JSON.toJSONString(user1)==\u0026gt;\u0026#34;+str2); System.out.println(\u0026#34;\\n****** JSON字符串 转 Java对象*******\u0026#34;); User jp_user1=JSON.parseObject(str2,User.class); System.out.println(\u0026#34;JSON.parseObject(str2,User.class)==\u0026gt;\u0026#34;+jp_user1); System.out.println(\u0026#34;\\n****** Java对象 转 JSON对象 ******\u0026#34;); JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2); System.out.println(\u0026#34;(JSONObject) JSON.toJSON(user2)==\u0026gt;\u0026#34;+jsonObject1.getString(\u0026#34;name\u0026#34;)); System.out.println(\u0026#34;\\n****** JSON对象 转 Java对象 ******\u0026#34;); User to_java_user = JSON.toJavaObject(jsonObject1, User.class); System.out.println(\u0026#34;JSON.toJavaObject(jsonObject1, User.class)==\u0026gt;\u0026#34;+to_java_user); } } Jackson刚刚测试没成功，还是选择FastJson吧😇。\n拦截器 概述 SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。\n**过滤器与拦截器的区别：**拦截器是AOP思想的具体应用。\n过滤器\n servlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截  拦截器\n 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的  使用方法   自定义拦截器需要实现接口HandlerInterceptor\npublic class MyInterceptor implements HandlerInterceptor { //在请求处理的方法之前执行  //如果返回true执行下一个拦截器  //如果返回false就不执行下一个拦截器  public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception { System.out.println(\u0026#34;------------处理前------------\u0026#34;); return true; } //在请求处理方法执行之后执行  public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;------------处理后------------\u0026#34;); } //在dispatcherServlet处理后执行,做清理工作.  public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception { System.out.println(\u0026#34;------------清理------------\u0026#34;); } }   在springmvc的配置文件中配置拦截器\n\u0026lt;!--关于拦截器的配置--\u0026gt; \u0026lt;mvc:interceptors\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;!--/** 包括路径及其子路径--\u0026gt; \u0026lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--\u0026gt; \u0026lt;!--/admin/** 拦截的是/admin/下的所有--\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/**\u0026#34;/\u0026gt; \u0026lt;!--bean配置的就是拦截器--\u0026gt; \u0026lt;bean class=\u0026#34;top.lbqaq.interceptor.MyInterceptor\u0026#34;/\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;/mvc:interceptors\u0026gt;   执行顺序如下：\n------------处理前------------ Controller方法 ------------处理后------------ ------------清理------------ 拦截器可以用来做登录验证等等内容，这里就不展开了（才不是懒得写）\n文件传输 文件上传是项目开发中最常见的功能之一 ,springMVC 可以很好的支持文件上传，但是SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。\n前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器；\n对表单中的 enctype 属性做个详细的说明：\n application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。 multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。 text/plain：除了把空格转换为 \u0026ldquo;+\u0026rdquo; 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。  \u0026lt;form action=\u0026#34;\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 文件上传   导入依赖包\n\u0026lt;!--文件上传--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-fileupload\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-fileupload\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--servlet-api导入高版本的--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   配置multipartResolver\n这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！\n\u0026lt;!--文件上传配置--\u0026gt; \u0026lt;bean id=\u0026#34;multipartResolver\u0026#34; class=\u0026#34;org.springframework.web.multipart.commons.CommonsMultipartResolver\u0026#34;\u0026gt; \u0026lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --\u0026gt; \u0026lt;property name=\u0026#34;defaultEncoding\u0026#34; value=\u0026#34;utf-8\u0026#34;/\u0026gt; \u0026lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --\u0026gt; \u0026lt;property name=\u0026#34;maxUploadSize\u0026#34; value=\u0026#34;10485760\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;maxInMemorySize\u0026#34; value=\u0026#34;40960\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   编写前端页面\n\u0026lt;form action=\u0026#34;/upload\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;upload\u0026#34;\u0026gt; \u0026lt;/form\u0026gt;   配置Controller\npackage com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.multipart.commons.CommonsMultipartFile; import javax.servlet.http.HttpServletRequest; import java.io.*; @Controller public class FileController { //@RequestParam(\u0026#34;file\u0026#34;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象  //批量上传CommonsMultipartFile则为数组即可  @RequestMapping(\u0026#34;/upload\u0026#34;) public String fileUpload(@RequestParam(\u0026#34;file\u0026#34;) CommonsMultipartFile file , HttpServletRequest request) throws IOException { //获取文件名 : file.getOriginalFilename();  String uploadFileName = file.getOriginalFilename(); //如果文件名为空，直接回到首页！  if (\u0026#34;\u0026#34;.equals(uploadFileName)){ return \u0026#34;redirect:/index.jsp\u0026#34;; } System.out.println(\u0026#34;上传文件名 : \u0026#34;+uploadFileName); //上传路径保存设置  String path = request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;); //如果路径不存在，创建一个  File realPath = new File(path); if (!realPath.exists()){ realPath.mkdir(); } System.out.println(\u0026#34;上传文件保存地址：\u0026#34;+realPath); InputStream is = file.getInputStream(); //文件输入流  OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流  //读取写出  int len=0; byte[] buffer = new byte[1024]; while ((len=is.read(buffer))!=-1){ os.write(buffer,0,len); os.flush(); } os.close(); is.close(); return \u0026#34;redirect:/index.jsp\u0026#34;; } }   方法二：使用file.Transto 来保存上传的文件\n/* * 采用file.Transto 来保存上传的文件 */ @RequestMapping(\u0026#34;/upload2\u0026#34;) public String fileUpload2(@RequestParam(\u0026#34;file\u0026#34;) CommonsMultipartFile file, HttpServletRequest request) throws IOException { //上传路径保存设置  String path = request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;); File realPath = new File(path); if (!realPath.exists()){ realPath.mkdir(); } //上传文件地址  System.out.println(\u0026#34;上传文件保存地址：\u0026#34;+realPath); //通过CommonsMultipartFile的方法直接写文件（注意这个时候）  file.transferTo(new File(realPath +\u0026#34;/\u0026#34;+ file.getOriginalFilename())); return \u0026#34;redirect:/index.jsp\u0026#34;; } 文件下载 @RequestMapping(value=\u0026#34;/download\u0026#34;) public String downloads(HttpServletResponse response ,HttpServletRequest request) throws Exception{ //要下载的图片地址  String path = request.getServletContext().getRealPath(\u0026#34;/upload\u0026#34;); String fileName = \u0026#34;基础语法.jpg\u0026#34;; //1、设置response 响应头  response.reset(); //设置页面不缓存,清空buffer  response.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); //字符编码  response.setContentType(\u0026#34;multipart/form-data\u0026#34;); //二进制传输数据  //设置响应头  response.setHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment;fileName=\u0026#34;+URLEncoder.encode(fileName, \u0026#34;UTF-8\u0026#34;)); File file = new File(path,fileName); //2、 读取文件--输入流  InputStream input=new FileInputStream(file); //3、 写出文件--输出流  OutputStream out = response.getOutputStream(); byte[] buff =new byte[1024]; int index=0; //4、执行 写出操作  while((index= input.read(buff))!= -1){ out.write(buff, 0, index); out.flush(); } out.close(); input.close(); return null; } 或者直接用a标签\n\u0026lt;a href=\u0026quot;/1.jpg\u0026quot;\u0026gt;点击下载\u0026lt;/a\u0026gt;\n","date":"2021-08-15T09:06:00+08:00","image":"https://lbqaq.top/p/springmvc/65411813_hu5438825b9b6d1014226d20d231e650c2_327102_120x120_fill_q75_box_smart1.jpg","permalink":"https://lbqaq.top/p/springmvc/","title":"SpringMVC学习笔记"},{"content":"花了3天时间，Spring也终于看完了,SSM已经干完了两个了，感觉人都要没了😇。还是老样子，留下笔记以免遗忘。\n下面的内容都是基于遇见狂神说的Spring5视频教程而来，在此感谢能提供这么优秀的教程。\nSpring 简介 Spring就是用来简化Java开发的，只能说学Java不学Spring，就像读四大名著不读红楼梦\u0026hellip;\u0026hellip;\n2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。\n2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。\n很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。\nSpring理念 : 使现有技术更加实用。 本身就是一个大杂烩 , 整合现有的框架技术。\nSSM：SpringMVC+Spring+MyBatis\n几个常用的网址：\n  官网\n  官方文档（英文）\n  中文文档\n  GitHub\n  \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 优点   Spring是一个开源免费的框架 , 容器\n  Spring是一个轻量级的框架 , 非侵入式的\n  控制反转（IoC）,面向切面（Aop）\n  对事务的支持 , 对框架的支持\n  一句话概括：\n Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。\n 拓展  Spring Boot  一套快速配置脚手架 可以基于Spring Boot 快速开发单个微服务   Spring Cloud  Spring Cloud是基于Spring Boot实现的    学习路线：Spring -\u0026gt; SpringMVC -\u0026gt; Spring Boot -\u0026gt; Spring Cloud\nIOC理论推导 原先的开发模式：\n  先写一个UserDao接口\npublic interface UserDao { public void getUser(); }   再去写Dao的实现类\npublic class UserDaoImpl implements UserDao { @Override public void getUser() { System.out.println(\u0026#34;获取用户数据\u0026#34;); } }   然后去写UserService的接口\npublic interface UserService { public void getUser(); }   最后写Service的实现类\npublic class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoImpl(); @Override public void getUser() { userDao.getUser(); } }   测试一下\n@Test public void test(){ //用户实际调用的是业务层，dao层他们并不需要接触！  UserService service = new UserServiceImpl(); service.getUser(); }   如果需要更换Dao层的实现方法，每次都需要在UserServiceImpl里手动修改new的对象，这样做十分麻烦。\n现在可以使用set接口实现\npublic class UserServiceImpl implements UserService { private UserDao userDao; // 利用set进行动态实现值的注入  public void setUserDao(UserDao userDao) { this.userDao = userDao; } @Override public void getUser() { userDao.getUser(); } }  以前所有东西都是由程序去进行控制创建。 而现在是由我们自行控制创建对象，把主动权交给了调用者。程序不用去管怎么创建,怎么实现了，它只负责提供一个接口。  这种思想，从本质上解决了问题，我们程序员不再去管理对象的创建了，更多的去关注业务的实现。耦合性大大降低， 这也就是IOC的原型！\nIOC本质 控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。\n IoC图示 \nSpring的工作原理：\n container magic \n 控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。\n 第一个Spring程序   添加Maven依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   在pojo包下创建实体类Hello\npackage top.lbqaq.pojo; /** * @author luoboQAQ * @Date 2021/8/12 上午 10:49 */ public class Hello { private String str; public String getStr() { return str; } public void setStr(String str) { this.str = str; } @Override public String toString() { return \u0026#34;Hello{\u0026#34; + \u0026#34;str=\u0026#39;\u0026#34; + str + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } }   在resources目录下编写Spring的配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--bean就是java对象 , 由Spring创建和管理 原来是 类型 变量名 = new 类型(); Hello hello = new Hello(); 现在 id=变量名 class=new的对象 property是给变量赋的初值 --\u0026gt; \u0026lt;bean id=\u0026#34;hello\u0026#34; class=\u0026#34;top.lbqaq.pojo.Hello\u0026#34;\u0026gt; \u0026lt;!--引用另外一个bean , 不是用value 而是用 ref--\u0026gt; \u0026lt;property name=\u0026#34;str\u0026#34; value=\u0026#34;Spring\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   进行测试\nimport org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import top.lbqaq.pojo.Hello; /** * @author luoboQAQ * @Date 2021/8/12 上午 10:53 */ public class MyTest { public static void main(String[] args) { //获取Spring的上下文对象  ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;beans.xml\u0026#34;); //我们的对象都在Spring中管理了，我们要使用直接从中取即可  Hello hello = (Hello) context.getBean(\u0026#34;hello\u0026#34;); System.out.println(hello); } }   现在Hello对象由Spring来创建和管理，这个过程就叫控制反转\n  控制：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring后，对象是由Spring来创建的。\n  反转：程序本身不创建对象，而变成被动的接收对象。\n  依赖注入：就是利用set方法来进行注入的。\nIOC是一种编程思想，由主动的编程变成被动的接收。\nIOC创建对象方式   通过无参构造函数（默认）\n  通过有参构造函数，有三种方式\n  下标赋值\n\u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   用类型赋值（不推荐）\n\u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg type=\u0026#34;java.lang.String\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   通过参数名创建\n\u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;     在配置文件加载的时候，其中管理的对象都已经初始化了！\nSpring配置 别名（alias） \u0026lt;!--设置别名：在获取Bean的时候可以使用别名获取--\u0026gt; \u0026lt;alias name=\u0026#34;user\u0026#34; alias=\u0026#34;userNew\u0026#34;/\u0026gt; Bean的配置 \u0026lt;!--bean就是java对象,由Spring创建和管理--\u0026gt; \u0026lt;!-- id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符 如果配置id,又配置了name,那么name是别名 name可以设置多个别名,可以用逗号,分号,空格隔开 如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象; class是bean的全限定名=包名+类名 --\u0026gt; \u0026lt;bean id=\u0026#34;hello\u0026#34; name=\u0026#34;hello2 h2,h3;h4\u0026#34; class=\u0026#34;top.lbqaq.pojo.Hello\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Spring\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; import 一般用于团队开发，将多个配置文件合为一个配置文件applicationContext.xml\n\u0026lt;import resource=\u0026#34;{path}/beans.xml\u0026#34;/\u0026gt; 依赖注入 概念  依赖注入（Dependency Injection,DI）。 依赖 : 指Bean对象的创建依赖于容器，Bean对象的依赖资源。 注入 : 指Bean对象所依赖的资源，由容器来设置和装配。  构造器注入 见前面的IOC创建对象方式\nset注入【重点】 测试环境 public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } public class Student { private String name; private Address address; private String[] books; private List\u0026lt;String\u0026gt; hobbys; private Map\u0026lt;String,String\u0026gt; card; private Set\u0026lt;String\u0026gt; games; private String wife; private Properties info; } xml编写 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;address\u0026#34; class=\u0026#34;top.lbqaq.pojo.Address\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; value=\u0026#34;西安\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;student\u0026#34; class=\u0026#34;top.lbqaq.pojo.Student\u0026#34;\u0026gt; \u0026lt;!--普通值注入，value--\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;!--Bean注入，ref--\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34; ref=\u0026#34;address\u0026#34;/\u0026gt; \u0026lt;!--数组注入--\u0026gt; \u0026lt;property name=\u0026#34;books\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;红楼梦\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;西游记\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;水浒传\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;三国演义\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--list--\u0026gt; \u0026lt;property name=\u0026#34;hobbys\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;听歌\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;看电影\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;打游戏\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--map--\u0026gt; \u0026lt;property name=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;身份证\u0026#34; value=\u0026#34;112233445566778899\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;银行卡\u0026#34; value=\u0026#34;123987879172197\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Set--\u0026gt; \u0026lt;property name=\u0026#34;games\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;LOL\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;CSGO\u0026lt;/value\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--null--\u0026gt; \u0026lt;property name=\u0026#34;wife\u0026#34;\u0026gt; \u0026lt;null/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Properties--\u0026gt; \u0026lt;property name=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;driver\u0026#34;\u0026gt;20211213\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;url\u0026#34;\u0026gt;女\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;username\u0026#34;\u0026gt;root\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;password\u0026#34;\u0026gt;123456\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 具体用法见上面的代码就行了。\n扩展方式注入 p命名空间   导入命名空间\nxmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34;   在bean标签里直接使用\n\u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34; p:age=\u0026#34;18\u0026#34; p:name=\u0026#34;小明\u0026#34;/\u0026gt;   相当于set注入\nc命名空间   导入命名空间\nxmlns:c=\u0026#34;http://www.springframework.org/schema/c\u0026#34;   在bean标签里直接使用\n\u0026lt;bean id=\u0026#34;user2\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34; c:age=\u0026#34;20\u0026#34; c:name=\u0026#34;小红\u0026#34;/\u0026gt;   相当于有参构造函数注入\nBean的作用域    类别 说明     singleton (默认)将每个 Spring IoC 容器的单个 bean 定义范围限定为单个对象实例。   prototype 将单个 bean 定义的作用域限定为任意数量的对象实例。   request 将单个 bean 定义的范围限定为单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有一个在单个 bean 定义后面创建的 bean 实例。仅在可感知网络的 Spring ApplicationContext中有效。   session 将单个 bean 定义的范围限定为 HTTP Session的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。   application 将单个 bean 定义的范围限定为ServletContext的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。   websocket 将单个 bean 定义的范围限定为WebSocket的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。      单例模式（默认）：每次获取的都是同一个对象\n\u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34; p:age=\u0026#34;18\u0026#34; p:name=\u0026#34;小明\u0026#34; scope=\u0026#34;singleton\u0026#34;/\u0026gt;   原型模式：每次get都是从容器中产生一个新对象\n\u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;top.lbqaq.pojo.User\u0026#34; p:age=\u0026#34;18\u0026#34; p:name=\u0026#34;小明\u0026#34; scope=\u0026#34;prototype\u0026#34;/\u0026gt;   其余request、session、application、websocket这些只在web开发中使用。\n  Bean的自动装配  自动装配是使用spring满足bean依赖的一种方法 spring会在应用上下文中为某个bean寻找其依赖的bean。  Spring中bean有三种装配机制，分别是：\n 在xml中显式配置 在java中显式配置 隐式的bean发现机制和自动装配【重要】  环境搭建 public class Cat { public void shout(){ System.out.println(\u0026#34;miao~\u0026#34;); } } public class Dog { public void shout(){ System.out.println(\u0026#34;wang~\u0026#34;); } } public class People { private Cat cat; private Dog dog; private String name; public Cat getCat() { return cat; } public void setCat(Cat cat) { this.cat = cat; } public Dog getDog() { return dog; } public void setDog(Dog dog) { this.dog = dog; } public String getName() { return name; } public void setName(String name) { this.name = name; } } ByName自动装配 \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;top.lbqaq.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;top.lbqaq.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;people\u0026#34; class=\u0026#34;top.lbqaq.pojo.People\u0026#34; autowire=\u0026#34;byName\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 会自动在容器上下文中查找，和自己对象set方法后面的值相对应的beanid\nByType自动装配 \u0026lt;bean id=\u0026#34;cat\u0026#34; class=\u0026#34;top.lbqaq.pojo.Cat\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;dog\u0026#34; class=\u0026#34;top.lbqaq.pojo.Dog\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;people\u0026#34; class=\u0026#34;top.lbqaq.pojo.People\u0026#34; autowire=\u0026#34;byType\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 自动在容器上下文中查找，和自己对象属性类型相同的Bean\n小结：\n byname要保证所有的bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致 bytype的时候，需要保证bean的class唯一，并且这个bean需要和自动注入的属性的类型一致  使用注解自动装配 准备工作   导入aop包\n  导入约束\nxmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd   配置注解支持\u0026lt;context:annotation-config/\u0026gt;\n  @Autowired   在属性或在set方法上使用。\n  使用Autowired可以不需要set方法。\n  @Autowired是按类型自动转配的。\n  @Autowired(required=false) 说明对象可以为null\n  @Qualifier   如果环境比较复杂，自动装配无法通过一个@Autowired完成，可以通过@Qualifier(value=\u0026quot;xxx\u0026quot;)来实现。\n  @Qualifier相当于byName\n  @Autowired @Qualifier(value = \u0026#34;cat2\u0026#34;) private Cat cat; @Autowired @Qualifier(value = \u0026#34;dog2\u0026#34;) private Dog dog; @Resource  @Resource如有指定的name属性，先按该属性进行byName方式查找装配； 其次再进行默认的byName方式进行装配； 如果以上都不成功，则按byType的方式自动装配。 都不成功，则报异常。  public class User { //如果允许对象为null，设置required = false,默认为true  @Resource(name = \u0026#34;cat2\u0026#34;) private Cat cat; @Resource private Dog dog; private String str; } 小结 @Autowired与@Resource异同：\n  @Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。\n  @Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用\n  @Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。\n  它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。\n使用注解开发 使用注解开发需要导入aop的包，导入约束和配置注解支持\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--指定要扫描的包，这个包下的注解就会生效--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;top.lbqaq.pojo\u0026#34;/\u0026gt; \u0026lt;context:annotation-config/\u0026gt; \u0026lt;/beans\u0026gt; Bean的实现 @Component public class User { public String name = \u0026#34;小明\u0026#34;; } 使用@Component注解，相当于配置文件中的\u0026lt;bean id=\u0026quot;user\u0026quot; class=\u0026quot;当前注解的类\u0026quot;/\u0026gt;\n注意需要在配置文件中指定要扫描的包\u0026lt;context:component-scan base-package=\u0026quot;top.lbqaq.pojo\u0026quot;/\u0026gt;\n属性注入 使用@Value注解，相当于配置文件中的\u0026lt;property name=\u0026quot;name\u0026quot; value=\u0026quot;小明\u0026quot;/\u0026gt;\n可以在声明上加，也可以在set方法上加\n@Component public class User { @Value(\u0026#34;小明\u0026#34;) public String name; } @Component public class User { public String name; @Value(\u0026#34;小明\u0026#34;) public void setName(String name) { this.name = name; } } 衍生注解 对于@Component注解，有三个衍生注解，分别对应MVC的三层。\n Dao层：@Repository Service层：@Service Web层：@Controller  这四个注解的作用都是代表将某个类注册到Spring中，装配Bean\n自动装配注解  @Autowired：按类型自动转配 @Qualifier(value=\u0026quot;xxx\u0026quot;)：按name自动装配 @Resource：Java提供的，先name再type，比较复杂  详细的解释可以看上面\n作用域 @Scope\n singleton：单例模式 prototype：多例模式  @Component @Scope(\u0026#34;prototype\u0026#34;) public class User { @Value(\u0026#34;小明\u0026#34;) public String name; } 小结 XML与注解比较\n XML可以适用任何场景 ，结构清晰，维护方便 注解不是自己提供的类使用不了，开发简单方便  推荐用法\n xml管理Bean 注解完成属性注入  使用Java类进行配置 实体类\npublic class User { private String name; @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } public String getName() { return name; } @Value(\u0026#34;小明\u0026#34;) public void setName(String name) { this.name = name; } } 配置类\n@Configuration public class LbqaqConfig { @Bean public User getUser(){ return new User(); } } 这里的@Configuration表明这是Spring的配置\n@Bean是用来注册bean，这里的返回值就Bean的类型，方法名就是bean的id\n测试\npublic class MyTest { @Test public void test1(){ ApplicationContext context = new AnnotationConfigApplicationContext(LbqaqConfig.class); User user = (User) context.getBean(\u0026#34;getUser\u0026#34;); System.out.println(user.getName()); } } 代理模式 AOP的底层机制就是动态代理。\n静态代理 角色分析\n 抽象角色：一般使用接口或者抽象类来实现 真实角色：被代理的角色 代理角色：代理真实角色。代理真实角色后 , 一般会做一些附属的操作。 客户：使用代理角色来进行一些操作。  举例：\nRent.java即抽象角色\n//抽象角色：租房 public interface Rent { public void rent(); } Host.java即真实角色\n//真实角色: 房东，房东要出租房子 public class Host implements Rent{ public void rent() { System.out.println(\u0026#34;房屋出租\u0026#34;); } } Proxy.java即代理角色\n//代理角色：中介 public class Proxy implements Rent { private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } //租房  public void rent(){ seeHouse(); host.rent(); fare(); } //看房  public void seeHouse(){ System.out.println(\u0026#34;带房客看房\u0026#34;); } //收中介费  public void fare(){ System.out.println(\u0026#34;收中介费\u0026#34;); } } Client.java即客户\n//客户类，一般客户都会去找代理！ public class Client { public static void main(String[] args) { //房东要租房  Host host = new Host(); //中介帮助房东  Proxy proxy = new Proxy(host); //你去找中介！  proxy.rent(); } } 分析：\n在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式。\n静态代理的好处:\n 可以使得我们的真实角色更加纯粹，不再去关注一些公共的事情。 公共的业务由代理来完成，实现了业务的分工。 公共业务发生扩展时变得更加集中和方便。  缺点：\n 类多了，多了代理类，工作量变大了，开发效率降低。  我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想。\n AOP \n动态代理   动态代理的角色和静态代理的一样。\n  动态代理的代理类是动态生成的，静态代理的代理类是我们提前写好的\n  动态代理分为两类：一类是基于接口动态代理，一类是基于类的动态代理\n   基于接口的动态代理\u0026mdash;-JDK动态代理 基于类的动态代理\u0026ndash;cglib 现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist 我们这里使用JDK的原生代码来实现，其余的道理都是一样的！    JDK的动态代理需要了解两个类\n核心 : InvocationHandler、Proxy\n代码实现：\n//租房 public interface Rent { void rent(); } //房东 public class Host implements Rent { @Override public void rent() { System.out.println(\u0026#34;房东要出租\u0026#34;); } } public class ProxyInvocationHandler implements InvocationHandler { //被代理的接口  private Rent rent; public void setRent(Rent rent) { this.rent = rent; } //生成得到的代理类  public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(),rent.getClass().getInterfaces(),this); } @Override //处理代理实例，并返回结果  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //动态代理就是依赖反射实现  Object result = method.invoke(rent, args); return result; } } public class Client { public static void main(String[] args) { //真实角色  Host host=new Host(); ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setRent(host); Rent proxy = (Rent) pih.getProxy(); proxy.rent(); } } 动态代理代理接口\n通用的代码\npublic class ProxyInvocationHandler implements InvocationHandler { private Object target; public void setTarget(Object target) { this.target = target; } //生成代理类  public Object getProxy() { return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); } // proxy : 代理类  // method : 代理类的调用处理程序的方法对象.  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { log(method.getName()); Object result = method.invoke(target, args); return result; } public void log(String methodName) { System.out.println(\u0026#34;执行了\u0026#34; + methodName + \u0026#34;方法\u0026#34;); } } AOP 什么是AOP AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n AOP \n 通俗点说，就是在不改变原有代码的情况下去增加新的功能。\n AOP在Spring中 提供声明式事务；允许用户自定义切面\n 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 \u0026hellip;. 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 目标（Target）：被通知对象。 代理（Proxy）：向目标对象应用通知之后创建的对象。 切入点（PointCut）：切面通知 执行的 “地点”的定义。 连接点（JointPoint）：与切入点匹配的执行点。   2 \nSpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice：\n Advice \n使用Spring实现AOP 导入依赖包\n\u0026lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.7\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 方式一：使用Spring的方法 业务接口和实现类\npublic interface UserService { void add(); void delete(); void update(); void select(); } public class UserServiceImpl implements UserService{ @Override public void add() { System.out.println(\u0026#34;增加一个用户\u0026#34;); } @Override public void delete() { System.out.println(\u0026#34;删除一个用户\u0026#34;); } @Override public void update() { System.out.println(\u0026#34;更新一个用户\u0026#34;); } @Override public void select() { System.out.println(\u0026#34;查询一个用户\u0026#34;); } } 写两个增强类\npublic class Log implements MethodBeforeAdvice { //method : 要执行的目标对象的方法  //objects : 被调用的方法的参数  //o : 目标对象  @Override public void before(Method method, Object[] objects, Object o) throws Throwable { System.out.println(o.getClass().getName()+\u0026#34;的\u0026#34;+method.getName()+\u0026#34;被执行了\u0026#34;); } } public class AfterLog implements AfterReturningAdvice { //o:返回值  @Override public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable { System.out.println(\u0026#34;执行了\u0026#34;+method.getName()+\u0026#34;方法，返回结果为\u0026#34;+o); } } 配置xml，这里需要引入aop命名空间\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;!--注册Bean--\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;top.lbqaq.service.UserServiceImpl\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;log\u0026#34; class=\u0026#34;top.lbqaq.log.Log\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;afterLog\u0026#34; class=\u0026#34;top.lbqaq.log.AfterLog\u0026#34;/\u0026gt; \u0026lt;!--配置aop：需要导入aop约束--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--切入点：expression：表达式 execution()--\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;pointcut\u0026#34; expression=\u0026#34;execution(* top.lbqaq.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt; \u0026lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;log\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;afterLog\u0026#34; pointcut-ref=\u0026#34;pointcut\u0026#34;/\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt; execution表达式解析：\n execution(修饰符 返回值 包名.类名/接口名.方法名(参数列表)) 修饰符可以忽略 (..)可以代表所有参数,(*)代表一个参数,(*,String)代表第一个参数为任何值,第二个参数为String类型  最后测试\npublic class MyTest { @Test public void test(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); UserService userService = (UserService) context.getBean(\u0026#34;userService\u0026#34;); userService.select(); } } 方法二：使用自定义类来实现 创建自定义类\npublic class DiyPointCut { public void before(){ System.out.println(\u0026#34;==========方法执行前==========\u0026#34;); } public void after(){ System.out.println(\u0026#34;==========方法执行后==========\u0026#34;); } } 配置xml\n\u0026lt;bean id=\u0026#34;diy\u0026#34; class=\u0026#34;top.lbqaq.diy.DiyPointCut\u0026#34;/\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--自定义切面，ref为要引用的类--\u0026gt; \u0026lt;aop:aspect ref=\u0026#34;diy\u0026#34;\u0026gt; \u0026lt;!--切入点--\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;point\u0026#34; expression=\u0026#34;execution(* top.lbqaq.service.UserServiceImpl.*(..))\u0026#34;/\u0026gt; \u0026lt;!--通知--\u0026gt; \u0026lt;aop:before method=\u0026#34;before\u0026#34; pointcut-ref=\u0026#34;point\u0026#34;/\u0026gt; \u0026lt;aop:after method=\u0026#34;after\u0026#34; pointcut-ref=\u0026#34;point\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; 方式三：使用注解来实现AOP   在类上标注注解@Aspect，如果没有该注解，就在maven配置里把\u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt;去掉\n  在方法前加上@Before()或@After()注解，并在括号中填入表达式\n//使用注解实现AOP @Aspect public class AnnotationPointCut { @Before(\u0026#34;execution(* top.lbqaq.service.UserServiceImpl.*(..))\u0026#34;) public void before(){ System.out.println(\u0026#34;=====方法执行前=====\u0026#34;); } @After(\u0026#34;execution(* top.lbqaq.service.UserServiceImpl.*(..))\u0026#34;) public void after(){ System.out.println(\u0026#34;=====方法执行后=====\u0026#34;); } //在环绕增强中，我们可以给定一个参数，代表我们要获取处理切入的点  @Around(\u0026#34;execution(* top.lbqaq.service.UserServiceImpl.*(..))\u0026#34;) public void around(ProceedingJoinPoint jp) throws Throwable { System.out.println(\u0026#34;环绕前\u0026#34;); //执行方法  Object proceed = jp.proceed(); System.out.println(\u0026#34;环绕后\u0026#34;); } }   在Spring配置文件注册Bean并开启注解支持\n\u0026lt;bean id=\u0026#34;annotationPointCut\u0026#34; class=\u0026#34;top.lbqaq.diy.AnnotationPointCut\u0026#34;/\u0026gt; \u0026lt;!--开启注解支持--\u0026gt; \u0026lt;aop:aspectj-autoproxy/\u0026gt;   整合MyBatis 首先要导入相关jar包\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- junit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.13\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mysql驱动 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.25\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis-spring --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- spring框架 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- spring-jdbc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- AOP 织入器 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 回顾MyBatis   编写实体类\npublic class User { private int id; private String name; private String pwd; //setter,getter  //toString,构造 }   编写Mybatis配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;!--核心配置文件--\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;top.lbqaq.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!--每一个mapper都需要注册--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026#34;top.lbqaq.mapper.UserMapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;   编写接口\npublic interface UserMapper { List\u0026lt;User\u0026gt; selectUser(); }   编写接口对应的xml文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;top.lbqaq.mapper.UserMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;selectUser\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;   解决Maven静态资源过滤问题\n\u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt;   测试\npublic class MyTest { @Test public void test() throws IOException { String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u0026lt;User\u0026gt; userList = mapper.selectUser(); for (User user: userList){ System.out.println(user); } sqlSession.close(); } }   MyBatis-Spring MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。官方文档\n整合实现一   引入Spring配置文件spring-dao.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt;   配置数据源\n\u0026lt;!--DataSource:使用Spring的数据源替换MyBatis的配置 这里使用Spring提供的JDBC --\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DriverManagerDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   配置SqlSessionFactory,关联MyBatis\n\u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34; /\u0026gt; \u0026lt;!--绑定Mybatis配置文件--\u0026gt; \u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;classpath:mybatis-config.xml\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;mapperLocations\u0026#34; value=\u0026#34;classpath:top/lbqaq/mapper/*.xml\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   注册sqlSessionTemplate，关联sqlSessionFactory\n\u0026lt;bean id=\u0026#34;sqlSession\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionTemplate\u0026#34;\u0026gt; \u0026lt;!--使用构造器注入，因为它没有set方法--\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; ref=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   增加Mapper接口的实现类\npublic class UserMapperImpl implements UserMapper{ //原来我们的所有操作，都使用sqlSession来执行；现在都使用SqlSessionTemplate  private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } @Override public List\u0026lt;User\u0026gt; selectUser() { UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); } }   将实现类注册到Spring中\n\u0026lt;bean id=\u0026#34;userMapper\u0026#34; class=\u0026#34;top.lbqaq.mapper.UserMapperImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sqlSession\u0026#34; ref=\u0026#34;sqlSession\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   测试\n@Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;spring-dao.xml\u0026#34;); UserMapper userMapper = context.getBean(\u0026#34;userMapper\u0026#34;, UserMapper.class); for (User user : userMapper.selectUser()) { System.out.println(user); } }   此时再去看MyBatis的配置文件，里面大部分配置都被Spring整合了\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;top.lbqaq.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;/configuration\u0026gt; 这里建议将typeAliases和settings留在MyBatis的配置文件中。\n以后可以将Spring配置文件拆开，spring-dao.xml用来处理数据库相关代码，applicationContext.xml作为总配置文件。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;import resource=\u0026#34;spring-dao.xml\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;userMapper\u0026#34; class=\u0026#34;top.lbqaq.mapper.UserMapperImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sqlSession\u0026#34; ref=\u0026#34;sqlSession\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 整合方式二 使用SqlSessionDaoSupport\n  修改实现类，继承SqlSessionDaoSupport\npublic class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper{ @Override public List\u0026lt;User\u0026gt; selectUser() { return getSqlSession().getMapper(UserMapper.class).selectUser(); } }   配置Bean\n\u0026lt;bean id=\u0026#34;userMapper2\u0026#34; class=\u0026#34;top.lbqaq.mapper.UserMapperImpl2\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;sqlSessionFactory\u0026#34; ref=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   测试\n@Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); UserMapper userMapper = context.getBean(\u0026#34;userMapper2\u0026#34;, UserMapper.class); for (User user : userMapper.selectUser()) { System.out.println(user); } }   使用这种方法，就不需要上面的第4步了，步骤就更加简洁了。\n声明式事务 spring中的事务：\n 编程式事务：在代码中进行事务的管理 声明式事务：AOP  一般我们都采用声明式事务，将事务管理作为横切关注点，通过aop方法模块化。\n使用方法：\n  引入头文件约束tx\nxmlns:tx=\u0026#34;http://www.springframework.org/schema/tx\u0026#34; http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\u0026#34;   配置事务管理器\n\u0026lt;!--配置声明式事务--\u0026gt; \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt;   配置事务通知\n\u0026lt;!--配置事务通知--\u0026gt; \u0026lt;tx:advice id=\u0026#34;txAdvice\u0026#34; transaction-manager=\u0026#34;transactionManager\u0026#34;\u0026gt; \u0026lt;!--给那些方法配置事务--\u0026gt; \u0026lt;tx:attributes\u0026gt; \u0026lt;!--配置事务的传播特性 propagation--\u0026gt; \u0026lt;tx:method name=\u0026#34;add\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;delete\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;update\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;query\u0026#34; read-only=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;tx:method name=\u0026#34;*\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;/tx:attributes\u0026gt; \u0026lt;/tx:advice\u0026gt; Spring的事务的传播特性一共有7种：\n propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。 propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。 propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。 propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作  一般第一种就够用了。\n  配置AOP\n注意要导入头文件依赖aop，详细的内容在上面，或者IDEA也会自动补全\n\u0026lt;!--配置事务切入--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;txPointCut\u0026#34; expression=\u0026#34;execution(* top.lbqaq.mapper.*(..))\u0026#34;/\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;txAdvice\u0026#34; pointcut-ref=\u0026#34;txPointCut\u0026#34;/\u0026gt; \u0026lt;/aop:config\u0026gt;   ","date":"2021-08-12T09:38:02+08:00","image":"https://lbqaq.top/p/spring/82968220_hud03476ee92894581471a20b3a26a7972_2325845_120x120_fill_q75_box_smart1.jpg","permalink":"https://lbqaq.top/p/spring/","title":"Spring学习笔记"},{"content":"因为买了一台云服务器，不拿来干点啥实在是太亏了，于是便想到了可以使用云服务器来挂卡。\n步骤 安装.net环境 ASF是基于.netcore开发的程序，所以需要安装环境。这里建议看微软官方的安装文档，里面有不同系统的安装方法。\n我们需要安装的只是ASP.NET Core 运行时。\n我的系统是centos7，这里就只列举我系统上的命令了。\nsudo rpm -Uvh https://packages.microsoft.com/config/centos/7/packages-microsoft-prod.rpm sudo yum install aspnetcore-runtime-5.0 安装ASF 在ASF的发布页面上下载系统对应的版本解压即可。\n我这里是在本地先下载好后用WinSCP直接传上服务器。\n配置ASF 这里就采用官方的**在线配置文件生成器**自动生成即可。\n我们这里选择机器人，将steam的账号和密码填入，并将Enabled设置为True就行了。\n详细的配置内容可以在官方Wiki上看到，这里就不再赘述了。\n下面放上我的配置文件：\n{ \u0026#34;SteamLogin\u0026#34;: \u0026#34;xxx\u0026#34;, \u0026#34;SteamPassword\u0026#34;: \u0026#34;xxx\u0026#34;, \u0026#34;Enabled\u0026#34;: true, \u0026#34;CustomGamePlayedWhileFarming\u0026#34;: \u0026#34;挂卡中...\u0026#34;, \u0026#34;CustomGamePlayedWhileIdle\u0026#34;: \u0026#34;空闲中...\u0026#34;, \u0026#34;FarmingOrders\u0026#34;: [ 15, 12 ], \u0026#34;HoursUntilCardDrops\u0026#34;: 0, \u0026#34;OnlineStatus\u0026#34;: 1 }  CustomGamePlayedWhileFarming：表示挂卡时显示的游戏名 CustomGamePlayedWhileIdle：表示空闲时显示的游戏名 HoursUntilCardDrops：表示至少将游戏挂到几小时，如果是非限制账户，调到0是最好的。  我们也可以配置ASF本身的设置，这里也同样贴上我的配置：\n{ \u0026#34;s_SteamOwnerID\u0026#34;: \u0026#34;xxx\u0026#34;, \u0026#34;CurrentCulture\u0026#34;: \u0026#34;zh-CN\u0026#34;, \u0026#34;IPCPassword\u0026#34;: \u0026#34;xxx\u0026#34; }  s_SteamOwnerID：该属性定义 ASF 进程所有者的 64 位 Steam ID，直接设置成自己的大号就行 CurrentCulture：ASF的语言 IPCPassword：由于ASF默认会开启IPC服务，为了安全起见建议设置密码或关闭IPC服务。  将配置文件放入config目录里就行了。\n启动ASF 首先将ASF的主程序设置为可执行：\nsudo chmod 755 ./ArchiSteamFarm 然后运行即可：\n./ArchiSteamFarm 附加步骤 使用ASCF 由于服务器在大陆境内，由于众所周知的原因是无法访问steam社区的，这时就需要使用大佬开发的转发工具了。\n【更新2.0】另一个SteamCommunityFix | 支持Win/Linux/MacOS 【2018-08-29】\n下载地址：https://pan.baidu.com/s/1nvBW8qP\n使用步骤：\n  下载并解压缩\n  打开终端（Terminal），进入到ascf程序目录： 如ascf程序在 /Users/Makazeu/Downloads/文件夹中，那么在终端中输入\ncd /Users/Makazeu/Downloads   赋予程序可执行权限，在终端中输入命令：\nchmod +x ./ascf   使用root用户（管理员用户）运行程序，在终端中输入\nsudo ./ascf 输入root用户密码后，看程序是否运行 因为程序涉及到hosts文件修改，需要高权限，所以你需要输入root密码\n  若程序已经成功运行，此时就不要关闭终端窗口了，否则程序就会退出！试下Steam社区能否正常打开\n  使用Tmux 由于我们在服务器上使用，不可能一直开着ssh，这时就需要将终端窗口和会话解绑，Tmux就是做这个工作的。\n安装：\n# Ubuntu 或 Debian $ sudo apt-get install tmux # CentOS 或 Fedora $ sudo yum install tmux # Mac $ brew install tmux 常用命令/快捷键：\n  新建会话：Tmux 窗口默认是以0、1、2\u0026hellip;\u0026hellip;来编号的，为了便于区分，可以为每个会话起名\ntmux new -s \u0026lt;session-name\u0026gt;   分离当前会话：Ctrl+b d\n  列出所有会话：Ctrl+b s或tmux ls\n  重命名当前会话：Ctrl+b $或tmux rename-session -t 0 \u0026lt;new-name\u0026gt;\n  接入到某个会话：\n# 使用会话编号 $ tmux attach -t 0 # 使用会话名称 $ tmux attach -t \u0026lt;session-name\u0026gt;   切换到某个会话：\n# 使用会话编号 $ tmux switch -t 0 # 使用会话名称 $ tmux switch -t \u0026lt;session-name\u0026gt;   参考链接  Tmux 使用教程 - 阮一峰的网络日志 ASF官方Wiki NET开发文档  ","date":"2021-08-11T21:46:24+08:00","image":"https://lbqaq.top/p/asf/82970659_hu38fcc35bf47ad0f09aab60914ff90ed7_427280_120x120_fill_q75_box_smart1.jpg","permalink":"https://lbqaq.top/p/asf/","title":"从零开始ASF挂卡"},{"content":"花了四天的时间，终于把MyBatis的视频教程全部看完了，为了以后不要那么快的遗忘掉，还是来写一下笔记比较好。\n下面的内容都是基于遇见狂神说的MyBatis视频教程而来，在此感谢能提供这么优秀的教程。\n简介  MyBatis的作用用我自己的话说，就是不用自己手动搞JDBC了，省事，行！ MyBatis作用于持久层——DAO层 【DAO (Data Access Object) 数据访问对象】，通俗点说就是用来操作数据库的层 选择MyBatis的最大原因还是用的人多，为后面的Spring打基础_(:з)∠)_  第一个MyBatis程序 思路流程：搭建环境\u0026ndash;\u0026gt;导入MyBatis\u0026mdash;\u0026gt;编写代码\u0026mdash;\u0026gt;测试\n具体代码   创建Maven项目\n  引入依赖包\n\u0026lt;!-- 导入依赖 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- mysql驱动 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.25\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- junit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;   在resources目录下创建mybatis-config.xml，作为MyBatis的配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;!--核心配置文件--\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!--每一个mapper都需要注册--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;UserMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;   编写MyBatis工具类，在utils的包下面创建MybatisUtils类，填入以下代码\nimport org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; //SqlSessionFactory  /** * @author luoboQAQ */ public class MybatisUtils { private static SqlSessionFactory sqlSessionFactory; static { try { //使用Mybatis第一步：获取SqlSessionFactory  String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。  //SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。  public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(); } }   在pojo包下创建实体类\npublic class User { private int id; //id  private String name; //姓名  private String pwd; //密码  //构造,有参,无参  //set/get  //toString() }   在dao包下创建接口类，我们需要的功能就填入到这里面\nimport top.lbqaq.pojo.User; import java.util.List; import java.util.Map; public interface UserMapper { //模糊查询  List\u0026lt;User\u0026gt; getUserLike(String value); //查询全部用户  List\u0026lt;User\u0026gt; getUserList(); //根据ID查询用户  User getUserById(int id); //插入用户  int addUser(User user); int addUser2(Map\u0026lt;String,Object\u0026gt; map); //修改用户  int updateUser(User user); //删除用户  int deleteUser(int id); }   编写Mapper.xml配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!--namespace绑定一个对应的Dao/Mapper接口--\u0026gt; \u0026lt;mapper namespace=\u0026#34;top.lbqaq.dao.UserMapper\u0026#34;\u0026gt; \u0026lt;!--id就是namespace中对应的方法名，resultType：sql语句的返回值--\u0026gt; \u0026lt;select id=\u0026#34;getUserList\u0026#34; resultType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;getUserLike\u0026#34; resultType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; select * from user where name like #{value} \u0026lt;/select\u0026gt; \u0026lt;!--parameterType：传入参数类型--\u0026gt; \u0026lt;select id=\u0026#34;getUserById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; select * from user where id=#{id} \u0026lt;/select\u0026gt; \u0026lt;insert id=\u0026#34;addUser\u0026#34; parameterType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; insert into user (id,name,pwd) values (#{id},#{name},#{pwd}) \u0026lt;/insert\u0026gt; \u0026lt;!--传递map的key--\u0026gt; \u0026lt;insert id=\u0026#34;addUser2\u0026#34; parameterType=\u0026#34;map\u0026#34;\u0026gt; insert into user (id,name,pwd) values (#{userid},#{userName},#{passWord}) \u0026lt;/insert\u0026gt; \u0026lt;update id=\u0026#34;updateUser\u0026#34; parameterType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; update user set name =#{name},pwd=#{pwd} where id=#{id} \u0026lt;/update\u0026gt; \u0026lt;delete id=\u0026#34;deleteUser\u0026#34; parameterType=\u0026#34;int\u0026#34;\u0026gt; delete from user where id=#{id} \u0026lt;/delete\u0026gt; \u0026lt;/mapper\u0026gt;   进行测试\nimport org.apache.ibatis.session.SqlSession; import org.junit.Test; import top.lbqaq.pojo.User; import top.lbqaq.utils.MybatisUtils; import java.util.HashMap; import java.util.List; public class UserMapperTest { @Test public void test() { //获得sqlSession对象  try (SqlSession sqlSession = MybatisUtils.getSqlSession()) { //执行SQL  UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u0026lt;User\u0026gt; userList = mapper.getUserList(); for (User user : userList) { System.out.println(user); } } } @Test public void getUserLike() { //获得sqlSession对象  try (SqlSession sqlSession = MybatisUtils.getSqlSession()) { //执行SQL  UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u0026lt;User\u0026gt; userList = mapper.getUserLike(\u0026#34;%李%\u0026#34;); for (User user : userList) { System.out.println(user); } } } @Test public void getUserById() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); sqlSession.close(); } @Test public void addUser(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); int res = mapper.addUser(new User(4, \u0026#34;小明\u0026#34;, \u0026#34;123\u0026#34;)); if(res\u0026gt;0){ System.out.println(\u0026#34;提交成功\u0026#34;); //提交事务  sqlSession.commit(); } sqlSession.close(); } @Test public void addUser2(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap\u0026lt;String,Object\u0026gt; map= new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;userid\u0026#34;,5); map.put(\u0026#34;userName\u0026#34;,\u0026#34;小绿\u0026#34;); map.put(\u0026#34;passWord\u0026#34;,\u0026#34;1234\u0026#34;); int res = mapper.addUser2(map); if(res\u0026gt;0){ System.out.println(\u0026#34;提交成功\u0026#34;); //提交事务  sqlSession.commit(); } sqlSession.close(); } @Test public void updateUser(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); int res = mapper.updateUser(new User(4, \u0026#34;小明\u0026#34;, \u0026#34;123456\u0026#34;)); if(res\u0026gt;0){ System.out.println(\u0026#34;提交成功\u0026#34;); //提交事务  sqlSession.commit(); } sqlSession.close(); } @Test public void deleteUser(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); int res = mapper.deleteUser(4); if(res\u0026gt;0){ System.out.println(\u0026#34;提交成功\u0026#34;); //提交事务  sqlSession.commit(); } sqlSession.close(); } }   注意事项   如果Mapper.xml创建在java目录里而不是resouces里，需要在Maven配置里配置过滤，否则会保错\n\u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt;   当需要传入参数进行查询而不是传入实体类，有两种方法\n  第一种：直接在方法中传递参数。\n在接口方法的参数前加@Param属性，sql语句编写的时候，直接取@Param中设置的值即可，不需要单独设置参数类型\nUser selectUserByNP(@Param(\u0026#34;username\u0026#34;) String username,@Param(\u0026#34;pwd\u0026#34;) String pwd); /* \u0026lt;select id=\u0026#34;selectUserByNP\u0026#34; resultType=\u0026#34;top.lbqaq.pojo.User\u0026#34;\u0026gt; select * from user where name = #{username} and pwd = #{pwd} \u0026lt;/select\u0026gt; */   第二种：通过map来传递参数。（推荐）\n在接口创建时就直接使用map作为参数\nint addUser2(Map\u0026lt;String,Object\u0026gt; map); 在写sql时直接设置入参为map即可\n\u0026lt;!--传递map的key--\u0026gt; \u0026lt;insert id=\u0026#34;addUser2\u0026#34; parameterType=\u0026#34;map\u0026#34;\u0026gt; insert into user (id,name,pwd) values (#{userid},#{userName},#{passWord}) \u0026lt;/insert\u0026gt;     配置解析 官方文档\n核心配置 MyBatis官方给出的配置项有以下这么多：\nconfiguration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） \u0026lt;!-- 注意元素节点的顺序！顺序不对会报错 --\u0026gt; 我们需要关注的就是properties（属性）、settings（设置）、typeAliases（类型别名）、plugins（插件）、environments（环境配置）、mappers（映射器）这几项配置，其余的可以忽略（基本用不到）\nproperties 数据库这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。\n说白了，就是能将数据库那些配置项从核心配置中剥离出来，降低耦合。\n用法   在resources目录下创建db.properties，填入下面的内容\ndriver=com.mysql.cj.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis username=root password=root   在配置xml中导入\n\u0026lt;!--引用外部配置文件--\u0026gt; \u0026lt;properties resource=\u0026#34;db.properties\u0026#34;\u0026gt; \u0026lt;!--外部文件优先级大于内部（下面）--\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123\u0026#34;/\u0026gt; \u0026lt;/properties\u0026gt; 正常情况下，只需要用\u0026lt;properties resource=\u0026quot;db.properties\u0026quot;/\u0026gt;这短短一句就行了，上面的代码是用来测试优先级的\n  settings 这里存放的是MyBatis的一些设置项，具体的内容在官方文档上可以查看\n常用的设置项有以下几个：\n   设置名 描述 有效值 默认值     cacheEnabled 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。 true | false true   mapUnderscoreToCamelCase 是否开启驼峰命名自动映射，即从经典数据库列名A_COLUMN 映射到经典 Java 属性名 aColumn。 true | false False   logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 未设置    typeAliases 类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。\n也就是在resultType和parameterType中不需要写那么长的类名了\n用法 \u0026lt;!--可以给实体类起别名--\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;!--手动指定--\u0026gt; \u0026lt;typeAlias type=\u0026#34;top.lbqaq.pojo.User\u0026#34; alias=\u0026#34;User\u0026#34;/\u0026gt; \u0026lt;!--自动扫描包下所有类，别名为类名全小写--\u0026gt; \u0026lt;package name=\u0026#34;top.lbqaq.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; 有两种方法，第一种就是手动指定别名，第二种就是通过package标签自动扫描包下所有的类\n在第二种方法下，默认别名是类名全小写（当然首字母大写也同样可用）\n如果在类前加上@Alias注解，则别名就为手动设定的内容。\nplugins 这里是配置mybatis的插件的地方，常用的插件有以下几个：\n PageHelper MyBatis-Plus \u0026hellip; \u0026hellip;  这里是就不展开这些插件了，以后有需要再看\nenvironments 配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定）。\n\u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt;  transactionManager： 事务管理器 。有两个选项：  JDBC：正常的 MANAGED：几乎啥都不干   dataSource：如何使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。有三个选项：  unpooled：这个数据源的实现只是每次被请求时打开和关闭连接。 pooled：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。 jndi：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。    mappers 用于告诉MyBatis我们写的xml文件到底在哪，每个xml文件都需要绑定！\n常用的有以下几种方法：\n\u0026lt;!-- 使用相对于类路径的资源引用 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;top/lbqaq/dao/UserMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;!-- 使用映射器接口实现类的完全限定类名 需要配置文件名称和接口名称一致，并且位于同一目录下 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper class=\u0026#34;top.lbqaq.dao.UserMapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;!-- 将包内的映射器接口实现全部注册为映射器 但是需要配置文件名称和接口名称一致，并且位于同一目录下 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;package name=\u0026#34;org.mybatis.builder\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; ResultMap 属性名和字段名不一致 在实际开发中，会遇到类的属性名和数据库的字段名不一致，这时MyBatis的自动匹配将无法产生作用，这时可以使用ResultMap来解决这个问题。\n\u0026lt;mapper namespace=\u0026#34;top.lbqaq.dao.UserMapper\u0026#34;\u0026gt; \u0026lt;!--结果集映射--\u0026gt; \u0026lt;resultMap id=\u0026#34;UserMap\u0026#34; type=\u0026#34;User\u0026#34;\u0026gt; \u0026lt;!--column:数据库中的字段；property：实体类的属性--\u0026gt; \u0026lt;!-- \u0026lt;result column=\u0026#34;id\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;result column=\u0026#34;name\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;result column=\u0026#34;pwd\u0026#34; property=\u0026#34;password\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getUserById\u0026#34; parameterType=\u0026#34;int\u0026#34; resultMap=\u0026#34;UserMap\u0026#34;\u0026gt; select * from user where id=#{id} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 多对一 在开发时常常会有这样的需求，比如多个学生都被一个老师教，下面将对该实例具体展开来了解多对一如何处理。\n环境搭建   添加Lombok插件\n  引入Maven依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.20\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   编写实体类\n@Data public class Student { private int id; private String name; /** * 学生需要关联一个老师 */ private Teacher teacher; } @Data public class Teacher { private int id; private String name; }   按查询嵌套处理 思路：\n  获取所有学生的信息\n  根据获取的学生信息的老师ID-\u0026gt;获取该老师的信息\n  思考问题，这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般使用关联查询？\n 做一个结果集映射：StudentTeacher StudentTeacher结果集的类型为 Student 学生中老师的属性为teacher，对应数据库中为tid。 多个 [1,\u0026hellip;）学生关联一个老师=\u0026gt; 一对一，一对多 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查询    \u0026lt;select id=\u0026#34;getStudent\u0026#34; resultMap=\u0026#34;StudentTeacher\u0026#34;\u0026gt; select * from student \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;StudentTeacher\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;id\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;name\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;!--复杂的属性需要单独处理 对象：association 集合：collection--\u0026gt; \u0026lt;association column=\u0026#34;tid\u0026#34; property=\u0026#34;teacher\u0026#34; javaType=\u0026#34;Teacher\u0026#34; select=\u0026#34;getTeacher\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultType=\u0026#34;Teacher\u0026#34;\u0026gt; select * from teacher where id=#{tid} \u0026lt;/select\u0026gt; 注意点：\n\u0026lt;resultMap id=\u0026#34;StudentTeacher\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--\u0026gt; \u0026lt;association property=\u0026#34;teacher\u0026#34; column=\u0026#34;{id=tid,name=tid}\u0026#34; javaType=\u0026#34;Teacher\u0026#34; select=\u0026#34;getTeacher\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!-- 这里传递过来的id，只有一个属性的时候，下面可以写任何值 association中column多参数配置： column=\u0026#34;{key=value,key=value}\u0026#34; 其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。 --\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultType=\u0026#34;teacher\u0026#34;\u0026gt; select * from teacher where id = #{id} and name = #{name} \u0026lt;/select\u0026gt; 这个还是比较难以理解的，一般我选择用第二种方法\n按结果嵌套处理 \u0026lt;!--按照结果嵌套处理--\u0026gt; \u0026lt;select id=\u0026#34;getStudent2\u0026#34; resultMap=\u0026#34;StudentTeacher2\u0026#34;\u0026gt; select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid=t.id \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;StudentTeacher2\u0026#34; type=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;sid\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;sname\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;association property=\u0026#34;teacher\u0026#34; javaType=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;tname\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; 这种就比较好理解了，难度主要在sql部分，好在之前数据库学的还行，这种方法还是比较适合我。\n一对多 一个老师会教多个学生。\n环境搭建 @Data public class Student { private int id; private String name; private int tid; } @Data public class Teacher { private int id; private String name; /** * 一个老师有多个学生 */ private List\u0026lt;Student\u0026gt; students; } 按结果嵌套查询 \u0026lt;!--按结果嵌套查询--\u0026gt; \u0026lt;select id=\u0026#34;getTeacher\u0026#34; resultMap=\u0026#34;TeacherStudent\u0026#34;\u0026gt; select s.id sid,s.name sname,t.name tname,t.id tid from student s,teacher t where s.tid=t.id and t.id=#{tid} \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;TeacherStudent\u0026#34; type=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;tid\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;tname\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;!--集合中的泛型信息用ofType获取--\u0026gt; \u0026lt;collection property=\u0026#34;students\u0026#34; ofType=\u0026#34;Student\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;sid\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;sname\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;tid\u0026#34; property=\u0026#34;tid\u0026#34;/\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt; JavaType和ofType都是用来指定对象类型的。\nJavaType是用来指定pojo中属性的类型。\nofType指定的是映射到list集合属性中pojo的类型。\n按查询嵌套 \u0026lt;!--按查询嵌套--\u0026gt; \u0026lt;select id=\u0026#34;getTeacher2\u0026#34; resultMap=\u0026#34;TeacherStudent2\u0026#34;\u0026gt; select * from teacher where id=#{tid} \u0026lt;/select\u0026gt; \u0026lt;resultMap id=\u0026#34;TeacherStudent2\u0026#34; type=\u0026#34;Teacher\u0026#34;\u0026gt; \u0026lt;collection property=\u0026#34;students\u0026#34; javaType=\u0026#34;ArrayList\u0026#34; ofType=\u0026#34;Student\u0026#34; select=\u0026#34;getStudentByTeacherId\u0026#34; column=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getStudentByTeacherId\u0026#34; resultType=\u0026#34;Student\u0026#34;\u0026gt; select * from student where tid = #{tid} \u0026lt;/select\u0026gt; 日志工厂 如果一个数据库相关的操作出现了问题，我们可以根据输出的SQL语句快速排查问题。可见打印出SQL语句是十分重要的。（还记得之前项目综合实践为了搞日志忙了半天，结果还是没搞出来😭）\n标准日志 在MyBatis里自带了通过控制台打印的日志功能，如果项目并不是很复杂，用它就足够了。\n只需要在设置里设置启用就可以了。\n\u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;STDOUT_LOGGING\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; log4j log4j相比标准日志，那不知道高到哪里去了，具体的功能我就不写了，毕竟一百度就能出来了。\n使用步骤：\n  导入log4j的包\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   在resources目录下新建log4j.properties，并填入以下配置文件\n#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码 log4j.rootLogger=DEBUG,console,file #控制台输出的相关设置 log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n #文件输出的相关设置 log4j.appender.file = org.apache.log4j.RollingFileAppender log4j.appender.file.File=./log/log.log log4j.appender.file.MaxFileSize=10mb log4j.appender.file.Threshold=DEBUG log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n #日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG   在MyBatis里启用\n\u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;logImpl\u0026#34; value=\u0026#34;LOG4J\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt;   在程序中使用Log4j进行输出\nimport org.apache.log4j.Logger; import org.junit.Test; public class UserMapperTest { static Logger logger = Logger.getLogger(UserMapperTest.class); @Test public void testLog4j(){ logger.info(\u0026#34;info:进入了testLog4j\u0026#34;); logger.debug(\u0026#34;debug:进入了testLog4j\u0026#34;); logger.error(\u0026#34;error:进入了testLog4j\u0026#34;); } }   使用注解开发 MyBatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。\n而到MyBatis 3提供了新的基于注解的配置。不幸的是，Java 注解的的表达力和灵活性十分有限。最强大的 MyBatis 映射并不能用注解来构建。\n在注解开发中，主要使用这几个注解：@select ()、@update ()、@Insert ()、@delete ()\n举例：\npublic interface UserMapper { @Select(\u0026#34;select * from user\u0026#34;) List\u0026lt;User\u0026gt; getUser(); @Select(\u0026#34;select * from user where id=#{id}\u0026#34;) User getUserByID(@Param(\u0026#34;id\u0026#34;) int id); @Insert(\u0026#34;insert into user(id,name,pwd) values(#{id},#{name},#{pwd})\u0026#34;) int addUser(User user); } 改造MybatisUtils工具类的getSession() 方法，重载实现。\n//获取SqlSession连接 public static SqlSession getSession(){ return getSession(true); //事务自动提交 } public static SqlSession getSession(boolean flag){ return sqlSessionFactory.openSession(flag); } @Param注解用于给方法参数起一个名字。以下是总结的使用原则：\n 在方法只接受一个参数的情况下，可以不使用@Param。 在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。 如果参数是 JavaBean ， 则不能使用@Param。 不使用@Param注解时，参数只能有一个，并且是JavaBean。  动态SQL 动态SQL指的是根据不同的查询条件 , 生成不同的sql语句。\n主要使用这几个标签：if、choose、where、set、foreach\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;top.lbqaq.dao.BlogMapper\u0026#34;\u0026gt; \u0026lt;insert id=\u0026#34;addBook\u0026#34; parameterType=\u0026#34;Blog\u0026#34;\u0026gt; insert into blog(id, title, author, create_time, views) values (#{id}, #{title}, #{author}, #{createTime}, #{views}) \u0026lt;/insert\u0026gt; \u0026lt;select id=\u0026#34;queryBlogIF\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;queryBlogChoose\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; and views = #{view} \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;update id=\u0026#34;updateBlog\u0026#34; parameterType=\u0026#34;map\u0026#34;\u0026gt; update blog \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id = #{id} \u0026lt;/update\u0026gt; \u0026lt;select id=\u0026#34;queryBlogForeach\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;Blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;!--collection:指定输入对象中的集合属性 item:每次遍历生成的对象 open:开始遍历时的拼接字符串 close:结束时拼接的字符串 separator:遍历对象之间需要拼接的字符串--\u0026gt; \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34; separator=\u0026#34;or\u0026#34;\u0026gt; id = #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; SQL片段 有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。\n提取SQL片段：\n\u0026lt;sql id=\u0026#34;if-title-author\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;title != null\u0026#34;\u0026gt; title = #{title} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;author != null\u0026#34;\u0026gt; and author = #{author} \u0026lt;/if\u0026gt; \u0026lt;/sql\u0026gt; 引用SQL片段：\n\u0026lt;select id=\u0026#34;queryBlogIf\u0026#34; parameterType=\u0026#34;map\u0026#34; resultType=\u0026#34;blog\u0026#34;\u0026gt; select * from blog \u0026lt;where\u0026gt; \u0026lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --\u0026gt; \u0026lt;include refid=\u0026#34;if-title-author\u0026#34;\u0026gt;\u0026lt;/include\u0026gt; \u0026lt;!-- 在这里还可以引用其他的 sql 片段 --\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 注意：\n①、最好基于 单表来定义 sql 片段，提高片段的可重用性\n②、在 sql 片段中不要包括 where\n缓存 简介 1、什么是缓存 [ Cache ]？\n 存在内存中的临时数据。 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。  2、为什么使用缓存？\n 减少和数据库的交互次数，减少系统开销，提高系统效率。  3、什么样的数据能使用缓存？\n 经常查询并且不经常改变的数据。  MyBatis缓存   MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。\n  MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存\n   默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存    一级缓存 一级缓存也叫本地缓存：\n 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；  一级缓存失效的四种情况  sqlSession不同 sqlSession相同，查询条件不同 sqlSession相同，两次查询之间执行了增删改操作！ sqlSession相同，手动清除一级缓存  二级缓存   二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存\n  基于namespace级别的缓存，一个名称空间，对应一个二级缓存；\n  工作机制\n   一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存（map）中；    使用方法   开启全局缓存 mybatis-config.xml\n\u0026lt;setting name=\u0026#34;cacheEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt;   去每个mapper.xml中配置使用二级缓存，这个配置非常简单。\n\u0026lt;cache/\u0026gt; 官方示例 \u0026lt;cache eviction=\u0026#34;FIFO\u0026#34; flushInterval=\u0026#34;60000\u0026#34; size=\u0026#34;512\u0026#34; readOnly=\u0026#34;true\u0026#34;/\u0026gt; 这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。   ","date":"2021-08-11T11:11:10+08:00","image":"https://lbqaq.top/p/mybatis/86164137_hudf396ad5f75caaaed9aa8bcb008fce93_362314_120x120_fill_q75_box_smart1.jpg","permalink":"https://lbqaq.top/p/mybatis/","title":"MyBatis学习笔记"},{"content":"这篇文章我打算来介绍一下如何构建qsqlmysql.dll，由于版权原因，在新版的Qt里是不自带该dll的，这样对我们编写数据库程序会很麻烦。（你用ODBC？那没事了）\n我在网上也查了很多资料，但根据步骤来总是会报错，提示没有mysql.h这个头文件。下面就记录一下我成功编译的过程。\n基于cmake的步骤 在6.1之后的Qt版本中，Qt公司删除了qmake而更换成了cmake的方式来构建项目文件，下面就是我总结的使用cmake生成的方法。\n注意： 路径的前段部分(软件的安装位置)每个人可能都不一样，但是路径的后段部分应该是一样的，请自行修改。\n1.准备好Qt的源代码，如果没有可以在Qt的安装目录打开MaintenanceTool.exe启动Qt组件管理，在里面勾选Src把源码下载下来。\n2.打开cmake-gui，选择目标文件夹为D:\\Qt\\6.1.1\\Src\\qtbase\\src\\plugins\\sqldrivers，并设置生成文件夹为D:/Qt/6.1.1/Src/qtbase/src/plugins/sqldrivers/build\n 配置文件夹 \n3.点击左下角的Configure，会提示生成的目录不存在是否创建，直接点是就可以了。\n4.编译器这里选择MinGW Makefiles,然后点击Finish\n 选择编译器 \n5.等待生成完成后，把FEATURE_sql_mysql后面的勾勾上，然后把其余的FEATURE_sql后面的勾取消。\n 选择生成模块 \n6.再次点击左下角的Configure，可以发现上面的红框已经消失了，说明配置成功了。然后点击Generate，生成Makefiles。\n 配置成功 \n7.这时配置文件已经构建完成了，接下来就是生成dll了，打开PowerShell切换目录至D:/Qt/6.1.1/Src/qtbase/src/plugins/sqldrivers/build，输入mingw32-make开始编译生成dll。\n 编译成功 \n没有报错，说明生成成功。\n8.最后打开目录D:\\Qt\\6.1.1\\Src\\qtbase\\src\\plugins\\sqldrivers\\build\\plugins\\sqldrivers，就可以看到生成好的qsqlmysql.dll了。\n基于qmake的步骤 注意： 路径的前段部分(软件的安装位置)每个人可能都不一样，但是路径的后段部分应该是一样的，请自行修改。\n1.准备好Qt的源代码，如果没有可以在Qt的安装目录打开MaintenanceTool.exe启动Qt组件管理，在里面勾选Src把源码下载下来。\n2.进入D:\\Qt\\6.0.3\\Src\\qtbase\\src\\plugins\\sqldrivers目录下，打开sqldrivers.pro这个文件。\n3.在左侧文件树中打开mysql文件夹，选择mysql.pro打开。\n4.修改里面的内容：\n  注释掉QMAKE_USE += mysql这一句\n  增加下面三行代码(注意把D:/MySQL/改为你MySQL的安装路径)：\nLIBS +=-LD:/MySQL/lib -llibmysql INCLUDEPATH += D:/MySQL/include DEPENDPATH += D:/MySQL/include   5.点击Qt左下角的小锤子进行构建，不出意外的话就可以在D:\\Qt\\6.0.3\\Src\\qtbase\\src\\plugins这个路径下看到build开头的文件夹，在.\\plugins\\sqldrivers目录下就能看到编译好的dll了。\n6.最后将qsqlmysql.dll放入D:\\Qt\\6.0.3\\mingw81_64\\plugins\\sqldrivers\\里就行了。如果链接数据库时还报错，就把libmysql.dll复制到Qt的编译器的D:\\Qt\\6.0.3\\mingw81_64\\bin\\目录。\n","date":"2021-06-03T15:44:17+08:00","image":"https://lbqaq.top/p/qt%E6%9E%84%E5%BB%BAqsqlmysql.dll/89217963_hu5f736f3854c953c513cfaec8c3d31831_4303313_120x120_fill_box_smart1_3.png","permalink":"https://lbqaq.top/p/qt%E6%9E%84%E5%BB%BAqsqlmysql.dll/","title":"Qt构建qsqlmysql.dll"},{"content":"1202年了，是时候抛弃老旧的cmd窗口和臃肿的VM虚拟机了，来试试巨硬推出的WSL2+Windows Terminal(～￣▽￣)～。\n起因 在知乎上刷到了一篇回答，是关于Windows编程的体验的。在这篇文章中提到了WSL2和Windows Terminal，我一下就被那精美的界面吸引了（管他好不好用，好看就完事了）。正好现在在上操作系统这门课，需要使用Linux进行实验，这还说什么，直接开冲。\n 精美的界面 \nWSL2安装 安装其实很简单，按照微软的教程一步一步做就完事了。\n0.前置条件 想要用WSL2，首先你得是 Windows 10，而且还有版本号要求。\n 对于 x64 系统：版本 1903 或更高版本，采用 内部版本 18362 或更高版本。 对于 ARM64 系统：版本 2004 或更高版本，采用 内部版本 19041 或更高版本。  1. 开启WSL服务 在Powershell(管理员)中输入下面的命令：\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 2. 启用虚拟机服务 在Powershell(管理员)中输入下面的命令：\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 重新启动 计算机，以完成 WSL 安装并更新到 WSL 2。\n3. 下载 Linux 内核更新包 下载最新包并安装：\n 适用于 x64 计算机的 WSL2 Linux 内核更新包  4. 将 WSL 2 设置为默认版本 在Powershell中输入下面的命令：\nwsl --set-default-version 2 5.安装 Linux  打开 Microsoft Store，并选择你偏好的 Linux 分发版并点击获取进行安装。 等安装好后，打开并设置用户名和密码。  到此WSL2就安装完事了。\nWindows Terminal安装 1. 下载和安装   从Microsoft Store中下载\n  从Github上下载\n  2. 配置 为了让Windows Terminal看起来更好看一些，我们还要对其进行一些配置。\n 设置 \n打开Windows Terminal的设置选项，然后选打开JSON文件，把我配好的配置文件粘贴进去\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://aka.ms/terminal-profiles-schema\u0026#34;, // Add custom actions and keybindings to this array. // To unbind a key combination from your defaults.json, set the command to \u0026#34;unbound\u0026#34;. // To learn more about actions and keybindings, visit https://aka.ms/terminal-keybindings \u0026#34;actions\u0026#34;: [ // Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json. // These two lines additionally bind them to Ctrl+C and Ctrl+V. // To learn more about selection, visit https://aka.ms/terminal-selection { \u0026#34;command\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;copy\u0026#34;, \u0026#34;singleLine\u0026#34;: false }, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+c\u0026#34; }, { \u0026#34;command\u0026#34;: \u0026#34;paste\u0026#34;, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+v\u0026#34; }, // Press Ctrl+Shift+F to open the search box { \u0026#34;command\u0026#34;: \u0026#34;find\u0026#34;, \u0026#34;keys\u0026#34;: \u0026#34;ctrl+shift+f\u0026#34; }, // Press Alt+Shift+D to open a new pane. // - \u0026#34;split\u0026#34;: \u0026#34;auto\u0026#34; makes this pane open in the direction that provides the most surface area. // - \u0026#34;splitMode\u0026#34;: \u0026#34;duplicate\u0026#34; makes the new pane use the focused pane\u0026#39;s profile. // To learn more about panes, visit https://aka.ms/terminal-panes { \u0026#34;command\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;splitPane\u0026#34;, \u0026#34;split\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;splitMode\u0026#34;: \u0026#34;duplicate\u0026#34; }, \u0026#34;keys\u0026#34;: \u0026#34;alt+shift+d\u0026#34; } ], \u0026#34;copyFormatting\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;copyOnSelect\u0026#34;: false, \u0026#34;defaultProfile\u0026#34;: \u0026#34;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\u0026#34;, \u0026#34;initialCols\u0026#34;: 120, \u0026#34;initialRows\u0026#34;: 30, \u0026#34;profiles\u0026#34;: { \u0026#34;defaults\u0026#34;: { \u0026#34;acrylicOpacity\u0026#34;: 0.75, \u0026#34;closeOnExit\u0026#34;: \u0026#34;graceful\u0026#34;, \u0026#34;colorScheme\u0026#34;: \u0026#34;Campbell\u0026#34;, \u0026#34;cursorColor\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, \u0026#34;cursorShape\u0026#34;: \u0026#34;bar\u0026#34;, \u0026#34;fontFace\u0026#34;: \u0026#34;Consolas\u0026#34;, \u0026#34;fontSize\u0026#34;: 13, \u0026#34;historySize\u0026#34;: 9001, \u0026#34;padding\u0026#34;: \u0026#34;0, 0, 0, 0\u0026#34;, \u0026#34;snapOnInput\u0026#34;: true, \u0026#34;startingDirectory\u0026#34;: \u0026#34;./\u0026#34;, \u0026#34;useAcrylic\u0026#34;: true }, \u0026#34;list\u0026#34;: [ { \u0026#34;commandline\u0026#34;: \u0026#34;powershell.exe -NoLogo\u0026#34;, \u0026#34;guid\u0026#34;: \u0026#34;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Windows PowerShell\u0026#34; }, { \u0026#34;commandline\u0026#34;: \u0026#34;cmd.exe\u0026#34;, \u0026#34;guid\u0026#34;: \u0026#34;{0caa0dad-35be-5f56-a8ff-afceeeaa6101}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Command Prompt\u0026#34; }, { \u0026#34;guid\u0026#34;: \u0026#34;{b453ae62-4e3d-5e58-b989-0a998ec441b8}\u0026#34;, \u0026#34;hidden\u0026#34;: true, \u0026#34;name\u0026#34;: \u0026#34;Azure Cloud Shell\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;Windows.Terminal.Azure\u0026#34; }, { \u0026#34;guid\u0026#34;: \u0026#34;{2c4de342-38b7-51cf-b940-2309a097f518}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Ubuntu\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;Windows.Terminal.Wsl\u0026#34;, \u0026#34;startingDirectory\u0026#34;: \u0026#34;//wsl$/Ubuntu/home/luobo\u0026#34; } ] } } 一般要修改这几项：\n fontFace - 字体，我的字体为Consolas，适合1080P的屏幕。高分辩率屏建议用monaco或者fira code fontSize - 字体大小，因人而异，因屏幕而异，自己根据视觉效果调整大小 acrylicOpacity - 背景透明度，同样因人而异，因屏幕而异，自己根据视觉效果调整大小 initialCols - 初始窗口宽度，同样因人而异，因屏幕而异，自己根据视觉效果调整大小 initialRows - 初始窗口高度，同样因人而异，因屏幕而异，自己根据视觉效果调整大小 startingDirectory - Ubuntu的默认打开路径，把其中的luobo换成你自己的用户名。  WSL+VSCode 毕竟都是微软家的软件，直接就能通过VSCode来远程编辑Linux里的文件。vim太难上手？我直接在Windows里编程(雾)。\n只要在项目目录里键入code .，就会自动跳到Windows里的VSCode里了。\n小结 WSL+Windows Terminal+VSCode，将三者配合起来，我觉得可以实现1+1+1\u0026gt;3的功能，毕竟，谁不喜欢颜值高的软件呢ヾ(≧▽≦*)o\n参考链接  微软官方WSL2教程 微软官方Windows Terminal教程 Windows Terminal 终端入门  ","date":"2021-04-08T13:14:20+08:00","image":"https://lbqaq.top/p/wsl2-wt%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93/43493473_hu0b461f4faf109c1e7e1e6db59436d03b_285140_120x120_fill_box_smart1_3.png","permalink":"https://lbqaq.top/p/wsl2-wt%E9%85%8D%E7%BD%AE%E5%B0%8F%E7%BB%93/","title":"WSL2+WT配置小结"},{"content":"PyAipao简介 该项目可实现阳光体育一键跑步，同时可基于GitHub Actions来实现云跑步。\n仅需一次配置，即可轻松跑完一学期ヾ(≧▽≦*)o\n准备工作 1.一个github账号 2.抓包抓到的IMEICode 3.Server酱的SCKEY或企业微信（可选，用于微信推送跑步结果）  云跑步上手教程 1.点击fork按钮将该仓库复制到你的仓库  fork \n2.获取 IMEICode\n 打开抓包软件抓包, 再打开阳光体育 App 登录, 在所有的数据包中找后缀有 IMEICode=  的 URL 请求, 等号后面的字段即为七天有效的 IMEICode (若多次没抓到: 可来回切换几次飞行模式, 杀掉 App 后台重复尝试多次)  如果不需要推送，可以直接略过第3步\n3.1基于Server酱的推送\n 完成Server酱的注册和绑定 点我直达 在 SendKey这一页中找到SendKey并记录  SendKey   3.2基于企业微信应用消息的推送\n由于Server酱不捐助是无法查看消息内容的，所以为了白嫖我自己写了推送部分的代码，可以直接使用微信官方接口来推送。\n企业微信的配置方法可以在Server酱的消息通道里看到，这里就不赘述了。\n weisend \n和Server酱一样，我们也需要企业ID(CORPID)，应用ID(AGENTID)，应用Secret(SECRET)这三个值。\n4.配置Github Actions\n  打开仓库的secrets，在其中建立IMEICODE并将IMEICode填入  4.1 \n  （可选）使用Server酱推送，需要建立SCKEY并填入SendKey\n  （可选）使用企业微信应用消息推送，需要建立CORPID\u0026ndash;填入企业ID，AGENTID\u0026ndash;填入应用ID，SECRET\u0026ndash;填入应用Secret\n  打开Code-.github/workflows-autorun.yml，点击右上角的铅笔图标进行编辑，将时间改为你想让它每天按时跑的时间，默认为每天上午9点；同时修改推送方式，默认不推送。\n   4.2 \n注意：autorun.yml里的时间为UTC时间而不是北京时间 点我转换\n  启用Github Actions\n workflow \n   4.3 \n到这步已经配置完成了，它每天就会自己跑了。\n5.(可选)手动开始跑步\n 如果想手动开始跑步，点击Actions，按照图示步骤操作即可。  5.1   6.关闭自动跑步\n  在仓库Settings-Actions中选择Disable Actions\n 6.1 \n  参考链接  AutoAction AiPao  注意事项 License GPL v3.0\n本文仅供研究，使用者造成的任何后果由使用者自行承担，与作者无关。\n","date":"2021-03-11T10:25:00+08:00","image":"https://lbqaq.top/p/pyaipao/87856451_huf58260040af023debd102865c61ea42c_2928959_120x120_fill_q75_box_smart1.jpg","permalink":"https://lbqaq.top/p/pyaipao/","title":"PyAipao"},{"content":"看到zsnmwy大佬的博客，和我使用的是同样的主题，但是人家却多了一些动画，瞬间就高级起来了。于是打开百度搜素一波，发现只要改一下CSS就可以实现了。\n准备工具   hugo的扩展版（extended）\n这里一定要下扩展版，因为我使用的主题都是利用scss来生成css的，如果用普通版是无法利用scss生成对应的css的。之前不知道下的是普通版，结果怎么改scss都没有效果，浪费了很多时间😥。\n  相关代码 1.头像转动 在themes/hugo-theme-stack/assets/scss/partials/sidebar.scss中增加以下代码：\n.site-logo { transition: all 1.75s ease-out; } .site-logo:hover { transform: rotate(360deg); } 2.文章头图缩放 在themes/hugo-theme-stack/assets/scss/partials/article.scss中增加以下代码：\n.article-image { overflow:hidden; } .article-image { img { transition:all .5s ease; } \u0026amp;:hover{ transform:scale(1.2); } 3.Archives页面缩放 在themes/hugo-theme-stack/assets/scss/partials/article.scss中增加以下代码：\narticle{ transition:.5s ease; } article { \u0026amp;:hover{ transform:scale(1.05,1.05); background:#f0f8ff; } } 4.菜单缩放 在themes/hugo-theme-stack/assets/scss/partials/menu.scss中增加以下代码：\noverflow-y: visible; //把auto改为visible，为了图标放大溢出时不显示滚动条 li { transition:.5s ease; } li{ \u0026amp;:hover{ transform:scale(1.1,1.1); } } 有了动画后，感觉整个博客都变得高级起来了ヾ(•ω•`)o\n在这感谢zsnmwy大佬，上面有些动画懒得自己写了，就直接从他的css中复制了ヾ(￣▽￣)\n","date":"2021-02-01T13:55:05+08:00","image":"https://lbqaq.top/p/%E7%BB%99blog%E5%A2%9E%E5%8A%A0%E5%8A%A8%E7%94%BB/86589864_hu78fbbc6652b920150235079836d94b1b_2463299_120x120_fill_box_smart1_3.png","permalink":"https://lbqaq.top/p/%E7%BB%99blog%E5%A2%9E%E5%8A%A0%E5%8A%A8%E7%94%BB/","title":"给Blog增加动画"},{"content":"最近刷了好几道关于STL的竞赛题，许多知识点还是不熟练，在继续学习之前，还是来好好整理一下一些常见的STL和容器吧。紫书上介绍的有以下几种：\n 线性：vector,list,string 关联：map,set 特殊：stack,queue,priority_queue 算法：sort,lower_bound,find  vector vector可以理解为可以自由变换长度的数组(不定长数组)，个人感觉使用频率还是很高的。vector是连续的，意味着可以使用[]或at()。\n声明： vector\u0026lt;int\u0026gt; a\n常用函数   push_back：在尾部添加一个数据\n  pop_back：删除尾部的一个数据\n  size：当前的大小（就是有多少元素）\n  erase：删除指针指向的数据项\n  clear：清空\n  empty：判断是否为空\n  deque deque可以看作是双向队列，是连续存储结构。vector有的功能它都有，还支持高效的首/尾端插入/删除操作。\n新增函数  push_front：在头部添加一个数据 pop_front：在头部删除一个数据  list list可以看作是双链表，是非连续存储结构。可在两端进行push、pop，同时在内部可以很方便的进行插入和删除操作。不过我没怎么用到这个容器。等我做到相关的题目再来补充一些信息吧。\nstring string就是字符串。相比char[]那可是方便不少，c++的cin/cout就只支持string类型而不支持char型数组。string还支持+、=、+=等运算符。\n常用函数   append：在字符串后添加（相当于+=）\n  substr(n,m)：返回string的子串，从n处开始，取m个。当m省略或超过了字符串的长度，则一直取到字符串结束。\n  查找相关函数：\n如果没有查到，返回string::npos。\n  find：从前往后查找子串或字符出现的位置。\n  rfind：从后往前查找子串或字符出现的位置。\n  find_first_of：从前往后查找何处出现另一个字符串中包含的字符。例如：\n  s1.find_first_of(\u0026ldquo;abc\u0026rdquo;); //查找s1中第一次出现\u0026quot;abc\u0026quot;中任一字符的位置\n  find_last_of：从后往前查找何处出现另一个字符串中包含的字符。\n  find_first_not_of：从前往后查找何处出现另一个字符串中没有包含的字符。\n  find_last_not_of：从后往前查找何处出现另一个字符串中没有包含的字符。\n  流处理 可以通过\u0026lt;sstream\u0026gt;，将string对象作为一个流。例如：\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;sstream\u0026gt;#include \u0026lt;string\u0026gt;using namespace std; int main(){ string line; while(getline(cin,line)){ stringstream ss(line); while(ss\u0026gt;\u0026gt;x){...} } } set set就是数学中的集合，每个元素只能出现一次，set中的元素已经从小到大排好了。\n常用函数  insert：插入一个元素 erase：删除，可以传入定位器，也可直接传入值 count：统计元素出现的个数，因为只有0/1个，所以一般用来判断元素是否存在 find：查找  对于自己定义的结构体，需要重载\u0026lt;运算符。\n常用算法 在\u0026lt;algorithm\u0026gt;中提供了关于set的两种算法（目前只知道两种）\n  set_union：取两个集合的并集，例如：\n#define ALL(x) x.begin(),x.end() #define INS(x) inserter(x,x.begin()) set_union(ALL(x1),ALL(x2),INS(x)); //将x1和x2的内容取并集后放入x中   set_intersection：取两个集合的交集，例如：\nset_intersection(ALL(x1),ALL(x2),INS(x)); //将x1和x2的内容取交集放入x中   map map是映射，支持[]运算符，还是非常实用的。\nmap的函数和set基本一致，这里就不重复写了。\nstack stack就是数据结构中的栈，数据是“后进先出”。\n基本函数  push：入栈 pop：出栈 top：取栈顶元素  要注意的是，使用pop()出栈并不会返回被删除的元素值，如果想要需要先top()一下\nqueue queue就是数据结构里的队列，数据符合“先进先出”的规则。\n基本函数   push：入队\n  pop：出队\n  front：取队首\n  priority_queue 优先队列，将按照优先级来排序，取队首的front()的函数将换为top()。该容器也定义在头文件\u0026lt;queue\u0026gt;里。\n对于自定义数据类型的队列，需要定义\u0026lt;运算。对于已经定义过的数据类型，我们可以通过定义一个结构体，在其中重载()运算符来看起来像一个函数，例如：\nstruct cmp { bool operator()(const int a, const int b) const { return abs(a) \u0026lt; abs(b); } }; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, cmp\u0026gt; p_queue; 这样就定义了一个绝对值大小优先的队列\n","date":"2021-01-31T20:39:29+08:00","image":"https://lbqaq.top/p/%E7%AB%9E%E8%B5%9B%E7%94%A8stl%E6%95%B4%E7%90%86/85526504_huffc36122ca7f2f624d334d6d5c5a83e7_1825704_120x120_fill_q75_box_smart1.jpg","permalink":"https://lbqaq.top/p/%E7%AB%9E%E8%B5%9B%E7%94%A8stl%E6%95%B4%E7%90%86/","title":"竞赛用STL整理"},{"content":"考前整理的算法，也顺便放到博客上吧ヾ(•ω•`)o\n数据结构代码复习 3.单链表逆置 带头结点\nint Inverse_Link(LinkList *L) { LinkList *cur, *p; if (L-\u0026gt;next \u0026amp;\u0026amp; L-\u0026gt;next-\u0026gt;next) { p = L-\u0026gt;next-\u0026gt;next; L-\u0026gt;next-\u0026gt;next = NULL; while (p) { cur = L-\u0026gt;next; L-\u0026gt;next = p; p = p-\u0026gt;next; L-\u0026gt;next-\u0026gt;next = cur; } } return 0; } 5.双向链表 双链表定义：\ntypedef struct DuLinkList { int data; struct DuLinkList *prior; struct DuLinkList *next; } DuLinkList; 遍历：\nvoid Printlist_DuL(DuLinkList *L) { DuLinkList *s; s = L-\u0026gt;next; if (L-\u0026gt;next != NULL) { printf(\u0026#34;当前的双向链表值为：\u0026#34;); do { printf(\u0026#34;%d \u0026#34;, s-\u0026gt;data); s = s-\u0026gt;next; } while (s != NULL); } printf(\u0026#34;\\n\u0026#34;); } 交换：\nint ListSwap_DuL(DuLinkList *L, int i) { //在带头结点的双向链表中交换第i个，i+1个位置的元素  DuLinkList *p = L, *q; int j = 0; while (p \u0026amp;\u0026amp; j \u0026lt; i - 1) { p = p-\u0026gt;next; j += 1; } if (!p || j \u0026gt; i - 1) return -1; p = p-\u0026gt;next; q = p-\u0026gt;next; p-\u0026gt;prior-\u0026gt;next = q; //1 -\u0026gt;q p 2  q-\u0026gt;prior = p-\u0026gt;prior; //1\u0026lt;--\u0026gt;q p 2  p-\u0026gt;next = q-\u0026gt;next; //1\u0026lt;--\u0026gt;q p -\u0026gt;2  q-\u0026gt;next-\u0026gt;prior = p; //1\u0026lt;--\u0026gt;q p\u0026lt;--\u0026gt;2  q-\u0026gt;next = p; //1\u0026lt;--\u0026gt;q -\u0026gt;p\u0026lt;--\u0026gt;2  p-\u0026gt;prior = q; //1\u0026lt;--\u0026gt;q\u0026lt;--\u0026gt;p\u0026lt;--\u0026gt;2  return 0; } 6.链表回文 bool isPalindrome(struct ListNode *head) { Lstack *s; int e; struct ListNode *p = head; s = (Lstack *)malloc(sizeof(Lstack)); Initlist_Stack(s); while (p) { push(s, p-\u0026gt;val); p = p-\u0026gt;next; } p = head; while (p) { e = pop(s); if (p-\u0026gt;val != e) break; p = p-\u0026gt;next; } if (p) return false; else return true; } 7-1.链队列 定义：\ntypedef struct QNode //队列 { int data; struct QNode *next; } QNode; typedef struct LinkQueue //对列相关的指针 { QNode *front; //对头指针  QNode *rear; //队尾指针 } LinkQueue; 插入：\nint EnQueue(LinkQueue *q, int e) { //[入队]将元素e放入队尾，带头结点  QNode *p; p = (QNode *)malloc(sizeof(QNode)); p-\u0026gt;data = e; p-\u0026gt;next = NULL; q-\u0026gt;rear-\u0026gt;next = p; q-\u0026gt;rear = p; return 0; } 7-2.循环链表 插入和普通单链表没区别，这里就列举部分\ns = (LinkList *)malloc(sizeof(LinkList)); s-\u0026gt;data = e; s-\u0026gt;next = p-\u0026gt;next; p-\u0026gt;next = s; 8.求二叉树各种数的算法 （1）求高度 高度很简单，来个递归就完事了\nint BiTreeHeight(BiTNode *T) { //求二叉树的高度  int treeHeight = 0; if (T != NULL) { int leftHeight = BiTreeHeight(T-\u0026gt;lchild); int rightHeight = BiTreeHeight(T-\u0026gt;rchild); treeHeight = leftHeight \u0026gt;= rightHeight ? leftHeight + 1 : rightHeight + 1; } return treeHeight; } （2）求叶子数 叶子数也一样，递归永远滴神\nvoid BiTreeLeafCount(BiTNode *T, int *count) { //求二叉树叶子结点数  if (!T) return; if (T-\u0026gt;lchild == NULL \u0026amp;\u0026amp; T-\u0026gt;rchild == NULL) *count += 1; BiTreeLeafCount(T-\u0026gt;lchild, count); BiTreeLeafCount(T-\u0026gt;rchild, count); } （3）求结点数 这不就遍历嘛，直接看下面吧=￣ω￣=\n9.二叉树的中序遍历 递归：\nint InOrderTraverse(BiTNode *T) { //中序遍历二叉树T的递归算法  if (T == NULL) return 0; InOrderTraverse(T-\u0026gt;lchild); printf(\u0026#34;%c \u0026#34;, T-\u0026gt;data); InOrderTraverse(T-\u0026gt;rchild); } 非递归（重要）：\nint inorder(BiTNode *T) { //中序遍历二叉树T的非递归算法  BiTNode *s[MAXSIZE + 1]; int top = 0; while (T != NULL || top != 0) { while (T != NULL) { s[++top] = T; T = T-\u0026gt;lchild; } if (top != 0) { T = s[top--]; printf(\u0026#34;%c \u0026#34;, T-\u0026gt;data); T = T-\u0026gt;rchild; } } return 0; } 10.二叉排序树 int Search_BST(BSTree t, int key, BSTree f, BSTree *p) { //在指针t所指的二叉排序树上查找key，成功则p指向该元素数据结点并返回0  //否则p指向查找路径上最后一个结点并返回1，f指向T的双亲，初始值为NULL  if (!t) { *p = f; return 1; } else if (key == t-\u0026gt;data) { *p = t; return 0; } else if (key \u0026lt; t-\u0026gt;data) { return Search_BST(t-\u0026gt;lchild, key, t, p); } else return Search_BST(t-\u0026gt;rchild, key, t, p); } int Insert_BST(BSTree *t, int key) { //二叉排序树的插入，当不存在key时插入并返回0，否则返回1  BSTree p, s; p = NULL; if (Search_BST(*t, key, NULL, \u0026amp;p)) { s = (BSTree)malloc(sizeof(BSTNode)); s-\u0026gt;data = key; s-\u0026gt;lchild = s-\u0026gt;rchild = NULL; if (!p) *t = s; else if (key \u0026lt; p-\u0026gt;data) p-\u0026gt;lchild = s; else p-\u0026gt;rchild = s; return 0; } else return 1; } 14.图的遍历 （1）深度优先 入栈时打印结点信息\n递归：\nvoid DFS(ALGraph *G, int v, int visited[]) { ArcNode *p; int w, i; visited[v] = 1; printf(\u0026#34;%d \u0026#34;, v); p = G-\u0026gt;vertices[v].firstarc; while (p != NULL) { w = p-\u0026gt;adjvex; if (visited[w] == 0) DFS(G, w, visited); p = p-\u0026gt;nextarc; } } 非递归：\nvoid DFS1(ALGraph *G, int v) { ArcNode *p; int w, i; int visited[MAX_VERTEX_NUM]; ArcNode *s[MAX_VERTEX_NUM]; //顺序栈  int top = 0; for (i = 1; i \u0026lt;= G-\u0026gt;vexnum; i++) visited[i] = 0; //访问标志数组初始化  visited[v] = 1; printf(\u0026#34;%2d\u0026#34;, v); p = G-\u0026gt;vertices[v].firstarc; while (p != NULL || top != 0) { while (p != NULL) { w = p-\u0026gt;adjvex; if (visited[w] == 0) { printf(\u0026#34;%2d\u0026#34;, w); visited[w] = 1; s[++top] = p; p = G-\u0026gt;vertices[w].firstarc; } else p = p-\u0026gt;nextarc; } if (top != 0) { p = s[top--]; p = p-\u0026gt;nextarc; } } } （2）广度优先 出队列时打印结点信息\nvoid BFS(ALGraph *G, int v) { ArcNode *p; int w, i; int queue[MAX_VERTEX_NUM], front = 0, rear = 0; // 定义循环队列  int visited[MAX_VERTEX_NUM]; for (i = 1; i \u0026lt;= G-\u0026gt;vexnum; i++) visited[i] = 0; //访问标志数组初始化  printf(\u0026#34;%2d\u0026#34;, v); //输出被访问顶点的编号  visited[v] = 1; //置已访问标记  rear = (rear + 1) % MAX_VERTEX_NUM; queue[rear] = v; //v进队  while (front != rear) // 队列不空时循环  { front = (front + 1) % MAX_VERTEX_NUM; w = queue[front]; //出队并赋给w  p = G-\u0026gt;vertices[w].firstarc; //找w的第一个的邻接点  while (p != NULL) { if (visited[p-\u0026gt;adjvex] == 0) { printf(\u0026#34;%2d\u0026#34;, p-\u0026gt;adjvex); //访问之  visited[p-\u0026gt;adjvex] = 1; rear = (rear + 1) % MAX_VERTEX_NUM; //相邻顶点进队  queue[rear] = p-\u0026gt;adjvex; } p = p-\u0026gt;nextarc; //找下一个邻接顶点  } } } 15.双向冒泡 void BubbleSort1(int R[], int n) { //双向冒泡  int i, j, lastExchange, lastExchange1, i1, temp; i = n; //i 指示无序序列中最后一个记录的位置  i1 = 1; while (i \u0026gt; i1) { lastExchange = 1; //记录正序最后一次交换发生的位置  lastExchange1 = n; //记录逆序最后一次交换发生的位置  for (j = i1; j \u0026lt; i; j++) if (R[j] \u0026gt; R[j + 1]) { temp = R[j]; R[j] = R[j + 1]; R[j + 1] = temp; //逆序时交换  lastExchange = j; } for (j = lastExchange; j \u0026gt; i1; j--) if (R[j] \u0026lt; R[j - 1]) { temp = R[j]; R[j] = R[j - 1]; R[j - 1] = temp; //逆序时交换  lastExchange1 = j; } i = lastExchange; i1 = lastExchange1; } } ","date":"2021-01-10T15:06:20+08:00","image":"https://lbqaq.top/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/83667969_hu38d2b1a912e76eab4c1b90daa958e1cd_1812230_120x120_fill_box_smart1_3.png","permalink":"https://lbqaq.top/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/","title":"数据结构算法复习"},{"content":"生成随机数 在C语言中，生成随机数可以使用stdlib.h头文件里的rand()来生成，例如：\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;int main(){ int a = rand(); printf(\u0026#34;%d\\n\u0026#34;,a); return 0; } rand() 会随机生成一个位于 0 ~ RAND_MAX 之间的整数。\n但是这样生成的随机数每次开启程序都是一样的，则需要使用srand()来重新播种，一般常与\u0026lt;time.h\u0026gt;里的time()函数一起使用。\nsrand((unsigned)time(NULL)); 连续生成多个随机数 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;time.h\u0026gt;int main() { int a, i; srand((unsigned)time(NULL)); //使用for循环生成10个随机数  for (i = 0; i \u0026lt; 10; i++) { a = rand(); printf(\u0026#34;%d \u0026#34;, a); } return 0; } 生成指定范围的随机数 想要生成指定范围的随机数，只要进行%运算就好了\nint a = rand() % 10; //产生0~9的随机数 int a = rand() % 10 + 1; //产生1~10的随机数 连续生成不重复的随机数 这就是本文的重点了ヾ(•ω•`)o （其实就是为了记下这个算法才水了一篇文章）\nint *GetRandom(int m) { //根据给定的m生成随机不重复的数组a  int i, n, w, t; int *a; n = 2 * m; srand((unsigned int)time(0)); a = (int *)malloc(n * sizeof(int)); for (i = 0; i \u0026lt; n; i++) a[i] = i + 1; for (i = 1; i \u0026lt;= m; i++) { w = rand() % (n - i) + i; t = a[i]; a[i] = a[w]; a[w] = t; } return a; } ","date":"2020-12-22T19:36:53+08:00","image":"https://lbqaq.top/p/c%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/84444030_hu7ef2fd02297b262112d9bbc23507151d_2022394_120x120_fill_box_smart1_3.png","permalink":"https://lbqaq.top/p/c%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/","title":"C语言生成随机数"},{"content":"基本操作 建立版本库：git init\n查看结果：git status\n查看不同：git diff\n版本回退 查看提交日记：git log\n回退：git reset --hard HEAD^\nHEAD^表示上一个版本，HEAD^^表示前两个版本，HEAD~100表示前100个版本\n恢复：git reflog查看命令历史，确定回到未来的哪个版本\n撤销修改  直接丢弃工作区的修改时，用命令git checkout -- file 已经添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD \u0026lt;file\u0026gt;，第二步按1操作。  上传 git remote add origin 仓库链接 #将远程仓库和本地仓库绑定 git add . git commit -m \u0026quot;提交信息\u0026quot; git push -u origin 自己当前的分支名 #-u将本地库和远程库的分支关联，之后可以不加 下载 git clone 仓库链接 git clone到当前文件夹\ngit clone 仓库链接 . 分支管理 创建与合并分支 查看分支：git branch\n创建分支：git branch \u0026lt;name\u0026gt;\n切换分支：git checkout \u0026lt;name\u0026gt;或者git switch \u0026lt;name\u0026gt;\n创建+切换分支：git checkout -b \u0026lt;name\u0026gt;或者git switch -c \u0026lt;name\u0026gt;\n删除分支：git branch -d \u0026lt;name\u0026gt;\n合并某分支到当前分支：git merge \u0026lt;name\u0026gt;\n 当Git无法自动合并分支时，就必须首先解决冲突，自己手动修改冲突文件再合并即可。 查看分支合并图：git log --graph 使用非快速模式合并，有commit：git merge --no-ff -m \u0026quot;merge with no-ff\u0026quot; dev  Bug分支 需要紧急处理Bug时，可以使用git stash将现在的工作区暂存\n恢复原来的工作区\n 恢复但不删除stash内容：git stash apply 手动删除stash内容：git stash drop 恢复且删除stash内容：git stash pop  可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，如：\ngit stash apply stash@{0} 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick \u0026lt;commit\u0026gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。\n多人协作   查看远程库信息，使用git remote -v\n  从本地推送分支，使用git push origin branch-name\n  如果冲突，先git pull抓取远程的新提交，处理好后再push\n  在本地创建和远程分支对应的分支：git checkout -b branch-name origin/branch-name\n  建立本地分支和远程分支的关联：git branch --set-upstream branch-name origin/branch-name\n  将非直线的提交日记变为直线：git rebase\n  标签管理 创建标签   新建一个标签：git tag \u0026lt;name\u0026gt;,默认为HEAD，也可以指定一个commit id\n  指定标签信息：git tag -a \u0026lt;tagname\u0026gt; -m \u0026quot;blablabla...\u0026quot;\n  查看所有标签：git tag\n  标签管理  推送一个本地标签：git push origin \u0026lt;tagname\u0026gt; 推送全部未推送过的本地标签：git push origin --tags 删除一个本地标签：git tag -d \u0026lt;tagname\u0026gt; 删除一个远程标签：git push origin :refs/tags/\u0026lt;tagname\u0026gt;  ","date":"2020-12-16T13:16:45+08:00","image":"https://lbqaq.top/p/git/79008828_hu0acf08fa0a8e929040b98749b2927875_1528743_120x120_fill_q75_box_smart1.jpg","permalink":"https://lbqaq.top/p/git/","title":"Git的常用命令"},{"content":"主题相关 FrontMatter 字段含义\ntitle: 标题 description: 描述 image: 显示的特色图片 comments: 显示 / 隐藏评论区(T/F) license: 文章协议 输入 false 可以隐藏 hidden: 隐藏文章（不在首页，归档等页面显示，但是可以直接通过链接访问） math: 是否加载 KaTeX 脚本 slug: 固定链接 draft: 是否为草稿 categories: 分类 tags: 标签 lastmod: 上次更新时间 MarkDown相关 # 我是一级标题 ## 我是二级标题 可对应1-6级标题 *斜体文本* **粗体文本** ***粗斜体文本*** 一行中用三个以上的星号*、减号-、底线_来建立一个分隔线 ~~删除线~~ \u0026lt;u\u0026gt;带下划线文本\u0026lt;/u\u0026gt; 创建脚注格式类似这样 [^JiaoZhu]。 [^JiaoZhu]: 脚注的内容 列表：*、+、-、1. \u0026gt; 区块 [链接文本](网址) 图片在前加! | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 ","date":"2020-12-15T18:02:14+08:00","image":"https://lbqaq.top/p/blog%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/80228475_hueadf3bffe35dbd99d1cbacd445bc351e_1641954_120x120_fill_q75_box_smart1.jpg","permalink":"https://lbqaq.top/p/blog%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/","title":"Blog常用的命令"}]